<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>KeyPerfect - Music Ear Training</title>
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <script src="https://unpkg.com/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Animated gradient background */
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(-45deg, #0f0c29, #302b63, #24243e, #0f0c29);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      min-height: 100vh;
      color: white;
      overflow-x: hidden;
    }
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #root { min-height: 100vh; }
    select option { background: #1a1a2e; color: white; }

    /* Glassmorphism base */
    .glass {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    /* Button with ripple effect */
    .btn-press {
      position: relative;
      overflow: hidden;
      transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.15s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .btn-press:active {
      transform: scale(0.97);
    }
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.4);
      transform: scale(0);
      animation: rippleEffect 0.6s linear;
      pointer-events: none;
    }
    @keyframes rippleEffect {
      to { transform: scale(4); opacity: 0; }
    }

    /* Prevent text selection on buttons */
    button, .btn-press {
      -webkit-user-select: none;
      user-select: none;
    }

    /* Enhanced skeleton loading */
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.05) 25%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.05) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 16px;
    }

    /* Toast animations */
    @keyframes slideIn {
      from { transform: translateY(-100%) scale(0.8); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateY(0) scale(1); opacity: 1; }
      to { transform: translateY(-100%) scale(0.8); opacity: 0; }
    }
    .toast-enter { animation: slideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; }
    .toast-exit { animation: slideOut 0.3s ease forwards; }

    /* Page transitions */
    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .page-enter {
      animation: fadeSlideIn 0.4s ease forwards;
    }

    /* Swipe container */
    .swipe-container {
      overflow: hidden;
      touch-action: pan-y;
    }

    /* Floating button pulse */
    @keyframes pulse {
      0%, 100% { box-shadow: 0 8px 30px rgba(139, 92, 246, 0.5), 0 0 0 0 rgba(139, 92, 246, 0.4); }
      50% { box-shadow: 0 12px 40px rgba(139, 92, 246, 0.7), 0 0 0 10px rgba(139, 92, 246, 0); }
    }
    .floating-btn {
      animation: pulse 2s ease-in-out infinite;
    }

    /* Confetti animation */
    @keyframes confettiFall {
      0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      top: -10px;
      animation: confettiFall 3s linear forwards;
      z-index: 9999;
      pointer-events: none;
    }

    /* Shake animation for wrong answers */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake {
      animation: shake 0.5s ease-in-out;
    }

    /* Success checkmark animation */
    @keyframes successPop {
      0% { transform: scale(0) rotate(-45deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(-45deg); }
      100% { transform: scale(1) rotate(-45deg); opacity: 1; }
    }
    .success-check {
      animation: successPop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
    }

    /* Fire/streak animation */
    @keyframes fireGlow {
      0%, 100% { filter: drop-shadow(0 0 5px #ff6b35) drop-shadow(0 0 10px #ff6b35); transform: scale(1); }
      50% { filter: drop-shadow(0 0 15px #ff6b35) drop-shadow(0 0 25px #ff6b35); transform: scale(1.1); }
    }
    .fire-glow {
      animation: fireGlow 0.5s ease-in-out infinite;
    }

    /* Number count up */
    @keyframes countPop {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    .count-pop {
      animation: countPop 0.3s ease;
    }

    /* Progress ring animation */
    @keyframes progressFill {
      from { stroke-dashoffset: 283; }
    }
    .progress-ring-circle {
      transition: stroke-dashoffset 0.5s ease;
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
    }

    /* Accordion animation */
    .accordion-content {
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
    }

    /* Achievement unlock animation */
    @keyframes achievementUnlock {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(10deg); }
      70% { transform: scale(0.9) rotate(-5deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    .achievement-unlock {
      animation: achievementUnlock 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
    }

    /* Badge shine effect */
    @keyframes badgeShine {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }
    .badge-shine {
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%);
      background-size: 200% 100%;
      animation: badgeShine 2s ease-in-out infinite;
    }

    /* Waveform animation */
    @keyframes waveform {
      0%, 100% { height: 20%; }
      50% { height: 100%; }
    }
    .waveform-bar {
      animation: waveform 0.5s ease-in-out infinite;
    }

    /* Nav pill indicator */
    .nav-pill {
      position: absolute;
      bottom: 0;
      height: 3px;
      background: linear-gradient(90deg, #a855f7, #ec4899);
      border-radius: 3px 3px 0 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Bottom nav safe area */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .bottom-nav { padding-bottom: calc(12px + env(safe-area-inset-bottom)); }
    }

    /* Mobile-first responsive bottom nav */
    .bottom-nav {
      display: flex !important;
      justify-content: stretch !important;
      width: 100%;
    }
    .bottom-nav button {
      flex: 1;
      min-height: 60px;
      transition: all 0.3s ease;
    }

    /* Mobile touch improvements */
    * {
      -webkit-tap-highlight-color: transparent;
    }

    input, select, button {
      font-size: 16px;
    }

    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, #a855f7, #ec4899);
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(168, 85, 247, 0.5);
    }

    /* Smooth scrolling */
    html {
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
    }

    /* Hide scrollbars on mobile */
    ::-webkit-scrollbar { display: none; }
    body {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    /* Glow effects */
    .glow-purple { box-shadow: 0 0 20px rgba(168, 85, 247, 0.5); }
    .glow-green { box-shadow: 0 0 20px rgba(34, 197, 94, 0.5); }
    .glow-red { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }

    /* Gradient text */
    .gradient-text {
      background: linear-gradient(135deg, #a855f7 0%, #ec4899 50%, #f97316 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Card hover lift */
    .card-lift {
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .card-lift:active {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }

    /* Timer animations */
    @keyframes timerPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .timer-warning {
      animation: timerPulse 0.5s ease-in-out infinite;
      color: #ef4444 !important;
    }
    @keyframes timerTick {
      0% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .timer-tick {
      animation: timerTick 0.2s ease-out;
    }

    /* Daily challenge badge */
    @keyframes dailyGlow {
      0%, 100% { box-shadow: 0 0 10px rgba(251, 191, 36, 0.5); }
      50% { box-shadow: 0 0 25px rgba(251, 191, 36, 0.8); }
    }
    .daily-badge {
      animation: dailyGlow 2s ease-in-out infinite;
    }

    /* Bonus points animation */
    @keyframes bonusFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
    }
    .bonus-float {
      animation: bonusFloat 1s ease-out forwards;
    }

    /* Speed run animations */
    @keyframes speedRunPulse {
      0%, 100% { box-shadow: 0 0 10px rgba(236, 72, 153, 0.5); }
      50% { box-shadow: 0 0 30px rgba(236, 72, 153, 0.8), 0 0 60px rgba(236, 72, 153, 0.4); }
    }
    .speed-run-active {
      animation: speedRunPulse 1s ease-in-out infinite;
    }
    @keyframes scorePopIn {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    .score-pop {
      animation: scorePopIn 0.3s ease-out;
    }

    /* Survival mode animations */
    @keyframes heartBeat {
      0%, 100% { transform: scale(1); }
      15% { transform: scale(1.3); }
      30% { transform: scale(1); }
      45% { transform: scale(1.2); }
    }
    .heart-beat {
      animation: heartBeat 1s ease-in-out;
    }
    @keyframes loseLife {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    .lose-life {
      animation: loseLife 0.5s ease-out forwards;
    }

    /* Quest completion animation */
    @keyframes questComplete {
      0% { transform: scale(1); background: rgba(251, 191, 36, 0.2); }
      50% { transform: scale(1.02); background: rgba(251, 191, 36, 0.4); }
      100% { transform: scale(1); background: rgba(34, 197, 94, 0.3); }
    }
    .quest-complete {
      animation: questComplete 0.5s ease-out forwards;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, createContext, useContext, useRef } = React;

    // ============================================
    // CONSTANTS & CONFIGURATION
    // ============================================

    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NATURAL_NOTES = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
    const OCTAVES = [3, 4, 5];

    const INTERVALS = {
      0: { name: 'Unison', short: 'P1', songs: ['Same note repeated'] },
      1: { name: 'Minor 2nd', short: 'm2', songs: ['Jaws theme', 'Pink Panther'] },
      2: { name: 'Major 2nd', short: 'M2', songs: ['Happy Birthday', 'FrÃ¨re Jacques'] },
      3: { name: 'Minor 3rd', short: 'm3', songs: ['Greensleeves', 'Hey Jude (verse)'] },
      4: { name: 'Major 3rd', short: 'M3', songs: ['When the Saints', 'Kumbaya'] },
      5: { name: 'Perfect 4th', short: 'P4', songs: ['Here Comes the Bride', 'Amazing Grace'] },
      6: { name: 'Tritone', short: 'TT', songs: ['The Simpsons', 'Maria (West Side Story)'] },
      7: { name: 'Perfect 5th', short: 'P5', songs: ['Star Wars', 'Twinkle Twinkle'] },
      8: { name: 'Minor 6th', short: 'm6', songs: ['The Entertainer', 'Love Story theme'] },
      9: { name: 'Major 6th', short: 'M6', songs: ['NBC chimes', 'My Bonnie'] },
      10: { name: 'Minor 7th', short: 'm7', songs: ['Star Trek theme', 'Somewhere (West Side)'] },
      11: { name: 'Major 7th', short: 'M7', songs: ['Take On Me', 'Superman theme'] },
      12: { name: 'Octave', short: 'P8', songs: ['Somewhere Over the Rainbow', 'Singin\' in the Rain'] },
    };

    // Achievement Badges
    const ACHIEVEMENTS = {
      first_correct: { id: 'first_correct', name: 'First Steps', description: 'Get your first correct answer', icon: 'ðŸŒŸ', requirement: (stats) => Object.values(stats).some(s => s.totalCorrect >= 1) },
      streak_5: { id: 'streak_5', name: 'On Fire', description: 'Get a 5 streak', icon: 'ðŸ”¥', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 5) },
      streak_10: { id: 'streak_10', name: 'Unstoppable', description: 'Get a 10 streak', icon: 'ðŸ’«', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 10) },
      streak_25: { id: 'streak_25', name: 'Legendary', description: 'Get a 25 streak', icon: 'ðŸ‘‘', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 25) },
      correct_50: { id: 'correct_50', name: 'Getting Started', description: 'Answer 50 questions correctly', icon: 'ðŸ“š', requirement: (stats) => Object.values(stats).reduce((sum, s) => sum + (s.totalCorrect || 0), 0) >= 50 },
      correct_100: { id: 'correct_100', name: 'Dedicated', description: 'Answer 100 questions correctly', icon: 'ðŸŽ¯', requirement: (stats) => Object.values(stats).reduce((sum, s) => sum + (s.totalCorrect || 0), 0) >= 100 },
      correct_500: { id: 'correct_500', name: 'Expert', description: 'Answer 500 questions correctly', icon: 'ðŸ†', requirement: (stats) => Object.values(stats).reduce((sum, s) => sum + (s.totalCorrect || 0), 0) >= 500 },
      all_modes: { id: 'all_modes', name: 'Well Rounded', description: 'Play all 5 game modes', icon: 'ðŸŽ­', requirement: (stats) => Object.keys(GAME_MODES).every(mode => stats[mode]?.totalAnswered > 0) },
      perfect_10: { id: 'perfect_10', name: 'Perfect Ten', description: 'Get 10 correct in a row in any mode', icon: 'ðŸ’¯', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 10) },
      interval_master: { id: 'interval_master', name: 'Interval Master', description: 'Answer 50 interval questions correctly', icon: 'â†”ï¸', requirement: (stats) => stats.intervals?.totalCorrect >= 50 },
      chord_master: { id: 'chord_master', name: 'Chord Master', description: 'Answer 50 chord questions correctly', icon: 'ðŸŽ¹', requirement: (stats) => stats.chords?.totalCorrect >= 50 },
      scale_master: { id: 'scale_master', name: 'Scale Master', description: 'Answer 50 scale questions correctly', icon: 'ðŸŽ¼', requirement: (stats) => stats.scales?.totalCorrect >= 50 },
    };

    // Guitar chord fingerings (fret positions: -1 = muted, 0 = open, 1-5 = fret number)
    const GUITAR_CHORDS = {
      'C': { name: 'C Major', frets: [-1, 3, 2, 0, 1, 0], fingers: [0, 3, 2, 0, 1, 0] },
      'D': { name: 'D Major', frets: [-1, -1, 0, 2, 3, 2], fingers: [0, 0, 0, 1, 3, 2] },
      'E': { name: 'E Major', frets: [0, 2, 2, 1, 0, 0], fingers: [0, 2, 3, 1, 0, 0] },
      'G': { name: 'G Major', frets: [3, 2, 0, 0, 0, 3], fingers: [2, 1, 0, 0, 0, 3] },
      'A': { name: 'A Major', frets: [-1, 0, 2, 2, 2, 0], fingers: [0, 0, 1, 2, 3, 0] },
      'Am': { name: 'A Minor', frets: [-1, 0, 2, 2, 1, 0], fingers: [0, 0, 2, 3, 1, 0] },
      'Em': { name: 'E Minor', frets: [0, 2, 2, 0, 0, 0], fingers: [0, 2, 3, 0, 0, 0] },
      'Dm': { name: 'D Minor', frets: [-1, -1, 0, 2, 3, 1], fingers: [0, 0, 0, 2, 3, 1] },
      'F': { name: 'F Major', frets: [1, 3, 3, 2, 1, 1], fingers: [1, 3, 4, 2, 1, 1], barre: true },
      'Bm': { name: 'B Minor', frets: [-1, 2, 4, 4, 3, 2], fingers: [0, 1, 3, 4, 2, 1], barre: true },
      'C7': { name: 'C7', frets: [-1, 3, 2, 3, 1, 0], fingers: [0, 3, 2, 4, 1, 0] },
      'G7': { name: 'G7', frets: [3, 2, 0, 0, 0, 1], fingers: [3, 2, 0, 0, 0, 1] },
    };

    const CHORD_TYPES = {
      major: { name: 'Major', intervals: [0, 4, 7], symbol: '' },
      minor: { name: 'Minor', intervals: [0, 3, 7], symbol: 'm' },
      diminished: { name: 'Diminished', intervals: [0, 3, 6], symbol: 'dim' },
      augmented: { name: 'Augmented', intervals: [0, 4, 8], symbol: 'aug' },
      major7: { name: 'Major 7th', intervals: [0, 4, 7, 11], symbol: 'maj7' },
      minor7: { name: 'Minor 7th', intervals: [0, 3, 7, 10], symbol: 'm7' },
      dominant7: { name: 'Dominant 7th', intervals: [0, 4, 7, 10], symbol: '7' },
      sus2: { name: 'Suspended 2nd', intervals: [0, 2, 7], symbol: 'sus2' },
      sus4: { name: 'Suspended 4th', intervals: [0, 5, 7], symbol: 'sus4' },
    };

    const CHORD_INVERSIONS = {
      root: { name: 'Root Position', description: 'Root note is the bass', offset: 0 },
      first: { name: '1st Inversion', description: '3rd is the bass note', offset: 1 },
      second: { name: '2nd Inversion', description: '5th is the bass note', offset: 2 },
    };

    // Daily quest templates
    const QUEST_TEMPLATES = [
      { id: 'streak_5', description: 'Get a 5 streak in any mode', target: 5, type: 'streak', icon: 'ðŸ”¥' },
      { id: 'streak_10', description: 'Get a 10 streak in any mode', target: 10, type: 'streak', icon: 'ðŸ”¥' },
      { id: 'correct_10', description: 'Answer 10 questions correctly', target: 10, type: 'correct', icon: 'âœ“' },
      { id: 'correct_25', description: 'Answer 25 questions correctly', target: 25, type: 'correct', icon: 'âœ“' },
      { id: 'play_intervals', description: 'Play 5 interval questions', target: 5, type: 'mode_intervals', icon: 'â†”ï¸' },
      { id: 'play_chords', description: 'Play 5 chord questions', target: 5, type: 'mode_chords', icon: 'ðŸŽ¹' },
      { id: 'play_scales', description: 'Play 5 scale questions', target: 5, type: 'mode_scales', icon: 'ðŸŽ¼' },
      { id: 'perfect_round', description: 'Get 5 correct in a row', target: 5, type: 'streak', icon: 'ðŸ’¯' },
      { id: 'speed_run', description: 'Complete a Speed Run', target: 1, type: 'speedrun', icon: 'âš¡' },
      { id: 'daily_challenge', description: 'Complete the Daily Challenge', target: 1, type: 'daily', icon: 'ðŸ“…' },
    ];

    const SCALE_TYPES = {
      major: { name: 'Major', intervals: [0, 2, 4, 5, 7, 9, 11, 12], description: 'Happy, bright sound' },
      natural_minor: { name: 'Natural Minor', intervals: [0, 2, 3, 5, 7, 8, 10, 12], description: 'Sad, dark sound' },
      harmonic_minor: { name: 'Harmonic Minor', intervals: [0, 2, 3, 5, 7, 8, 11, 12], description: 'Exotic, Middle Eastern feel' },
      melodic_minor: { name: 'Melodic Minor', intervals: [0, 2, 3, 5, 7, 9, 11, 12], description: 'Jazz minor scale' },
      pentatonic_major: { name: 'Major Pentatonic', intervals: [0, 2, 4, 7, 9, 12], description: 'Folk, country sound' },
      pentatonic_minor: { name: 'Minor Pentatonic', intervals: [0, 3, 5, 7, 10, 12], description: 'Blues, rock sound' },
      blues: { name: 'Blues', intervals: [0, 3, 5, 6, 7, 10, 12], description: 'Blues with blue note' },
      dorian: { name: 'Dorian', intervals: [0, 2, 3, 5, 7, 9, 10, 12], description: 'Minor with raised 6th' },
      mixolydian: { name: 'Mixolydian', intervals: [0, 2, 4, 5, 7, 9, 10, 12], description: 'Major with flat 7th' },
      phrygian: { name: 'Phrygian', intervals: [0, 1, 3, 5, 7, 8, 10, 12], description: 'Spanish, flamenco sound' },
    };

    const PROGRESSIONS = {
      'I-IV-V-I': { name: 'I - IV - V - I', chords: ['major', 'major', 'major', 'major'], degrees: [0, 5, 7, 0], description: 'Classic rock/pop progression' },
      'I-V-vi-IV': { name: 'I - V - vi - IV', chords: ['major', 'major', 'minor', 'major'], degrees: [0, 7, 9, 5], description: 'Pop punk, modern pop' },
      'ii-V-I': { name: 'ii - V - I', chords: ['minor', 'major', 'major'], degrees: [2, 7, 0], description: 'Jazz standard progression' },
      'I-vi-IV-V': { name: 'I - vi - IV - V', chords: ['major', 'minor', 'major', 'major'], degrees: [0, 9, 5, 7], description: '50s doo-wop progression' },
      'vi-IV-I-V': { name: 'vi - IV - I - V', chords: ['minor', 'major', 'major', 'major'], degrees: [9, 5, 0, 7], description: 'Emotional pop progression' },
      'I-IV-vi-V': { name: 'I - IV - vi - V', chords: ['major', 'major', 'minor', 'major'], degrees: [0, 5, 9, 7], description: 'Axis progression variant' },
      'i-VI-III-VII': { name: 'i - VI - III - VII', chords: ['minor', 'major', 'major', 'major'], degrees: [0, 8, 3, 10], description: 'Andalusian cadence' },
      'I-V-IV-V': { name: 'I - V - IV - V', chords: ['major', 'major', 'major', 'major'], degrees: [0, 7, 5, 7], description: 'Country/folk progression' },
    };

    const INSTRUMENTS = {
      piano: { name: 'Piano', midi: 'acoustic_grand_piano', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.4, release: 1.5 } } },
      electric_piano: { name: 'Electric Piano', midi: 'electric_piano_1', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.3, release: 1.2 } } },
      synth: { name: 'Synth', midi: 'synth_brass_1', config: { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.8 } } },
      organ: { name: 'Organ', midi: 'church_organ', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.3 } } },
      strings: { name: 'Strings', midi: 'string_ensemble_1', config: { oscillator: { type: 'fatsawtooth', spread: 20, count: 3 }, envelope: { attack: 0.3, decay: 0.1, sustain: 0.7, release: 1.0 } } },
      cello: { name: 'Cello', midi: 'cello', config: { oscillator: { type: 'fatsawtooth', spread: 10, count: 2 }, envelope: { attack: 0.4, decay: 0.2, sustain: 0.6, release: 1.2 } } },
      bell: { name: 'Bell', midi: 'tubular_bells', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 2.0 } } },
      vibraphone: { name: 'Vibraphone', midi: 'vibraphone', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.8, sustain: 0.2, release: 2.5 } } },
      marimba: { name: 'Marimba', midi: 'marimba', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.3, sustain: 0.05, release: 0.8 } } },
      guitar: { name: 'Guitar', midi: 'acoustic_guitar_nylon', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.4, sustain: 0.2, release: 1.0 } } },
      harpsichord: { name: 'Harpsichord', midi: 'harpsichord', config: { oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.5 } } },
      brass: { name: 'Brass', midi: 'brass_section', config: { oscillator: { type: 'fatsawtooth', spread: 15, count: 2 }, envelope: { attack: 0.15, decay: 0.2, sustain: 0.6, release: 0.6 } } },
      flute: { name: 'Flute', midi: 'flute', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.1, sustain: 0.7, release: 0.5 } } },
      bass: { name: 'Bass', midi: 'acoustic_bass', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.5, release: 0.8 } } },
      pad: { name: 'Ambient Pad', midi: 'pad_2_warm', config: { oscillator: { type: 'fatsine', spread: 30, count: 3 }, envelope: { attack: 0.5, decay: 0.3, sustain: 0.8, release: 2.0 } } },
    };

    // Seventh chord types for dedicated training
    const SEVENTH_CHORD_TYPES = {
      major7: { name: 'Major 7th', intervals: [0, 4, 7, 11], symbol: 'maj7', description: 'Dreamy, jazzy sound' },
      minor7: { name: 'Minor 7th', intervals: [0, 3, 7, 10], symbol: 'm7', description: 'Smooth, mellow sound' },
      dominant7: { name: 'Dominant 7th', intervals: [0, 4, 7, 10], symbol: '7', description: 'Bluesy, tense sound' },
      diminished7: { name: 'Diminished 7th', intervals: [0, 3, 6, 9], symbol: 'dim7', description: 'Mysterious, tense sound' },
      halfDim7: { name: 'Half-Diminished 7th', intervals: [0, 3, 6, 10], symbol: 'm7b5', description: 'Jazz minor ii chord' },
      minorMaj7: { name: 'Minor Major 7th', intervals: [0, 3, 7, 11], symbol: 'mMaj7', description: 'Dramatic, film noir sound' },
    };

    // Time signatures for rhythm training
    const TIME_SIGNATURES = {
      '4/4': { name: '4/4 (Common Time)', beats: 4, subdivision: 4, pattern: [1, 0, 0.5, 0] },
      '3/4': { name: '3/4 (Waltz)', beats: 3, subdivision: 4, pattern: [1, 0, 0] },
      '6/8': { name: '6/8 (Compound Duple)', beats: 6, subdivision: 8, pattern: [1, 0, 0, 0.7, 0, 0] },
      '2/4': { name: '2/4 (March)', beats: 2, subdivision: 4, pattern: [1, 0] },
      '5/4': { name: '5/4 (Irregular)', beats: 5, subdivision: 4, pattern: [1, 0, 0.5, 0, 0] },
      '7/8': { name: '7/8 (Asymmetric)', beats: 7, subdivision: 8, pattern: [1, 0, 0.5, 0, 0.5, 0, 0] },
    };

    // Tempo ranges for tempo training
    const TEMPO_RANGES = [
      { name: 'Largo', min: 40, max: 60, description: 'Very slow' },
      { name: 'Adagio', min: 60, max: 80, description: 'Slow and stately' },
      { name: 'Andante', min: 80, max: 100, description: 'Walking pace' },
      { name: 'Moderato', min: 100, max: 120, description: 'Moderate speed' },
      { name: 'Allegro', min: 120, max: 160, description: 'Fast and bright' },
      { name: 'Presto', min: 160, max: 200, description: 'Very fast' },
    ];

    // XP levels for gamification
    const XP_LEVELS = [
      { level: 1, xpRequired: 0, title: 'Beginner', color: '#94a3b8' },
      { level: 2, xpRequired: 100, title: 'Listener', color: '#22c55e' },
      { level: 3, xpRequired: 300, title: 'Student', color: '#3b82f6' },
      { level: 4, xpRequired: 600, title: 'Apprentice', color: '#8b5cf6' },
      { level: 5, xpRequired: 1000, title: 'Musician', color: '#f59e0b' },
      { level: 6, xpRequired: 1500, title: 'Artist', color: '#ec4899' },
      { level: 7, xpRequired: 2200, title: 'Virtuoso', color: '#ef4444' },
      { level: 8, xpRequired: 3000, title: 'Master', color: '#fbbf24' },
      { level: 9, xpRequired: 4000, title: 'Maestro', color: '#a855f7' },
      { level: 10, xpRequired: 5500, title: 'Legend', color: 'linear-gradient(135deg, #fbbf24, #f59e0b, #ec4899, #a855f7)' },
    ];

    // Weekly challenge templates
    const WEEKLY_CHALLENGES = [
      { id: 'accuracy_master', name: 'Accuracy Master', description: 'Get 85% accuracy across 100 questions', target: 100, requirement: 'accuracy', threshold: 85, reward: 200, icon: 'ðŸŽ¯' },
      { id: 'streak_hunter', name: 'Streak Hunter', description: 'Achieve a 20 streak', target: 20, requirement: 'streak', reward: 150, icon: 'ðŸ”¥' },
      { id: 'mode_explorer', name: 'Mode Explorer', description: 'Play all 5 game modes', target: 5, requirement: 'modes', reward: 100, icon: 'ðŸ—ºï¸' },
      { id: 'daily_devotee', name: 'Daily Devotee', description: 'Complete 5 daily challenges this week', target: 5, requirement: 'dailies', reward: 250, icon: 'ðŸ“…' },
      { id: 'speed_demon', name: 'Speed Demon', description: 'Score 30+ in Speed Run', target: 30, requirement: 'speedrun_score', reward: 175, icon: 'âš¡' },
      { id: 'survivor', name: 'Survivor', description: 'Score 25+ in Survival Mode', target: 25, requirement: 'survival_score', reward: 175, icon: 'â¤ï¸' },
      { id: 'interval_ace', name: 'Interval Ace', description: 'Answer 50 interval questions correctly', target: 50, requirement: 'mode_correct', mode: 'intervals', reward: 125, icon: 'â†”ï¸' },
      { id: 'chord_master', name: 'Chord Master', description: 'Answer 50 chord questions correctly', target: 50, requirement: 'mode_correct', mode: 'chords', reward: 125, icon: 'ðŸŽ¹' },
    ];

    // Unlockable instruments (earned through XP)
    const UNLOCKABLE_INSTRUMENTS = {
      celesta: { name: 'Celesta', midi: 'celesta', level: 3, config: { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.2, release: 1.5 } } },
      xylophone: { name: 'Xylophone', midi: 'xylophone', level: 4, config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.05, release: 0.5 } } },
      music_box: { name: 'Music Box', midi: 'music_box', level: 5, config: { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.3, sustain: 0.1, release: 1.2 } } },
      choir: { name: 'Choir', midi: 'choir_aahs', level: 6, config: { oscillator: { type: 'fatsine', spread: 20, count: 3 }, envelope: { attack: 0.3, decay: 0.2, sustain: 0.7, release: 1.0 } } },
      kalimba: { name: 'Kalimba', midi: 'kalimba', level: 7, config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 1.8 } } },
      crystal: { name: 'Crystal', midi: 'pad_6_metallic', level: 8, config: { oscillator: { type: 'sine' }, envelope: { attack: 0.2, decay: 0.4, sustain: 0.5, release: 2.5 } } },
    };

    // Theme definitions
    const THEMES = {
      dark: {
        name: 'Dark',
        background: 'linear-gradient(-45deg, #0f0c29, #302b63, #24243e, #0f0c29)',
        cardBg: 'rgba(255, 255, 255, 0.08)',
        text: '#ffffff',
        textSecondary: '#94a3b8',
        accent: '#a855f7',
      },
      light: {
        name: 'Light',
        background: 'linear-gradient(-45deg, #f0f4f8, #e2e8f0, #f8fafc, #e2e8f0)',
        cardBg: 'rgba(0, 0, 0, 0.05)',
        text: '#1e293b',
        textSecondary: '#64748b',
        accent: '#7c3aed',
      },
      midnight: {
        name: 'Midnight',
        background: 'linear-gradient(-45deg, #0a0a0f, #1a1a2e, #16213e, #0a0a0f)',
        cardBg: 'rgba(255, 255, 255, 0.05)',
        text: '#e2e8f0',
        textSecondary: '#64748b',
        accent: '#3b82f6',
      },
      sunset: {
        name: 'Sunset',
        background: 'linear-gradient(-45deg, #1a1a2e, #4a1942, #2d1b4e, #1a1a2e)',
        cardBg: 'rgba(255, 255, 255, 0.08)',
        text: '#fef3c7',
        textSecondary: '#d4a574',
        accent: '#f97316',
      },
    };

    // Circle of fifths data
    const CIRCLE_OF_FIFTHS = [
      { major: 'C', minor: 'Am', sharps: 0, flats: 0, position: 0 },
      { major: 'G', minor: 'Em', sharps: 1, flats: 0, position: 1 },
      { major: 'D', minor: 'Bm', sharps: 2, flats: 0, position: 2 },
      { major: 'A', minor: 'F#m', sharps: 3, flats: 0, position: 3 },
      { major: 'E', minor: 'C#m', sharps: 4, flats: 0, position: 4 },
      { major: 'B', minor: 'G#m', sharps: 5, flats: 0, position: 5 },
      { major: 'F#/Gb', minor: 'D#m/Ebm', sharps: 6, flats: 6, position: 6 },
      { major: 'Db', minor: 'Bbm', sharps: 0, flats: 5, position: 7 },
      { major: 'Ab', minor: 'Fm', sharps: 0, flats: 4, position: 8 },
      { major: 'Eb', minor: 'Cm', sharps: 0, flats: 3, position: 9 },
      { major: 'Bb', minor: 'Gm', sharps: 0, flats: 2, position: 10 },
      { major: 'F', minor: 'Dm', sharps: 0, flats: 1, position: 11 },
    ];

    const GAME_MODES = {
      notes: { name: 'Note Recognition', icon: 'ðŸŽµ', description: 'Identify single notes' },
      intervals: { name: 'Interval Training', icon: 'â†”ï¸', description: 'Recognize intervals between notes' },
      chords: { name: 'Chord Recognition', icon: 'ðŸŽ¹', description: 'Identify chord types' },
      scales: { name: 'Scale Recognition', icon: 'ðŸŽ¼', description: 'Identify scale types' },
      progressions: { name: 'Chord Progressions', icon: 'ðŸ”„', description: 'Recognize chord progressions' },
    };

    const NOTE_DIFFICULTIES = {
      easy: { notes: NATURAL_NOTES, choices: 4, octaves: [4], label: 'Easy', description: 'Natural notes, single octave' },
      medium: { notes: NOTES, choices: 4, octaves: [4], label: 'Medium', description: 'All notes, single octave' },
      hard: { notes: NOTES, choices: 6, octaves: [3, 4, 5], label: 'Hard', description: 'All notes, multiple octaves' },
    };

    const INTERVAL_DIFFICULTIES = {
      easy: { intervals: [3, 4, 5, 7], choices: 4, label: 'Easy', description: '3rds, 4ths, 5ths only' },
      medium: { intervals: [1, 2, 3, 4, 5, 7, 8, 9], choices: 4, label: 'Medium', description: 'Common intervals' },
      hard: { intervals: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], choices: 6, label: 'Hard', description: 'All intervals' },
    };

    const CHORD_DIFFICULTIES = {
      easy: { chords: ['major', 'minor'], choices: 2, label: 'Easy', description: 'Major vs Minor' },
      medium: { chords: ['major', 'minor', 'diminished', 'augmented'], choices: 4, label: 'Medium', description: 'Triads' },
      hard: { chords: ['major', 'minor', 'diminished', 'augmented', 'major7', 'minor7', 'dominant7'], choices: 6, label: 'Hard', description: 'Triads & 7th chords' },
    };

    const SCALE_DIFFICULTIES = {
      easy: { scales: ['major', 'natural_minor', 'pentatonic_major'], choices: 3, label: 'Easy', description: 'Major, Minor, Pentatonic' },
      medium: { scales: ['major', 'natural_minor', 'harmonic_minor', 'pentatonic_major', 'pentatonic_minor', 'blues'], choices: 4, label: 'Medium', description: 'Common scales' },
      hard: { scales: Object.keys(SCALE_TYPES), choices: 5, label: 'Hard', description: 'All scales including modes' },
    };

    const PROGRESSION_DIFFICULTIES = {
      easy: { progressions: ['I-IV-V-I', 'I-V-vi-IV', 'I-vi-IV-V'], choices: 3, label: 'Easy', description: 'Common pop progressions' },
      medium: { progressions: ['I-IV-V-I', 'I-V-vi-IV', 'ii-V-I', 'I-vi-IV-V', 'vi-IV-I-V'], choices: 4, label: 'Medium', description: 'Pop & jazz basics' },
      hard: { progressions: Object.keys(PROGRESSIONS), choices: 5, label: 'Hard', description: 'All progressions' },
    };

    const NAV_ITEMS = [
      { id: 'play', label: 'Play', icon: 'ðŸŽ®' },
      { id: 'learn', label: 'Learn', icon: 'ðŸ“š' },
      { id: 'stats', label: 'Stats', icon: 'ðŸ“Š' },
      { id: 'settings', label: 'Settings', icon: 'âš™ï¸' },
    ];

    // ============================================
    // TOAST CONTEXT
    // ============================================

    const ToastContext = createContext();

    function ToastProvider({ children }) {
      const [toasts, setToasts] = useState([]);

      const addToast = useCallback((message, type = 'info', duration = 3000) => {
        const id = Date.now();
        setToasts(prev => [...prev, { id, message, type, exiting: false }]);
        setTimeout(() => {
          setToasts(prev => prev.map(t => t.id === id ? { ...t, exiting: true } : t));
          setTimeout(() => {
            setToasts(prev => prev.filter(t => t.id !== id));
          }, 300);
        }, duration);
      }, []);

      return (
        <ToastContext.Provider value={{ addToast }}>
          {children}
          <div style={{ position: 'fixed', top: 20, right: 20, zIndex: 1000, display: 'flex', flexDirection: 'column', gap: 10 }}>
            {toasts.map(toast => (
              <div key={toast.id} className={toast.exiting ? 'toast-exit' : 'toast-enter'}
                style={{
                  padding: '12px 20px', borderRadius: 12, fontWeight: 600, fontSize: '0.9rem',
                  backgroundColor: toast.type === 'success' ? 'rgba(34, 197, 94, 0.95)' : toast.type === 'error' ? 'rgba(239, 68, 68, 0.95)' : 'rgba(59, 130, 246, 0.95)',
                  color: 'white', boxShadow: '0 4px 20px rgba(0,0,0,0.3)', maxWidth: 280
                }}>
                {toast.message}
              </div>
            ))}
          </div>
        </ToastContext.Provider>
      );
    }

    function useToast() {
      return useContext(ToastContext);
    }

    // ============================================
    // LOCAL STORAGE HOOKS
    // ============================================

    function useLocalStorage(key, initialValue) {
      const [storedValue, setStoredValue] = useState(() => {
        try {
          const item = window.localStorage.getItem(key);
          return item ? JSON.parse(item) : initialValue;
        } catch (error) {
          return initialValue;
        }
      });

      const setValue = useCallback((value) => {
        try {
          const valueToStore = value instanceof Function ? value(storedValue) : value;
          setStoredValue(valueToStore);
          window.localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {}
      }, [key, storedValue]);

      return [storedValue, setValue];
    }

    // ============================================
    // HAPTIC FEEDBACK
    // ============================================

    function triggerHaptic(type = 'light') {
      if ('vibrate' in navigator) {
        const patterns = { light: 10, medium: 25, heavy: 50, success: [10, 50, 10], error: [50, 30, 50] };
        navigator.vibrate(patterns[type] || 10);
      }
    }

    // ============================================
    // SOUND EFFECTS
    // ============================================

    function useSoundEffects() {
      const [enabled, setEnabled] = useLocalStorage('keyperfect_sfx', true);
      const audioCtx = useRef(null);

      const playSound = useCallback((type) => {
        if (!enabled) return;
        try {
          if (!audioCtx.current) audioCtx.current = new (window.AudioContext || window.webkitAudioContext)();
          const ctx = audioCtx.current;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);

          if (type === 'success') {
            osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
            osc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.1); // E5
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.3);
          } else if (type === 'error') {
            osc.frequency.setValueAtTime(200, ctx.currentTime);
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.2);
          }
        } catch (e) {}
      }, [enabled]);

      return { playSound, sfxEnabled: enabled, setSfxEnabled: setEnabled };
    }

    // ============================================
    // AUDIO HOOK
    // ============================================

    // MIDI Audio Context for soundfont
    const audioContextRef = { current: null };
    function getAudioContext() {
      if (!audioContextRef.current) {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContextRef.current;
    }

    function useAudio(instrument, useMidi = false, volume = 0.7) {
      const [synth, setSynth] = useState(null);
      const [polySynth, setPolySynth] = useState(null);
      const [midiInstrument, setMidiInstrument] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const [isLoading, setIsLoading] = useState(true);
      const gainNodeRef = useRef(null);

      // Load synth instruments
      useEffect(() => {
        if (useMidi) return;
        setIsLoading(true);
        const config = INSTRUMENTS[instrument]?.config || INSTRUMENTS.piano.config;
        const gainNode = new Tone.Gain(volume).toDestination();
        gainNodeRef.current = gainNode;
        const newSynth = new Tone.Synth(config).connect(gainNode);
        const newPolySynth = new Tone.PolySynth(Tone.Synth, config).connect(gainNode);
        setSynth(newSynth);
        setPolySynth(newPolySynth);
        setTimeout(() => setIsLoading(false), 300);
        return () => { newSynth.dispose(); newPolySynth.dispose(); gainNode.dispose(); };
      }, [instrument, useMidi]);

      // Update volume
      useEffect(() => {
        if (gainNodeRef.current) {
          gainNodeRef.current.gain.value = volume;
        }
      }, [volume]);

      // Load MIDI instrument
      useEffect(() => {
        if (!useMidi) return;
        setIsLoading(true);
        const midiName = INSTRUMENTS[instrument]?.midi || 'acoustic_grand_piano';
        const ac = getAudioContext();
        Soundfont.instrument(ac, midiName, {
          soundfont: 'MusyngKite',
          format: 'mp3'
        }).then(inst => {
          setMidiInstrument(inst);
          setIsLoading(false);
        }).catch(err => {
          console.error('Failed to load MIDI instrument:', err);
          setIsLoading(false);
        });
      }, [instrument, useMidi]);

      const playNote = useCallback(async (note, octave = 4, duration = '2n') => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            midiInstrument.play(`${note}${octave}`, ac.currentTime, { duration: 1.5, gain: volume });
          } else if (synth) {
            await Tone.start();
            synth.triggerAttackRelease(`${note}${octave}`, duration);
          }
          setTimeout(() => setIsPlaying(false), 1500);
        } catch (err) { setIsPlaying(false); }
      }, [synth, midiInstrument, isPlaying, useMidi]);

      const playNotes = useCallback(async (notes, duration = '2n') => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            notes.forEach(note => midiInstrument.play(note, ac.currentTime, { duration: 1.8, gain: volume }));
          } else if (polySynth) {
            await Tone.start();
            polySynth.triggerAttackRelease(notes, duration);
          }
          setTimeout(() => setIsPlaying(false), 1800);
        } catch (err) { setIsPlaying(false); }
      }, [polySynth, midiInstrument, isPlaying, useMidi]);

      const playSequence = useCallback(async (notes, interval = 0.5) => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            const now = ac.currentTime;
            notes.forEach((note, i) => midiInstrument.play(note, now + i * interval, { duration: 0.4, gain: volume }));
          } else if (synth) {
            await Tone.start();
            const now = Tone.now();
            notes.forEach((note, i) => synth.triggerAttackRelease(note, '4n', now + i * interval));
          }
          setTimeout(() => setIsPlaying(false), notes.length * interval * 1000 + 500);
        } catch (err) { setIsPlaying(false); }
      }, [synth, midiInstrument, isPlaying, useMidi]);

      const playChordSequence = useCallback(async (chordNotes, interval = 0.8) => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            const now = ac.currentTime;
            chordNotes.forEach((chord, i) => {
              chord.forEach(note => midiInstrument.play(note, now + i * interval, { duration: 0.7, gain: volume }));
            });
          } else if (polySynth) {
            await Tone.start();
            const now = Tone.now();
            chordNotes.forEach((chord, i) => polySynth.triggerAttackRelease(chord, '2n', now + i * interval));
          }
          setTimeout(() => setIsPlaying(false), chordNotes.length * interval * 1000 + 800);
        } catch (err) { setIsPlaying(false); }
      }, [polySynth, midiInstrument, isPlaying, useMidi]);

      return { playNote, playNotes, playSequence, playChordSequence, isPlaying, isLoading };
    }

    // ============================================
    // STATISTICS CONTEXT
    // ============================================

    const StatsContext = createContext();

    function StatsProvider({ children }) {
      const [stats, setStats] = useLocalStorage('keyperfect_stats_v4', {
        notes: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
        intervals: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
        chords: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
        scales: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
        progressions: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
        history: [],
      });

      const recordAnswer = useCallback((mode, difficulty, correct, streak, item = null) => {
        setStats(prev => {
          const modeStats = { ...prev[mode], byItem: { ...prev[mode].byItem } };
          modeStats.totalAnswered += 1;
          if (correct) modeStats.totalCorrect += 1;
          if (streak > modeStats.bestStreak) modeStats.bestStreak = streak;
          if (!modeStats.byDifficulty[difficulty]) modeStats.byDifficulty[difficulty] = { correct: 0, total: 0 };
          modeStats.byDifficulty[difficulty].total += 1;
          if (correct) modeStats.byDifficulty[difficulty].correct += 1;
          // Track by specific item for weakness analysis
          if (item !== null) {
            const itemKey = String(item);
            if (!modeStats.byItem[itemKey]) modeStats.byItem[itemKey] = { correct: 0, total: 0 };
            modeStats.byItem[itemKey].total += 1;
            if (correct) modeStats.byItem[itemKey].correct += 1;
          }
          const newHistory = [...prev.history, { mode, difficulty, correct, item, timestamp: Date.now() }].slice(-100);
          return { ...prev, [mode]: modeStats, history: newHistory };
        });
      }, [setStats]);

      // Get weakest items for a mode (items with lowest accuracy, min 3 attempts)
      const getWeaknesses = useCallback((mode, limit = 5) => {
        const byItem = stats[mode]?.byItem || {};
        return Object.entries(byItem)
          .filter(([_, data]) => data.total >= 3)
          .map(([item, data]) => ({
            item,
            correct: data.correct,
            total: data.total,
            accuracy: Math.round((data.correct / data.total) * 100)
          }))
          .sort((a, b) => a.accuracy - b.accuracy)
          .slice(0, limit);
      }, [stats]);

      const resetStats = useCallback(() => {
        setStats({
          notes: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
          intervals: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
          chords: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
          scales: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
          progressions: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {}, byItem: {} },
          history: [],
        });
      }, [setStats]);

      return (
        <StatsContext.Provider value={{ stats, recordAnswer, resetStats, getWeaknesses }}>
          {children}
        </StatsContext.Provider>
      );
    }

    function useStats() { return useContext(StatsContext); }

    // ============================================
    // SESSION STATS CONTEXT (non-persistent, resets on refresh)
    // ============================================

    const SessionStatsContext = createContext();

    function SessionStatsProvider({ children }) {
      const [sessionStats, setSessionStats] = useState({
        totalAnswered: 0,
        totalCorrect: 0,
        currentStreak: 0,
        bestStreak: 0,
        startTime: Date.now(),
        byMode: {},
      });

      const recordSessionAnswer = useCallback((mode, correct) => {
        setSessionStats(prev => {
          const newStreak = correct ? prev.currentStreak + 1 : 0;
          const newBest = Math.max(prev.bestStreak, newStreak);
          const modeStats = prev.byMode[mode] || { correct: 0, total: 0 };
          return {
            ...prev,
            totalAnswered: prev.totalAnswered + 1,
            totalCorrect: prev.totalCorrect + (correct ? 1 : 0),
            currentStreak: newStreak,
            bestStreak: newBest,
            byMode: {
              ...prev.byMode,
              [mode]: {
                correct: modeStats.correct + (correct ? 1 : 0),
                total: modeStats.total + 1,
              },
            },
          };
        });
      }, []);

      const resetSessionStats = useCallback(() => {
        setSessionStats({
          totalAnswered: 0,
          totalCorrect: 0,
          currentStreak: 0,
          bestStreak: 0,
          startTime: Date.now(),
          byMode: {},
        });
      }, []);

      const sessionDuration = useMemo(() => {
        return Math.floor((Date.now() - sessionStats.startTime) / 1000);
      }, [sessionStats.startTime]);

      return (
        <SessionStatsContext.Provider value={{ sessionStats, recordSessionAnswer, resetSessionStats, sessionDuration }}>
          {children}
        </SessionStatsContext.Provider>
      );
    }

    function useSessionStats() { return useContext(SessionStatsContext); }

    // ============================================
    // SETTINGS CONTEXT
    // ============================================

    const SettingsContext = createContext();

    function SettingsProvider({ children }) {
      const [settings, setSettings] = useLocalStorage('keyperfect_settings_v7', {
        instrument: 'piano',
        autoPlayOnStart: true,
        showOctaveInChoices: false,
        useMidi: false,
        volume: 0.7,
        practiceMode: false,
        timedMode: false,
        timerDuration: 10,
        intervalPlayback: 'melodic', // 'melodic' or 'harmonic'
        intervalDirection: 'ascending', // 'ascending', 'descending', or 'random'
      });

      const updateSettings = useCallback((updates) => {
        setSettings(prev => ({ ...prev, ...updates }));
      }, [setSettings]);

      return (
        <SettingsContext.Provider value={{ settings, updateSettings }}>
          {children}
        </SettingsContext.Provider>
      );
    }

    function useSettings() { return useContext(SettingsContext); }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function shuffle(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Seeded random for Daily Challenge (same questions each day)
    function seededRandom(seed) {
      const x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    function getDailySeed() {
      const today = new Date();
      return today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
    }

    function seededShuffle(array, seed) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(seededRandom(seed + i) * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function getNoteIndex(note) { return NOTES.indexOf(note); }

    function buildChord(rootNote, chordType, octave = 4) {
      const rootIndex = getNoteIndex(rootNote);
      const chord = CHORD_TYPES[chordType];
      return chord.intervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        const noteOctave = octave + Math.floor((rootIndex + interval) / 12);
        return `${NOTES[noteIndex]}${noteOctave}`;
      });
    }

    function buildScale(rootNote, scaleType, octave = 4) {
      const rootIndex = getNoteIndex(rootNote);
      const scale = SCALE_TYPES[scaleType];
      return scale.intervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        const noteOctave = octave + Math.floor((rootIndex + interval) / 12);
        return `${NOTES[noteIndex]}${noteOctave}`;
      });
    }

    function buildProgression(rootNote, progressionKey, octave = 3) {
      const progression = PROGRESSIONS[progressionKey];
      const rootIndex = getNoteIndex(rootNote);
      return progression.degrees.map((degree, i) => {
        const chordRoot = NOTES[(rootIndex + degree) % 12];
        const chordOctave = octave + Math.floor((rootIndex + degree) / 12);
        return buildChord(chordRoot, progression.chords[i], chordOctave);
      });
    }

    function getShareText(stats) {
      const totalAnswered = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalAnswered, 0);
      const totalCorrect = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalCorrect, 0);
      const accuracy = totalAnswered > 0 ? Math.round((totalCorrect / totalAnswered) * 100) : 0;
      const bestStreak = Math.max(...Object.keys(GAME_MODES).map(key => stats[key].bestStreak));
      return `ðŸŽµ KeyPerfect Stats ðŸŽµ\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nðŸ“Š ${totalAnswered} questions answered\nâœ… ${accuracy}% accuracy\nðŸ”¥ ${bestStreak} best streak\n\nTrain your ear at KeyPerfect!`;
    }

    // ============================================
    // STYLES
    // ============================================

    const styles = {
      // Layout
      container: { minHeight: '100vh', display: 'flex', flexDirection: 'column', padding: '20px', paddingBottom: '110px', maxWidth: '100%', margin: '0 auto', width: '100%' },
      header: { textAlign: 'center', marginBottom: '20px', paddingTop: '10px' },
      title: { fontSize: '2rem', fontWeight: '700', marginBottom: '4px', background: 'linear-gradient(135deg, #a855f7 0%, #ec4899 50%, #f97316 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', cursor: 'pointer', letterSpacing: '-0.5px' },
      subtitle: { color: '#94a3b8', fontSize: '0.85rem', fontWeight: '500' },
      breadcrumbs: { display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '20px', fontSize: '0.9rem', color: '#94a3b8' },
      breadcrumbLink: { color: '#a855f7', cursor: 'pointer', background: 'none', border: 'none', fontSize: '0.9rem', padding: 0, fontWeight: '500' },
      breadcrumbSep: { color: '#475569' },
      breadcrumbCurrent: { color: 'white', fontWeight: '600' },

      // Cards - Glassmorphism
      card: { background: 'rgba(255, 255, 255, 0.08)', borderRadius: '24px', padding: '24px', backdropFilter: 'blur(20px)', WebkitBackdropFilter: 'blur(20px)', border: '1px solid rgba(255, 255, 255, 0.1)', boxShadow: '0 8px 32px rgba(0, 0, 0, 0.2)', width: '100%' },
      cardTitle: { fontSize: '1.2rem', fontWeight: '700', marginBottom: '20px', textAlign: 'center', background: 'linear-gradient(135deg, #fff 0%, #94a3b8 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' },

      // Mode Selection - Horizontal Scroll
      modeScroll: { display: 'flex', gap: '12px', overflowX: 'auto', paddingBottom: '12px', marginBottom: '20px', scrollSnapType: 'x mandatory', WebkitOverflowScrolling: 'touch' },
      modeCard: { minWidth: '140px', padding: '20px 16px', borderRadius: '20px', border: '2px solid rgba(255, 255, 255, 0.15)', background: 'rgba(255, 255, 255, 0.05)', backdropFilter: 'blur(10px)', color: 'white', cursor: 'pointer', textAlign: 'center', scrollSnapAlign: 'start', transition: 'all 0.3s ease' },
      modeCardActive: { borderColor: '#a855f7', background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(236, 72, 153, 0.2))', boxShadow: '0 0 30px rgba(168, 85, 247, 0.3)' },
      modeIcon: { fontSize: '2rem', marginBottom: '8px', display: 'block' },
      modeName: { fontSize: '0.9rem', fontWeight: '600', marginBottom: '4px' },
      modeDesc: { fontSize: '0.7rem', color: '#94a3b8', lineHeight: 1.3 },

      // Difficulty - Chip Style
      difficultyChips: { display: 'flex', gap: '10px', marginBottom: '24px', justifyContent: 'center', flexWrap: 'wrap' },
      difficultyChip: { padding: '12px 24px', borderRadius: '50px', border: '2px solid rgba(255, 255, 255, 0.2)', background: 'rgba(255, 255, 255, 0.05)', color: 'white', fontSize: '0.95rem', fontWeight: '600', cursor: 'pointer', transition: 'all 0.3s ease' },
      difficultyChipActive: { borderColor: '#a855f7', background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.4), rgba(236, 72, 153, 0.3))', boxShadow: '0 0 20px rgba(168, 85, 247, 0.3)' },

      // Start Button
      startBtn: { width: '100%', padding: '20px', borderRadius: '16px', border: 'none', background: 'linear-gradient(135deg, #a855f7, #ec4899, #f97316)', backgroundSize: '200% 200%', color: 'white', fontSize: '1.2rem', fontWeight: '700', cursor: 'pointer', minHeight: '60px', boxShadow: '0 8px 30px rgba(168, 85, 247, 0.4)', transition: 'all 0.3s ease', letterSpacing: '0.5px' },

      // Score Board - Enhanced
      scoreBoard: { display: 'flex', justifyContent: 'space-around', background: 'rgba(255, 255, 255, 0.08)', borderRadius: '20px', padding: '20px 16px', backdropFilter: 'blur(10px)', border: '1px solid rgba(255, 255, 255, 0.1)' },
      scoreStat: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px' },
      scoreLabel: { fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '1px', fontWeight: '500' },
      scoreValue: { fontSize: '1.4rem', fontWeight: '700' },

      // Floating Play Button
      floatingPlayBtn: { position: 'fixed', bottom: '120px', right: '24px', width: '72px', height: '72px', borderRadius: '50%', border: 'none', background: 'linear-gradient(135deg, #3b82f6, #8b5cf6, #a855f7)', color: 'white', fontSize: '1.8rem', cursor: 'pointer', boxShadow: '0 8px 30px rgba(139, 92, 246, 0.5)', zIndex: 100, display: 'flex', alignItems: 'center', justifyContent: 'center' },
      playHint: { marginTop: '12px', color: '#64748b', fontSize: '0.85rem', textAlign: 'center', fontWeight: '500' },

      // Choice Buttons - Enhanced
      choicesGrid: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '14px', marginTop: '20px' },
      choiceBtn: { padding: '22px 16px', borderRadius: '18px', border: '2px solid rgba(255, 255, 255, 0.15)', background: 'rgba(255, 255, 255, 0.08)', backdropFilter: 'blur(10px)', color: 'white', fontSize: '1rem', fontWeight: '600', cursor: 'pointer', minHeight: '70px', transition: 'all 0.2s ease', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center' },
      choiceBtnCorrect: { borderColor: '#22c55e', background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.4), rgba(22, 163, 74, 0.3))', boxShadow: '0 0 30px rgba(34, 197, 94, 0.4)' },
      choiceBtnWrong: { borderColor: '#ef4444', background: 'linear-gradient(135deg, rgba(239, 68, 68, 0.4), rgba(220, 38, 38, 0.3))', boxShadow: '0 0 30px rgba(239, 68, 68, 0.4)' },

      // Action Buttons
      actionButtons: { display: 'flex', gap: '14px', marginTop: '24px' },
      nextBtn: { flex: 1, padding: '18px', borderRadius: '14px', border: 'none', background: 'linear-gradient(135deg, #22c55e, #16a34a)', color: 'white', fontSize: '1.1rem', fontWeight: '700', cursor: 'pointer', minHeight: '56px', boxShadow: '0 8px 25px rgba(34, 197, 94, 0.4)' },
      resetBtn: { flex: 1, padding: '18px', borderRadius: '14px', border: '2px solid rgba(255, 255, 255, 0.2)', background: 'rgba(255, 255, 255, 0.05)', color: 'white', fontSize: '1rem', fontWeight: '600', cursor: 'pointer', minHeight: '56px' },

      // Result Box
      resultBox: { textAlign: 'center', padding: '20px', borderRadius: '16px', border: '2px solid', fontSize: '1.1rem', fontWeight: '700', backdropFilter: 'blur(10px)' },

      // Bottom Navigation - Enhanced
      bottomNav: { position: 'fixed', bottom: 0, left: 0, right: 0, background: 'rgba(15, 12, 41, 0.95)', backdropFilter: 'blur(20px)', WebkitBackdropFilter: 'blur(20px)', borderTop: '1px solid rgba(255,255,255,0.08)', display: 'flex', justifyContent: 'stretch', padding: '12px 8px 16px', zIndex: 999, width: '100%' },
      bottomNavItem: { display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', gap: '6px', background: 'none', border: 'none', color: '#64748b', fontSize: '0.7rem', fontWeight: '500', cursor: 'pointer', padding: '8px', borderRadius: '12px', flex: 1, minHeight: '60px', transition: 'all 0.3s ease', position: 'relative' },
      bottomNavItemActive: { color: '#a855f7' },
      bottomNavIcon: { fontSize: '1.5rem', transition: 'transform 0.3s ease' },

      // Stats Cards
      statsCard: { background: 'rgba(255, 255, 255, 0.06)', borderRadius: '20px', padding: '20px', marginBottom: '14px', backdropFilter: 'blur(10px)', border: '1px solid rgba(255, 255, 255, 0.08)' },
      statsTitle: { fontSize: '1.05rem', fontWeight: '700', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '10px' },
      statsGrid: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '16px' },
      statItem: { textAlign: 'center', padding: '12px', background: 'rgba(255, 255, 255, 0.04)', borderRadius: '12px' },
      statValue: { fontSize: '1.6rem', fontWeight: '700', background: 'linear-gradient(135deg, #a855f7, #ec4899)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' },
      statLabel: { fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '0.5px', marginTop: '4px', fontWeight: '500' },

      // Settings
      settingRow: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '18px 0', borderBottom: '1px solid rgba(255, 255, 255, 0.08)', minHeight: '60px' },
      settingLabel: { fontSize: '1rem', fontWeight: '500' },
      select: { padding: '14px 18px', borderRadius: '12px', border: '2px solid rgba(255, 255, 255, 0.15)', background: 'rgba(255, 255, 255, 0.08)', color: 'white', fontSize: '1rem', cursor: 'pointer', minHeight: '48px', appearance: 'none', backgroundImage: 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' fill=\'white\' viewBox=\'0 0 24 24\'%3E%3Cpath d=\'M7 10l5 5 5-5z\'/%3E%3C/svg%3E")', backgroundRepeat: 'no-repeat', backgroundPosition: 'right 12px center', backgroundSize: '20px', paddingRight: '40px' },
      toggle: { width: '56px', height: '32px', borderRadius: '16px', border: 'none', cursor: 'pointer', position: 'relative', transition: 'all 0.3s ease', minWidth: '56px' },
      toggleKnob: { width: '28px', height: '28px', borderRadius: '50%', backgroundColor: 'white', position: 'absolute', top: '2px', transition: 'left 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)', boxShadow: '0 2px 8px rgba(0,0,0,0.2)' },

      // Buttons
      dangerBtn: { padding: '18px', borderRadius: '14px', border: '2px solid #ef4444', background: 'rgba(239, 68, 68, 0.1)', color: '#ef4444', fontSize: '1rem', fontWeight: '600', cursor: 'pointer', marginTop: '20px', width: '100%', minHeight: '56px' },
      shareBtn: { padding: '18px', borderRadius: '14px', border: 'none', background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)', color: 'white', fontSize: '1rem', cursor: 'pointer', marginTop: '16px', width: '100%', fontWeight: '700', minHeight: '56px', boxShadow: '0 8px 25px rgba(59, 130, 246, 0.4)' },

      // Accordion
      accordion: { background: 'rgba(255, 255, 255, 0.05)', borderRadius: '16px', marginBottom: '12px', overflow: 'hidden', border: '1px solid rgba(255, 255, 255, 0.08)' },
      accordionHeader: { padding: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: 'pointer', background: 'none', border: 'none', width: '100%', color: 'white', textAlign: 'left', minHeight: '60px' },
      accordionTitle: { fontSize: '1rem', fontWeight: '600' },
      accordionArrow: { fontSize: '0.9rem', transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)' },
      accordionBody: { padding: '0 20px 20px' },
      refNotes: { fontSize: '0.95rem', color: '#a855f7', fontFamily: 'monospace', marginBottom: '10px', fontWeight: '500' },
      refDesc: { fontSize: '0.85rem', color: '#94a3b8', marginBottom: '12px', lineHeight: 1.5 },
      playSmallBtn: { padding: '14px 24px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)', color: 'white', fontSize: '0.95rem', fontWeight: '600', cursor: 'pointer', minHeight: '48px' },

      // Swipe Indicator
      swipeIndicator: { display: 'flex', justifyContent: 'center', gap: '10px', marginBottom: '20px' },
      swipeDot: { width: '8px', height: '8px', borderRadius: '50%', backgroundColor: 'rgba(255,255,255,0.2)', cursor: 'pointer', transition: 'all 0.3s ease' },
      swipeDotActive: { backgroundColor: '#a855f7', width: '24px', borderRadius: '4px' },

      // Skeleton
      skeleton: { height: '60px', marginBottom: '12px' },
    };

    // ============================================
    // COMPONENTS
    // ============================================

    // Skeleton Loader
    function Skeleton({ height = 60, style = {} }) {
      return <div className="skeleton" style={{ height, ...style }} />;
    }

    // Piano Visualization Component
    function PianoVisualization({ highlightedNotes = [], startOctave = 3, octaves = 2 }) {
      const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const blackKeys = { 'C': 'C#', 'D': 'D#', 'F': 'F#', 'G': 'G#', 'A': 'A#' };

      const isHighlighted = (note, octave) => {
        return highlightedNotes.some(n => n === `${note}${octave}` || n === note);
      };

      const keyStyle = {
        white: { width: '28px', height: '100px', backgroundColor: 'white', border: '1px solid #333', borderRadius: '0 0 4px 4px', display: 'flex', alignItems: 'flex-end', justifyContent: 'center', paddingBottom: '4px', fontSize: '0.6rem', color: '#333' },
        whiteHighlight: { backgroundColor: '#a855f7', color: 'white' },
        black: { width: '20px', height: '60px', backgroundColor: '#1a1a2e', border: '1px solid #000', borderRadius: '0 0 3px 3px', position: 'absolute', zIndex: 1 },
        blackHighlight: { backgroundColor: '#ec4899' },
      };

      return (
        <div style={{ display: 'flex', position: 'relative', justifyContent: 'center', padding: '10px 0', overflowX: 'auto' }}>
          {Array.from({ length: octaves }, (_, octIdx) => {
            const octave = startOctave + octIdx;
            return whiteKeys.map((key, idx) => (
              <div key={`${key}${octave}`} style={{ position: 'relative' }}>
                <div style={{ ...keyStyle.white, ...(isHighlighted(key, octave) ? keyStyle.whiteHighlight : {}) }}>
                  {key}{octave}
                </div>
                {blackKeys[key] && (
                  <div style={{ ...keyStyle.black, ...(isHighlighted(blackKeys[key], octave) ? keyStyle.blackHighlight : {}), left: '18px', top: '10px' }} />
                )}
              </div>
            ));
          })}
        </div>
      );
    }

    // Guitar Chord Chart Component
    function GuitarChordChart({ chord, size = 'medium' }) {
      const chordData = GUITAR_CHORDS[chord];
      if (!chordData) return null;

      const scale = size === 'small' ? 0.7 : size === 'large' ? 1.3 : 1;
      const fretWidth = 30 * scale;
      const fretHeight = 20 * scale;
      const stringSpacing = 16 * scale;
      const dotSize = 12 * scale;

      const strings = ['E', 'A', 'D', 'G', 'B', 'e'];
      const minFret = Math.max(1, Math.min(...chordData.frets.filter(f => f > 0)));
      const maxFret = Math.max(...chordData.frets);
      const startFret = maxFret <= 4 ? 1 : minFret;
      const showFrets = 4;

      return (
        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '10px' }}>
          <div style={{ fontWeight: '600', marginBottom: '8px', fontSize: `${14 * scale}px` }}>{chordData.name}</div>
          <svg width={fretWidth * 6 + 30} height={fretHeight * (showFrets + 1) + 30} style={{ overflow: 'visible' }}>
            {/* Nut or fret number */}
            {startFret === 1 ? (
              <rect x={15} y={20} width={stringSpacing * 5 + 10} height={4} fill="white" />
            ) : (
              <text x={5} y={35} fill="white" fontSize={12 * scale}>{startFret}</text>
            )}

            {/* Frets */}
            {Array.from({ length: showFrets + 1 }, (_, i) => (
              <line key={i} x1={15} y1={22 + i * fretHeight} x2={15 + stringSpacing * 5} y2={22 + i * fretHeight} stroke="rgba(255,255,255,0.3)" strokeWidth={1} />
            ))}

            {/* Strings */}
            {strings.map((_, i) => (
              <line key={i} x1={15 + i * stringSpacing} y1={22} x2={15 + i * stringSpacing} y2={22 + showFrets * fretHeight} stroke="rgba(255,255,255,0.5)" strokeWidth={1} />
            ))}

            {/* Finger positions */}
            {chordData.frets.map((fret, stringIdx) => {
              if (fret === -1) {
                return <text key={stringIdx} x={12 + stringIdx * stringSpacing} y={15} fill="#ef4444" fontSize={12 * scale}>Ã—</text>;
              }
              if (fret === 0) {
                return <circle key={stringIdx} cx={15 + stringIdx * stringSpacing} cy={10} r={dotSize / 3} fill="none" stroke="white" strokeWidth={2} />;
              }
              const displayFret = fret - startFret + 1;
              if (displayFret > 0 && displayFret <= showFrets) {
                return (
                  <g key={stringIdx}>
                    <circle cx={15 + stringIdx * stringSpacing} cy={22 + (displayFret - 0.5) * fretHeight} r={dotSize / 2} fill="#a855f7" />
                    <text x={15 + stringIdx * stringSpacing} y={22 + (displayFret - 0.5) * fretHeight + 4} fill="white" fontSize={10 * scale} textAnchor="middle">
                      {chordData.fingers[stringIdx] || ''}
                    </text>
                  </g>
                );
              }
              return null;
            })}

            {/* Barre indicator */}
            {chordData.barre && (
              <rect x={12} y={22 + (chordData.frets[0] - startFret + 0.3) * fretHeight} width={stringSpacing * 5 + 6} height={8} rx={4} fill="rgba(168, 85, 247, 0.7)" />
            )}
          </svg>
        </div>
      );
    }

    // Volume Slider Component
    function VolumeSlider({ value, onChange }) {
      return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', flex: 1 }}>
          <span style={{ fontSize: '1.2rem' }}>ðŸ”ˆ</span>
          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
            style={{
              flex: 1,
              height: '6px',
              borderRadius: '3px',
              background: `linear-gradient(to right, #a855f7 ${value * 100}%, rgba(255,255,255,0.2) ${value * 100}%)`,
              appearance: 'none',
              outline: 'none',
              cursor: 'pointer',
            }}
          />
          <span style={{ fontSize: '1.2rem' }}>ðŸ”Š</span>
        </div>
      );
    }

    // Confetti Component for celebrations
    function Confetti({ trigger }) {
      const [particles, setParticles] = useState([]);

      useEffect(() => {
        if (trigger) {
          const colors = ['#a855f7', '#ec4899', '#f97316', '#22c55e', '#3b82f6', '#facc15'];
          const newParticles = Array.from({ length: 30 }, (_, i) => ({
            id: i,
            left: Math.random() * 100,
            color: colors[Math.floor(Math.random() * colors.length)],
            delay: Math.random() * 0.5,
            size: Math.random() * 8 + 6,
          }));
          setParticles(newParticles);
          setTimeout(() => setParticles([]), 3000);
        }
      }, [trigger]);

      return (
        <>
          {particles.map(p => (
            <div key={p.id} className="confetti" style={{
              left: `${p.left}%`,
              backgroundColor: p.color,
              animationDelay: `${p.delay}s`,
              width: `${p.size}px`,
              height: `${p.size}px`,
              borderRadius: Math.random() > 0.5 ? '50%' : '2px',
            }} />
          ))}
        </>
      );
    }

    // Progress Ring Component for stats
    function ProgressRing({ progress, size = 80, strokeWidth = 6, color = '#a855f7', label = '', value = '' }) {
      const radius = (size - strokeWidth) / 2;
      const circumference = radius * 2 * Math.PI;
      const offset = circumference - (progress / 100) * circumference;

      return (
        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px' }}>
          <svg width={size} height={size} style={{ transform: 'rotate(-90deg)' }}>
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              fill="none"
              stroke="rgba(255,255,255,0.1)"
              strokeWidth={strokeWidth}
            />
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              fill="none"
              stroke={color}
              strokeWidth={strokeWidth}
              strokeDasharray={circumference}
              strokeDashoffset={offset}
              strokeLinecap="round"
              className="progress-ring-circle"
              style={{ filter: `drop-shadow(0 0 6px ${color})` }}
            />
          </svg>
          <div style={{ position: 'absolute', marginTop: size / 2 - 10, fontSize: '1rem', fontWeight: '700' }}>{value}</div>
          {label && <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '0.5px' }}>{label}</div>}
        </div>
      );
    }

    // Mini Piano Visualization Component
    function MiniPiano({ notes = [], highlightColor = '#a855f7', showLabels = false }) {
      // Parse notes into a set for quick lookup (e.g., "C4", "E4", "G4")
      const activeNotes = useMemo(() => {
        const active = new Set();
        notes.forEach(note => {
          if (typeof note === 'string') {
            // Extract just the note name without octave (e.g., "C4" -> "C")
            const noteName = note.replace(/\d+/g, '');
            active.add(noteName);
          }
        });
        return active;
      }, [notes]);

      // Piano key configuration
      const whiteKeys = [
        { note: 'C', offset: 0 },
        { note: 'D', offset: 1 },
        { note: 'E', offset: 2 },
        { note: 'F', offset: 3 },
        { note: 'G', offset: 4 },
        { note: 'A', offset: 5 },
        { note: 'B', offset: 6 },
      ];
      const blackKeys = [
        { note: 'C#', offset: 0.65 },
        { note: 'D#', offset: 1.65 },
        { note: 'F#', offset: 3.65 },
        { note: 'G#', offset: 4.65 },
        { note: 'A#', offset: 5.65 },
      ];

      const keyWidth = 28;
      const keyHeight = 70;
      const blackKeyWidth = 18;
      const blackKeyHeight = 42;

      return (
        <div style={{
          display: 'inline-flex',
          position: 'relative',
          height: keyHeight + (showLabels ? 20 : 0),
          background: 'rgba(0,0,0,0.3)',
          borderRadius: '8px',
          padding: '6px',
          boxShadow: '0 4px 20px rgba(0,0,0,0.3)'
        }}>
          {/* White keys */}
          {whiteKeys.map((key, i) => {
            const isActive = activeNotes.has(key.note);
            return (
              <div key={key.note} style={{
                width: keyWidth,
                height: keyHeight,
                background: isActive
                  ? `linear-gradient(180deg, ${highlightColor}, ${highlightColor}dd)`
                  : 'linear-gradient(180deg, #ffffff, #e0e0e0)',
                borderRadius: '0 0 4px 4px',
                marginRight: i < whiteKeys.length - 1 ? '2px' : 0,
                boxShadow: isActive
                  ? `0 0 15px ${highlightColor}, inset 0 -2px 8px rgba(0,0,0,0.1)`
                  : 'inset 0 -2px 8px rgba(0,0,0,0.1)',
                display: 'flex',
                alignItems: 'flex-end',
                justifyContent: 'center',
                paddingBottom: '4px',
                transition: 'all 0.15s ease'
              }}>
                {showLabels && (
                  <span style={{
                    fontSize: '0.6rem',
                    fontWeight: '600',
                    color: isActive ? 'white' : '#666'
                  }}>{key.note}</span>
                )}
              </div>
            );
          })}
          {/* Black keys */}
          {blackKeys.map(key => {
            const isActive = activeNotes.has(key.note);
            return (
              <div key={key.note} style={{
                position: 'absolute',
                left: 6 + key.offset * (keyWidth + 2),
                top: 6,
                width: blackKeyWidth,
                height: blackKeyHeight,
                background: isActive
                  ? `linear-gradient(180deg, ${highlightColor}, ${highlightColor}cc)`
                  : 'linear-gradient(180deg, #333, #111)',
                borderRadius: '0 0 3px 3px',
                boxShadow: isActive
                  ? `0 0 15px ${highlightColor}`
                  : '0 2px 4px rgba(0,0,0,0.3)',
                zIndex: 1,
                transition: 'all 0.15s ease'
              }} />
            );
          })}
        </div>
      );
    }

    // Waveform Visualization Component
    function Waveform({ isPlaying, barCount = 5 }) {
      return (
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '3px', height: '32px' }}>
          {Array.from({ length: barCount }, (_, i) => (
            <div
              key={i}
              className={isPlaying ? 'waveform-bar' : ''}
              style={{
                width: '4px',
                height: isPlaying ? '100%' : '20%',
                backgroundColor: '#a855f7',
                borderRadius: '2px',
                animationDelay: `${i * 0.1}s`,
                transition: 'height 0.3s ease',
              }}
            />
          ))}
        </div>
      );
    }

    // Streak Fire Animation
    function StreakFire({ streak }) {
      if (streak < 3) return null;
      const flames = streak >= 10 ? 3 : streak >= 5 ? 2 : 1;
      return (
        <span className="fire-glow" style={{ display: 'inline-flex' }}>
          {Array.from({ length: flames }, (_, i) => (
            <span key={i} style={{ fontSize: '1.2rem' }}>ðŸ”¥</span>
          ))}
        </span>
      );
    }

    // Achievement Unlock Notification
    function AchievementNotification({ achievement, onClose }) {
      useEffect(() => {
        const timer = setTimeout(onClose, 4000);
        return () => clearTimeout(timer);
      }, [onClose]);

      return (
        <div style={{
          position: 'fixed',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.95), rgba(236, 72, 153, 0.95))',
          padding: '32px 48px',
          borderRadius: '24px',
          textAlign: 'center',
          zIndex: 1100,
          backdropFilter: 'blur(20px)',
          border: '1px solid rgba(255,255,255,0.2)',
          boxShadow: '0 20px 60px rgba(168, 85, 247, 0.5)',
        }} className="achievement-unlock">
          <div style={{ fontSize: '4rem', marginBottom: '12px' }}>{achievement.icon}</div>
          <div style={{ fontSize: '0.8rem', color: 'rgba(255,255,255,0.7)', marginBottom: '4px', textTransform: 'uppercase', letterSpacing: '2px' }}>Achievement Unlocked!</div>
          <div style={{ fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px' }}>{achievement.name}</div>
          <div style={{ fontSize: '0.9rem', color: 'rgba(255,255,255,0.8)' }}>{achievement.description}</div>
        </div>
      );
    }

    // Countdown Timer Component
    function CountdownTimer({ duration, onTimeUp, isActive, onTick }) {
      const [timeLeft, setTimeLeft] = useState(duration);
      const [tickKey, setTickKey] = useState(0);

      useEffect(() => {
        setTimeLeft(duration);
      }, [duration]);

      useEffect(() => {
        if (!isActive) return;
        if (timeLeft <= 0) {
          onTimeUp();
          return;
        }
        const timer = setInterval(() => {
          setTimeLeft(prev => {
            const newTime = prev - 1;
            setTickKey(k => k + 1);
            if (onTick) onTick(newTime);
            return newTime;
          });
        }, 1000);
        return () => clearInterval(timer);
      }, [isActive, timeLeft, onTimeUp, onTick]);

      const isWarning = timeLeft <= 3;
      const progress = (timeLeft / duration) * 100;

      return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: '12px 16px', background: 'rgba(255,255,255,0.08)', borderRadius: '16px', backdropFilter: 'blur(10px)' }}>
          <div style={{ position: 'relative', width: '50px', height: '50px' }}>
            <svg width="50" height="50" style={{ transform: 'rotate(-90deg)' }}>
              <circle cx="25" cy="25" r="22" fill="none" stroke="rgba(255,255,255,0.1)" strokeWidth="4" />
              <circle cx="25" cy="25" r="22" fill="none" stroke={isWarning ? '#ef4444' : '#a855f7'} strokeWidth="4"
                strokeDasharray={138} strokeDashoffset={138 - (progress / 100) * 138} strokeLinecap="round"
                style={{ transition: 'stroke-dashoffset 0.3s ease', filter: `drop-shadow(0 0 4px ${isWarning ? '#ef4444' : '#a855f7'})` }} />
            </svg>
            <div key={tickKey} className={`${isWarning ? 'timer-warning' : ''} timer-tick`} style={{
              position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
              fontSize: '1.1rem', fontWeight: '700', color: isWarning ? '#ef4444' : 'white'
            }}>{timeLeft}</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={{ fontSize: '0.75rem', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '1px' }}>Time Left</div>
            <div style={{ fontSize: '0.9rem', fontWeight: '600', color: isWarning ? '#ef4444' : 'white' }}>
              {isWarning ? 'Hurry!' : 'Answer quickly for bonus points!'}
            </div>
          </div>
        </div>
      );
    }

    // Bonus Points Floating Animation
    function BonusPoints({ points, trigger }) {
      const [show, setShow] = useState(false);

      useEffect(() => {
        if (trigger > 0) {
          setShow(true);
          const timer = setTimeout(() => setShow(false), 1000);
          return () => clearTimeout(timer);
        }
      }, [trigger]);

      if (!show || points <= 0) return null;

      return (
        <div className="bonus-float" style={{
          position: 'fixed', top: '30%', left: '50%', transform: 'translateX(-50%)',
          fontSize: '1.5rem', fontWeight: '700', color: '#fbbf24', textShadow: '0 0 10px rgba(251, 191, 36, 0.5)',
          zIndex: 1000, pointerEvents: 'none'
        }}>
          +{points} Bonus!
        </div>
      );
    }

    // Daily Challenge Hook
    function useDailyChallenge() {
      const [dailyStats, setDailyStats] = useLocalStorage('keyperfect_daily', {
        lastPlayedDate: null,
        completed: false,
        score: 0,
        streak: 0,
      });

      const todayStr = new Date().toISOString().split('T')[0];
      const hasPlayedToday = dailyStats.lastPlayedDate === todayStr;
      const seed = getDailySeed();

      const startDaily = useCallback(() => {
        if (!hasPlayedToday) {
          setDailyStats(prev => ({ ...prev, lastPlayedDate: todayStr, completed: false, score: 0, streak: 0 }));
        }
      }, [hasPlayedToday, todayStr, setDailyStats]);

      const completeDaily = useCallback((score, streak) => {
        setDailyStats(prev => ({ ...prev, completed: true, score, streak }));
      }, [setDailyStats]);

      return { dailyStats, hasPlayedToday, seed, startDaily, completeDaily, todayStr };
    }

    // Speed Run Hook
    function useSpeedRun() {
      const [speedRunStats, setSpeedRunStats] = useLocalStorage('keyperfect_speedrun', {
        highScore: 0,
        lastScore: 0,
        totalRuns: 0,
        bestAccuracy: 0,
      });

      const saveRun = useCallback((score, correct, total) => {
        const accuracy = total > 0 ? Math.round((correct / total) * 100) : 0;
        setSpeedRunStats(prev => ({
          highScore: Math.max(prev.highScore, score),
          lastScore: score,
          totalRuns: prev.totalRuns + 1,
          bestAccuracy: Math.max(prev.bestAccuracy, accuracy),
        }));
        return score > speedRunStats.highScore;
      }, [speedRunStats.highScore, setSpeedRunStats]);

      return { speedRunStats, saveRun };
    }

    // Survival Mode Hook
    function useSurvival() {
      const [survivalStats, setSurvivalStats] = useLocalStorage('keyperfect_survival', {
        bestScore: 0,
        totalGames: 0,
        bestStreak: 0,
      });

      const saveSurvival = useCallback((score, streak) => {
        const isNewBest = score > survivalStats.bestScore;
        setSurvivalStats(prev => ({
          bestScore: Math.max(prev.bestScore, score),
          totalGames: prev.totalGames + 1,
          bestStreak: Math.max(prev.bestStreak, streak),
        }));
        return isNewBest;
      }, [survivalStats.bestScore, setSurvivalStats]);

      return { survivalStats, saveSurvival };
    }

    // Daily Quests Hook
    function useDailyQuests() {
      const [questData, setQuestData] = useLocalStorage('keyperfect_quests', {
        lastGeneratedDate: null,
        quests: [],
        completedToday: 0,
        totalCompleted: 0,
      });

      const todayStr = new Date().toISOString().split('T')[0];

      // Generate new quests if it's a new day
      const generateQuests = useCallback(() => {
        if (questData.lastGeneratedDate === todayStr) return questData.quests;

        // Pick 3 random quests using seeded random for consistency
        const seed = getDailySeed();
        const shuffled = seededShuffle(QUEST_TEMPLATES, seed);
        const newQuests = shuffled.slice(0, 3).map(q => ({
          ...q,
          progress: 0,
          completed: false,
        }));

        setQuestData(prev => ({
          ...prev,
          lastGeneratedDate: todayStr,
          quests: newQuests,
          completedToday: 0,
        }));

        return newQuests;
      }, [todayStr, questData.lastGeneratedDate, setQuestData]);

      // Update quest progress
      const updateQuestProgress = useCallback((type, value = 1) => {
        setQuestData(prev => {
          const updatedQuests = prev.quests.map(quest => {
            if (quest.completed) return quest;

            let shouldUpdate = false;
            if (quest.type === type) shouldUpdate = true;
            if (type === 'correct' && quest.type === 'correct') shouldUpdate = true;
            if (type.startsWith('mode_') && quest.type === type) shouldUpdate = true;
            if (quest.type === 'streak' && type === 'streak') shouldUpdate = true;

            if (shouldUpdate) {
              const newProgress = quest.type === 'streak' ? Math.max(quest.progress, value) : quest.progress + value;
              const completed = newProgress >= quest.target;
              return { ...quest, progress: newProgress, completed };
            }
            return quest;
          });

          const newCompletedCount = updatedQuests.filter(q => q.completed).length;
          const prevCompletedCount = prev.quests.filter(q => q.completed).length;

          return {
            ...prev,
            quests: updatedQuests,
            completedToday: newCompletedCount,
            totalCompleted: prev.totalCompleted + (newCompletedCount - prevCompletedCount),
          };
        });
      }, [setQuestData]);

      // Get current quests (generate if needed)
      const quests = questData.lastGeneratedDate === todayStr ? questData.quests : generateQuests();

      return { quests, questData, updateQuestProgress, generateQuests };
    }

    // Practice Heatmap Hook
    function usePracticeHeatmap() {
      const [heatmapData, setHeatmapData] = useLocalStorage('keyperfect_heatmap', {
        days: {}, // { '2024-01-15': { count: 10, correct: 8 }, ... }
        currentStreak: 0,
        longestStreak: 0,
      });

      const todayStr = new Date().toISOString().split('T')[0];

      const recordPractice = useCallback((correct = false) => {
        setHeatmapData(prev => {
          const today = prev.days[todayStr] || { count: 0, correct: 0 };
          const newDays = {
            ...prev.days,
            [todayStr]: {
              count: today.count + 1,
              correct: today.correct + (correct ? 1 : 0),
            },
          };

          // Calculate streak
          let streak = 1;
          const date = new Date();
          date.setDate(date.getDate() - 1);
          while (newDays[date.toISOString().split('T')[0]]) {
            streak++;
            date.setDate(date.getDate() - 1);
          }

          return {
            days: newDays,
            currentStreak: streak,
            longestStreak: Math.max(prev.longestStreak, streak),
          };
        });
      }, [todayStr, setHeatmapData]);

      const getLast12Weeks = useCallback(() => {
        const weeks = [];
        const today = new Date();
        for (let w = 11; w >= 0; w--) {
          const week = [];
          for (let d = 0; d < 7; d++) {
            const date = new Date(today);
            date.setDate(date.getDate() - (w * 7 + (6 - d)));
            const dateStr = date.toISOString().split('T')[0];
            week.push({
              date: dateStr,
              count: heatmapData.days[dateStr]?.count || 0,
              correct: heatmapData.days[dateStr]?.correct || 0,
            });
          }
          weeks.push(week);
        }
        return weeks;
      }, [heatmapData.days]);

      return { heatmapData, recordPractice, getLast12Weeks, todayStr };
    }

    // XP and Leveling System Hook
    function useXP() {
      const [xpData, setXPData] = useLocalStorage('keyperfect_xp', {
        totalXP: 0,
        level: 1,
        xpHistory: [],
      });

      const getCurrentLevel = useCallback(() => {
        for (let i = XP_LEVELS.length - 1; i >= 0; i--) {
          if (xpData.totalXP >= XP_LEVELS[i].xpRequired) {
            return XP_LEVELS[i];
          }
        }
        return XP_LEVELS[0];
      }, [xpData.totalXP]);

      const getNextLevel = useCallback(() => {
        const current = getCurrentLevel();
        const nextIdx = XP_LEVELS.findIndex(l => l.level === current.level) + 1;
        return nextIdx < XP_LEVELS.length ? XP_LEVELS[nextIdx] : null;
      }, [getCurrentLevel]);

      const getProgress = useCallback(() => {
        const current = getCurrentLevel();
        const next = getNextLevel();
        if (!next) return 100;
        const progressXP = xpData.totalXP - current.xpRequired;
        const neededXP = next.xpRequired - current.xpRequired;
        return Math.round((progressXP / neededXP) * 100);
      }, [xpData.totalXP, getCurrentLevel, getNextLevel]);

      const addXP = useCallback((amount, source = 'unknown') => {
        const oldLevel = getCurrentLevel().level;
        setXPData(prev => {
          const newTotal = prev.totalXP + amount;
          const newHistory = [...prev.xpHistory.slice(-49), { amount, source, timestamp: Date.now() }];
          return { ...prev, totalXP: newTotal, xpHistory: newHistory };
        });
        const newLevel = XP_LEVELS.find(l => l.xpRequired <= xpData.totalXP + amount);
        return newLevel && newLevel.level > oldLevel ? newLevel : null;
      }, [xpData.totalXP, getCurrentLevel, setXPData]);

      return { xpData, addXP, getCurrentLevel, getNextLevel, getProgress };
    }

    // Weekly Challenge Hook
    function useWeeklyChallenge() {
      const getWeekNumber = () => {
        const now = new Date();
        const start = new Date(now.getFullYear(), 0, 1);
        const diff = now - start;
        const oneWeek = 1000 * 60 * 60 * 24 * 7;
        return Math.floor(diff / oneWeek);
      };

      const [challengeData, setChallengeData] = useLocalStorage('keyperfect_weekly', {
        weekNumber: getWeekNumber(),
        challenges: [],
        progress: {},
        completed: [],
      });

      const generateChallenges = useCallback(() => {
        const currentWeek = getWeekNumber();
        if (challengeData.weekNumber !== currentWeek || challengeData.challenges.length === 0) {
          const shuffled = [...WEEKLY_CHALLENGES].sort(() => Math.random() - 0.5);
          const selected = shuffled.slice(0, 3);
          setChallengeData({
            weekNumber: currentWeek,
            challenges: selected,
            progress: {},
            completed: [],
          });
          return selected;
        }
        return challengeData.challenges;
      }, [challengeData, setChallengeData]);

      const updateProgress = useCallback((type, value, mode = null) => {
        setChallengeData(prev => {
          const newProgress = { ...prev.progress };
          prev.challenges.forEach(c => {
            if (c.requirement === type && (!c.mode || c.mode === mode)) {
              newProgress[c.id] = (newProgress[c.id] || 0) + value;
            }
          });
          const newCompleted = prev.challenges
            .filter(c => (newProgress[c.id] || 0) >= c.target && !prev.completed.includes(c.id))
            .map(c => c.id);
          return {
            ...prev,
            progress: newProgress,
            completed: [...prev.completed, ...newCompleted],
          };
        });
      }, [setChallengeData]);

      return { challengeData, generateChallenges, updateProgress, weekNumber: getWeekNumber() };
    }

    // Theme Hook
    function useTheme() {
      const [theme, setTheme] = useLocalStorage('keyperfect_theme', 'dark');

      const currentTheme = THEMES[theme] || THEMES.dark;

      const applyTheme = useCallback((themeName) => {
        const t = THEMES[themeName];
        if (t) {
          setTheme(themeName);
          document.body.style.background = t.background;
          document.body.style.color = t.text;
        }
      }, [setTheme]);

      useEffect(() => {
        applyTheme(theme);
      }, []);

      return { theme, currentTheme, setTheme: applyTheme, availableThemes: Object.keys(THEMES) };
    }

    // Spaced Repetition Hook
    function useSpacedRepetition() {
      const [srData, setSRData] = useLocalStorage('keyperfect_sr', {
        items: {}, // { 'intervals:P5': { ease: 2.5, interval: 1, dueDate: timestamp, reps: 0 } }
      });

      const getItemKey = (mode, item) => `${mode}:${item}`;

      const recordAnswer = useCallback((mode, item, correct) => {
        const key = getItemKey(mode, item);
        setSRData(prev => {
          const existing = prev.items[key] || { ease: 2.5, interval: 1, reps: 0 };
          let newEase = existing.ease;
          let newInterval = existing.interval;
          let newReps = existing.reps;

          if (correct) {
            newReps++;
            if (newReps === 1) newInterval = 1;
            else if (newReps === 2) newInterval = 6;
            else newInterval = Math.round(existing.interval * newEase);
            newEase = Math.max(1.3, newEase + 0.1);
          } else {
            newReps = 0;
            newInterval = 1;
            newEase = Math.max(1.3, newEase - 0.2);
          }

          const dueDate = Date.now() + newInterval * 24 * 60 * 60 * 1000;

          return {
            items: {
              ...prev.items,
              [key]: { ease: newEase, interval: newInterval, dueDate, reps: newReps },
            },
          };
        });
      }, [setSRData]);

      const getDueItems = useCallback((mode = null) => {
        const now = Date.now();
        return Object.entries(srData.items)
          .filter(([key, data]) => {
            const itemMode = key.split(':')[0];
            return data.dueDate <= now && (!mode || itemMode === mode);
          })
          .sort((a, b) => a[1].dueDate - b[1].dueDate)
          .map(([key]) => {
            const [m, item] = key.split(':');
            return { mode: m, item };
          });
      }, [srData.items]);

      const getWeakItems = useCallback((limit = 10) => {
        return Object.entries(srData.items)
          .sort((a, b) => a[1].ease - b[1].ease)
          .slice(0, limit)
          .map(([key, data]) => {
            const [mode, item] = key.split(':');
            return { mode, item, ease: data.ease };
          });
      }, [srData.items]);

      return { srData, recordAnswer, getDueItems, getWeakItems };
    }

    // Custom Practice Sets Hook
    function useCustomPracticeSets() {
      const [practiceSets, setPracticeSets] = useLocalStorage('keyperfect_practice_sets', {
        sets: [],
      });

      const createSet = useCallback((name, items) => {
        setPracticeSets(prev => ({
          sets: [...prev.sets, { id: Date.now(), name, items, createdAt: Date.now() }],
        }));
      }, [setPracticeSets]);

      const deleteSet = useCallback((id) => {
        setPracticeSets(prev => ({
          sets: prev.sets.filter(s => s.id !== id),
        }));
      }, [setPracticeSets]);

      const updateSet = useCallback((id, updates) => {
        setPracticeSets(prev => ({
          sets: prev.sets.map(s => s.id === id ? { ...s, ...updates } : s),
        }));
      }, [setPracticeSets]);

      return { practiceSets: practiceSets.sets, createSet, deleteSet, updateSet };
    }

    // Sound Preview Component
    function SoundPreview({ instrument, useMidi, volume }) {
      const audio = useAudio(instrument, useMidi, volume);
      const [isPreviewPlaying, setIsPreviewPlaying] = useState(false);

      const playPreview = () => {
        if (audio.isLoading || isPreviewPlaying) return;
        setIsPreviewPlaying(true);
        // Play a simple C major chord
        audio.playNotes(['C4', 'E4', 'G4']);
        setTimeout(() => setIsPreviewPlaying(false), 2000);
      };

      return (
        <button onClick={playPreview} disabled={audio.isLoading || isPreviewPlaying}
          className="btn-press" style={{
            padding: '10px 16px', borderRadius: '10px', border: 'none',
            background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)',
            color: 'white', fontSize: '0.85rem', fontWeight: '600',
            cursor: audio.isLoading ? 'wait' : 'pointer',
            opacity: audio.isLoading || isPreviewPlaying ? 0.7 : 1,
            display: 'flex', alignItems: 'center', gap: '6px'
          }}>
          {audio.isLoading ? 'â³' : isPreviewPlaying ? 'ðŸ”Š' : 'â–¶'} Preview
        </button>
      );
    }

    // Bottom Navigation with Pill Indicator
    function BottomNav({ currentView, setView }) {
      const navRef = useRef(null);
      const [pillStyle, setPillStyle] = useState({ left: 0, width: 0 });

      useEffect(() => {
        const updatePill = () => {
          if (navRef.current) {
            const activeIdx = NAV_ITEMS.findIndex(item => item.id === currentView);
            const buttons = navRef.current.querySelectorAll('button');
            if (buttons[activeIdx]) {
              const btn = buttons[activeIdx];
              setPillStyle({
                left: btn.offsetLeft + 8,
                width: btn.offsetWidth - 16,
              });
            }
          }
        };
        updatePill();
        window.addEventListener('resize', updatePill);
        return () => window.removeEventListener('resize', updatePill);
      }, [currentView]);

      return (
        <nav ref={navRef} style={styles.bottomNav} className="bottom-nav">
          {/* Animated pill indicator */}
          <div className="nav-pill" style={{ ...pillStyle, position: 'absolute' }} />
          {NAV_ITEMS.map(item => (
            <button key={item.id} onClick={() => { setView(item.id); triggerHaptic('light'); }}
              className="btn-press"
              style={{ ...styles.bottomNavItem, ...(currentView === item.id ? styles.bottomNavItemActive : {}) }}>
              <span style={{ ...styles.bottomNavIcon, transform: currentView === item.id ? 'scale(1.15)' : 'scale(1)' }}>{item.icon}</span>
              <span>{item.label}</span>
            </button>
          ))}
        </nav>
      );
    }

    // Breadcrumbs
    function Breadcrumbs({ items }) {
      return (
        <div style={styles.breadcrumbs}>
          {items.map((item, i) => (
            <React.Fragment key={i}>
              {i > 0 && <span style={styles.breadcrumbSep}>/</span>}
              {item.onClick ? (
                <button style={styles.breadcrumbLink} onClick={item.onClick} className="btn-press">{item.label}</button>
              ) : (
                <span style={styles.breadcrumbCurrent}>{item.label}</span>
              )}
            </React.Fragment>
          ))}
        </div>
      );
    }

    // Floating Play Button
    function FloatingPlayButton({ onClick, isPlaying, isLoading }) {
      if (isLoading) return (
        <button style={{ ...styles.floatingPlayBtn, opacity: 0.5 }} disabled>
          <span>â³</span>
        </button>
      );
      return (
        <button onClick={() => { onClick(); triggerHaptic('medium'); }} disabled={isPlaying}
          className={`btn-press ${!isPlaying ? 'floating-btn' : ''}`}
          style={{ ...styles.floatingPlayBtn, opacity: isPlaying ? 0.7 : 1 }}>
          <span>{isPlaying ? 'ðŸ”Š' : 'â–¶ï¸'}</span>
        </button>
      );
    }

    // Accordion
    function Accordion({ title, children, defaultOpen = false, onPlay, isPlaying }) {
      const [isOpen, setIsOpen] = useState(defaultOpen);
      return (
        <div style={styles.accordion}>
          <button style={styles.accordionHeader} onClick={() => setIsOpen(!isOpen)} className="btn-press">
            <span style={styles.accordionTitle}>{title}</span>
            <span style={{ ...styles.accordionArrow, transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)' }}>â–¼</span>
          </button>
          <div className="accordion-content" style={{ maxHeight: isOpen ? '500px' : '0', opacity: isOpen ? 1 : 0 }}>
            <div style={styles.accordionBody}>
              {children}
              {onPlay && (
                <button onClick={(e) => { e.stopPropagation(); onPlay(); triggerHaptic('light'); }}
                  disabled={isPlaying} className="btn-press" style={styles.playSmallBtn}>
                  {isPlaying ? 'Playing...' : 'â–¶ Play'}
                </button>
              )}
            </div>
          </div>
        </div>
      );
    }

    // Swipe Container for Learn pages
    function SwipeContainer({ pages, currentPage, setCurrentPage }) {
      const containerRef = useRef(null);
      const startX = useRef(0);
      const currentX = useRef(0);

      const handleTouchStart = (e) => { startX.current = e.touches[0].clientX; };
      const handleTouchMove = (e) => { currentX.current = e.touches[0].clientX; };
      const handleTouchEnd = () => {
        const diff = startX.current - currentX.current;
        const pageKeys = Object.keys(pages);
        const currentIndex = pageKeys.indexOf(currentPage);
        if (diff > 50 && currentIndex < pageKeys.length - 1) {
          setCurrentPage(pageKeys[currentIndex + 1]);
          triggerHaptic('light');
        } else if (diff < -50 && currentIndex > 0) {
          setCurrentPage(pageKeys[currentIndex - 1]);
          triggerHaptic('light');
        }
      };

      return (
        <div>
          <div style={styles.swipeIndicator}>
            {Object.keys(pages).map(key => (
              <div key={key} style={{ ...styles.swipeDot, ...(currentPage === key ? styles.swipeDotActive : {}) }}
                onClick={() => setCurrentPage(key)} />
            ))}
          </div>
          <div ref={containerRef} className="swipe-container"
            onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
            {pages[currentPage]}
          </div>
        </div>
      );
    }

    // Score Board with enhanced visuals
    function ScoreBoard({ score, total, streak, bestStreak, isPlaying }) {
      return (
        <div style={styles.scoreBoard}>
          <div style={styles.scoreStat}>
            <span style={styles.scoreLabel}>Score</span>
            <span style={styles.scoreValue} className={score > 0 ? 'count-pop' : ''}>{score}/{total}</span>
          </div>
          <div style={styles.scoreStat}>
            <span style={styles.scoreLabel}>Streak</span>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <span style={{ ...styles.scoreValue, color: streak >= 5 ? '#f97316' : 'white' }}>{streak}</span>
              <StreakFire streak={streak} />
            </div>
          </div>
          <div style={styles.scoreStat}>
            <span style={styles.scoreLabel}>Best</span>
            <span style={{ ...styles.scoreValue, color: streak === bestStreak && bestStreak > 0 ? '#22c55e' : 'white' }}>{bestStreak}</span>
          </div>
          <div style={styles.scoreStat}>
            <Waveform isPlaying={isPlaying} barCount={4} />
          </div>
        </div>
      );
    }

    // Generic Game Component
    function GameComponent({ mode, difficulty, onBack, difficultySettings, buildQuestion, getChoiceLabel, getCorrectAnswer }) {
      const { settings } = useSettings();
      const { recordAnswer } = useStats();
      const { recordSessionAnswer } = useSessionStats();
      const { addToast } = useToast();
      const { playSound } = useSoundEffects();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const diffSettings = difficultySettings[difficulty];

      const [gameState, setGameState] = useState('playing');
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [choices, setChoices] = useState([]);
      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(0);
      const [totalPlayed, setTotalPlayed] = useState(0);
      const [lastResult, setLastResult] = useState(null);
      const [selectedAnswer, setSelectedAnswer] = useState(null);
      const [shakeWrong, setShakeWrong] = useState(false);
      const [confettiTrigger, setConfettiTrigger] = useState(0);
      const [timerKey, setTimerKey] = useState(0);
      const [timeRemaining, setTimeRemaining] = useState(settings.timerDuration);
      const [bonusPoints, setBonusPoints] = useState(0);
      const [bonusTrigger, setBonusTrigger] = useState(0);

      const generateRound = useCallback(() => {
        const question = buildQuestion(diffSettings, audio);
        setCurrentQuestion(question);
        setChoices(question.choices);
        setLastResult(null);
        setSelectedAnswer(null);
        setGameState('playing');
        setShakeWrong(false);
        setTimerKey(k => k + 1);
        setTimeRemaining(settings.timerDuration);
        if (settings.autoPlayOnStart && question.play) {
          setTimeout(() => question.play(), 300);
        }
      }, [diffSettings, settings.autoPlayOnStart, audio, buildQuestion]);

      useEffect(() => { if (!audio.isLoading) generateRound(); }, [audio.isLoading]);

      // Keyboard shortcuts for desktop users
      useEffect(() => {
        const handleKeyDown = (e) => {
          // Ignore if typing in an input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          // Space or R to replay
          if ((e.code === 'Space' || e.key === 'r' || e.key === 'R') && currentQuestion?.play) {
            e.preventDefault();
            currentQuestion.play();
            triggerHaptic('light');
            return;
          }

          // Number keys 1-9 to select answer (during playing state)
          if (gameState === 'playing' && choices.length > 0) {
            const num = parseInt(e.key);
            if (num >= 1 && num <= choices.length) {
              e.preventDefault();
              handleGuess(choices[num - 1]);
              return;
            }
          }

          // Enter or N for next round (during result state)
          if (gameState === 'result' && (e.key === 'Enter' || e.key === 'n' || e.key === 'N')) {
            e.preventDefault();
            generateRound();
            return;
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [gameState, choices, currentQuestion, generateRound]);

      // Calculate bonus points based on time remaining (timed mode only)
      const calculateBonus = () => {
        if (!settings.timedMode || !correct) return 0;
        const timePercent = timeRemaining / settings.timerDuration;
        if (timePercent > 0.7) return 3; // Fast answer
        if (timePercent > 0.4) return 2; // Good answer
        if (timePercent > 0.1) return 1; // OK answer
        return 0;
      };

      const handleGuess = (guess) => {
        if (gameState !== 'playing') return;
        const correctAnswer = getCorrectAnswer(currentQuestion);
        const correct = guess === correctAnswer;
        setSelectedAnswer(guess);

        // Get hint for intervals (song examples)
        let hint = '';
        if (mode === 'intervals' && INTERVALS[correctAnswer]?.songs) {
          hint = `Sounds like: ${INTERVALS[correctAnswer].songs.join(' or ')}`;
        }

        if (settings.practiceMode) {
          // Practice mode - no scoring, just learning
          if (correct) {
            playSound('success');
            triggerHaptic('success');
            setLastResult({ correct: true, message: 'âœ“ Correct!', hint });
          } else {
            playSound('error');
            triggerHaptic('error');
            setShakeWrong(true);
            setTimeout(() => setShakeWrong(false), 500);
            setLastResult({ correct: false, message: `It was ${getChoiceLabel(correctAnswer)}`, hint, showPiano: currentQuestion.notes });
          }
        } else {
          // Normal mode with scoring
          setTotalPlayed(prev => prev + 1);
          let newStreak = streak;
          let bonus = 0;

          if (correct) {
            playSound('success');
            triggerHaptic('success');

            // Calculate time bonus in timed mode
            if (settings.timedMode) {
              const timePercent = timeRemaining / settings.timerDuration;
              if (timePercent > 0.7) bonus = 3;
              else if (timePercent > 0.4) bonus = 2;
              else if (timePercent > 0.1) bonus = 1;
              if (bonus > 0) {
                setBonusPoints(bonus);
                setBonusTrigger(Date.now());
              }
            }

            setScore(prev => prev + 1 + bonus);
            newStreak = streak + 1;
            setStreak(newStreak);
            if (newStreak > bestStreak) setBestStreak(newStreak);
            setLastResult({ correct: true, message: bonus > 0 ? `âœ“ Correct! +${bonus} bonus!` : 'âœ“ Correct!', hint });
            // Streak milestones with confetti
            if (newStreak === 5) { addToast('ðŸ”¥ 5 streak! Keep going!', 'success'); setConfettiTrigger(Date.now()); }
            if (newStreak === 10) { addToast('ðŸ”¥ðŸ”¥ 10 streak! Amazing!', 'success'); setConfettiTrigger(Date.now()); }
            if (newStreak === 25) { addToast('ðŸ”¥ðŸ”¥ðŸ”¥ 25 streak! Legendary!', 'success'); setConfettiTrigger(Date.now()); }
          } else {
            playSound('error');
            triggerHaptic('error');
            setShakeWrong(true);
            setTimeout(() => setShakeWrong(false), 500);
            setStreak(0);
            newStreak = 0;
            setLastResult({ correct: false, message: `âœ— Wrong! It was ${getChoiceLabel(correctAnswer)}`, hint });
          }
          recordAnswer(mode, difficulty, correct, newStreak, correctAnswer);
          recordSessionAnswer(mode, correct);
        }
        setGameState('result');
      };

      // Handle timer running out
      const handleTimeUp = useCallback(() => {
        if (gameState !== 'playing') return;
        playSound('error');
        triggerHaptic('error');
        setShakeWrong(true);
        setTimeout(() => setShakeWrong(false), 500);
        const correctAnswer = getCorrectAnswer(currentQuestion);
        setLastResult({ correct: false, message: `â± Time's up! It was ${getChoiceLabel(correctAnswer)}` });
        setTotalPlayed(prev => prev + 1);
        setStreak(0);
        recordAnswer(mode, difficulty, false, 0, correctAnswer);
        recordSessionAnswer(mode, false);
        setGameState('result');
      }, [gameState, currentQuestion, getCorrectAnswer, getChoiceLabel, playSound, mode, difficulty, recordAnswer, recordSessionAnswer]);

      const handleReplay = () => {
        if (currentQuestion?.play) {
          triggerHaptic('light');
          currentQuestion.play();
        }
      };

      const modeInfo = GAME_MODES[mode];

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }}>
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: modeInfo.name }]} />
            <Skeleton height={60} />
            <Skeleton height={100} />
            <Skeleton height={200} />
          </div>
        );
      }

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Confetti trigger={confettiTrigger} />
          <BonusPoints points={bonusPoints} trigger={bonusTrigger} />
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: modeInfo.name }]} />
          <ScoreBoard score={score} total={totalPlayed} streak={streak} bestStreak={bestStreak} isPlaying={audio.isPlaying} />

          {/* Timed Mode Timer */}
          {settings.timedMode && !settings.practiceMode && gameState === 'playing' && (
            <CountdownTimer
              key={timerKey}
              duration={settings.timerDuration}
              onTimeUp={handleTimeUp}
              isActive={gameState === 'playing'}
              onTick={setTimeRemaining}
            />
          )}

          {!settings.timedMode && <p style={styles.playHint}>Tap the play button to hear again</p>}

          {lastResult && (
            <div className={lastResult.correct ? 'success-check' : ''} style={{ ...styles.resultBox, backgroundColor: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)', borderColor: lastResult.correct ? '#22c55e' : '#ef4444' }}>
              <div style={{ fontSize: '1.2rem' }}>{lastResult.message}</div>
              {lastResult.hint && <div style={{ fontSize: '0.85rem', marginTop: '8px', color: '#94a3b8' }}>{lastResult.hint}</div>}
              {lastResult.showPiano && <PianoVisualization highlightedNotes={lastResult.showPiano} startOctave={3} octaves={2} />}
            </div>
          )}
          {settings.practiceMode && (
            <div style={{ textAlign: 'center', padding: '10px', backgroundColor: 'rgba(168, 85, 247, 0.15)', borderRadius: '12px', fontSize: '0.85rem', color: '#a855f7', border: '1px solid rgba(168, 85, 247, 0.3)' }}>
              ðŸŽ“ Practice Mode - No scoring
            </div>
          )}
          {settings.timedMode && !settings.practiceMode && gameState !== 'playing' && (
            <div style={{ textAlign: 'center', padding: '10px', backgroundColor: 'rgba(251, 191, 36, 0.15)', borderRadius: '12px', fontSize: '0.85rem', color: '#fbbf24', border: '1px solid rgba(251, 191, 36, 0.3)' }}>
              â± Timed Mode - Answer quickly for bonus points!
            </div>
          )}

          <div className={shakeWrong ? 'shake' : ''} style={styles.choicesGrid}>
            {choices.map((choice, i) => {
              const correctAnswer = currentQuestion ? getCorrectAnswer(currentQuestion) : null;
              const isCorrect = gameState === 'result' && choice === correctAnswer;
              const isWrong = gameState === 'result' && choice === selectedAnswer && choice !== correctAnswer;
              return (
                <button key={i} onClick={() => handleGuess(choice)} disabled={gameState === 'result'}
                  className={`btn-press ${isCorrect ? 'glow-green' : ''} ${isWrong ? 'glow-red' : ''}`}
                  style={{ ...styles.choiceBtn, fontSize: '0.9rem', position: 'relative', ...(isCorrect ? styles.choiceBtnCorrect : {}), ...(isWrong ? styles.choiceBtnWrong : {}), ...(gameState === 'result' ? { cursor: 'default' } : {}) }}>
                  <span style={{ position: 'absolute', top: '4px', left: '8px', fontSize: '0.65rem', color: 'rgba(255,255,255,0.3)', fontWeight: '500' }}>{i + 1}</span>
                  {getChoiceLabel(choice)}
                </button>
              );
            })}
          </div>

          <div style={styles.actionButtons}>
            {gameState === 'result' && <button onClick={generateRound} className="btn-press" style={styles.nextBtn}>Next â†’</button>}
            <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
          </div>

          {/* Keyboard shortcuts hint for desktop */}
          <div style={{ textAlign: 'center', marginTop: '8px', fontSize: '0.7rem', color: 'rgba(255,255,255,0.25)' }}>
            <span style={{ display: 'none' }} className="kbd-hint">
              [Space/R] Replay Â· [1-{choices.length}] Answer Â· [Enter/N] Next
            </span>
          </div>
          <style>{`.kbd-hint { display: none !important; } @media (hover: hover) and (pointer: fine) { .kbd-hint { display: inline !important; } }`}</style>

          <FloatingPlayButton onClick={handleReplay} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Note Game
    function NoteGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const note = diffSettings.notes[Math.floor(Math.random() * diffSettings.notes.length)];
        const octave = diffSettings.octaves[Math.floor(Math.random() * diffSettings.octaves.length)];
        const available = diffSettings.notes.filter(n => n !== note);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, note]);
        return { note, octave, choices, play: () => audio.playNote(note, octave) };
      };
      return <GameComponent mode="notes" difficulty={difficulty} onBack={onBack} difficultySettings={NOTE_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => c} getCorrectAnswer={q => q.note} />;
    }

    // Interval Game with Melodic/Harmonic support and Direction setting
    function IntervalGame({ difficulty, onBack }) {
      const { settings } = useSettings();
      const buildQuestion = (diffSettings, audio) => {
        const interval = diffSettings.intervals[Math.floor(Math.random() * diffSettings.intervals.length)];
        const baseNote = NOTES[Math.floor(Math.random() * NOTES.length)];
        const baseIndex = getNoteIndex(baseNote);

        // Determine direction based on setting
        let direction = settings.intervalDirection;
        if (direction === 'random') {
          direction = Math.random() < 0.5 ? 'ascending' : 'descending';
        }

        let notes;
        if (direction === 'descending') {
          // Descending: second note is BELOW the first
          const baseOctave = 5; // Start higher so we have room to go down
          const secondIndex = ((baseIndex - interval) % 12 + 12) % 12;
          const secondOctave = baseIndex - interval < 0 ? 4 : 5;
          notes = [`${baseNote}${baseOctave}`, `${NOTES[secondIndex]}${secondOctave}`];
        } else {
          // Ascending: second note is ABOVE the first (default behavior)
          const secondIndex = (baseIndex + interval) % 12;
          const secondOctave = baseIndex + interval >= 12 ? 5 : 4;
          notes = [`${baseNote}4`, `${NOTES[secondIndex]}${secondOctave}`];
        }

        const available = diffSettings.intervals.filter(i => i !== interval);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, interval]);
        // Play melodically (sequentially) or harmonically (together) based on setting
        const play = settings.intervalPlayback === 'harmonic'
          ? () => audio.playNotes(notes)
          : () => audio.playSequence(notes);
        return { interval, notes, choices, play, direction };
      };
      return <GameComponent mode="intervals" difficulty={difficulty} onBack={onBack} difficultySettings={INTERVAL_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => INTERVALS[c].name} getCorrectAnswer={q => q.interval} />;
    }

    // Chord Game
    function ChordGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const chordType = diffSettings.chords[Math.floor(Math.random() * diffSettings.chords.length)];
        const rootNote = NOTES[Math.floor(Math.random() * NOTES.length)];
        const notes = buildChord(rootNote, chordType, 4);
        const available = diffSettings.chords.filter(c => c !== chordType);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, chordType]);
        return { chordType, notes, choices, play: () => audio.playNotes(notes) };
      };
      return <GameComponent mode="chords" difficulty={difficulty} onBack={onBack} difficultySettings={CHORD_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => CHORD_TYPES[c].name} getCorrectAnswer={q => q.chordType} />;
    }

    // Scale Game
    function ScaleGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const scaleType = diffSettings.scales[Math.floor(Math.random() * diffSettings.scales.length)];
        const rootNote = NATURAL_NOTES[Math.floor(Math.random() * NATURAL_NOTES.length)];
        const notes = buildScale(rootNote, scaleType, 4);
        const available = diffSettings.scales.filter(s => s !== scaleType);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, scaleType]);
        return { scaleType, notes, choices, play: () => audio.playSequence(notes, 0.25) };
      };
      return <GameComponent mode="scales" difficulty={difficulty} onBack={onBack} difficultySettings={SCALE_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => SCALE_TYPES[c].name} getCorrectAnswer={q => q.scaleType} />;
    }

    // Progression Game
    function ProgressionGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const progressionKey = diffSettings.progressions[Math.floor(Math.random() * diffSettings.progressions.length)];
        const rootNote = NATURAL_NOTES[Math.floor(Math.random() * NATURAL_NOTES.length)];
        const chords = buildProgression(rootNote, progressionKey, 3);
        const available = diffSettings.progressions.filter(p => p !== progressionKey);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, progressionKey]);
        return { progressionKey, chords, choices, play: () => audio.playChordSequence(chords) };
      };
      return <GameComponent mode="progressions" difficulty={difficulty} onBack={onBack} difficultySettings={PROGRESSION_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => PROGRESSIONS[c].name} getCorrectAnswer={q => q.progressionKey} />;
    }

    // Learn View with Swipe
    function LearnView({ onCircleOfFifths, onReferenceLibrary }) {
      const { settings } = useSettings();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const [currentPage, setCurrentPage] = useState('intervals');

      const ScalesPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Scales</h2>
          {Object.entries(SCALE_TYPES).map(([key, scale]) => {
            const notes = buildScale('C', key, 4);
            const noteNames = scale.intervals.map(i => NOTES[(i % 12)]);
            return (
              <Accordion key={key} title={scale.name} onPlay={() => audio.playSequence(notes, 0.25)} isPlaying={audio.isPlaying}>
                <div style={styles.refNotes}>{noteNames.join(' - ')}</div>
                <div style={styles.refDesc}>{scale.description}</div>
              </Accordion>
            );
          })}
        </div>
      );

      const ChordsPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Chords</h2>
          {Object.entries(CHORD_TYPES).map(([key, chord]) => {
            const notes = buildChord('C', key, 4);
            const noteNames = chord.intervals.map(i => NOTES[(i % 12)]);
            return (
              <Accordion key={key} title={`C${chord.symbol} - ${chord.name}`} onPlay={() => audio.playNotes(notes)} isPlaying={audio.isPlaying}>
                <div style={styles.refNotes}>{noteNames.join(' - ')}</div>
                <div style={styles.refDesc}>Intervals: {chord.intervals.join(', ')} semitones</div>
              </Accordion>
            );
          })}
        </div>
      );

      const ProgressionsPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Progressions</h2>
          {Object.entries(PROGRESSIONS).map(([key, prog]) => {
            const chords = buildProgression('C', key, 3);
            return (
              <Accordion key={key} title={prog.name} onPlay={() => audio.playChordSequence(chords)} isPlaying={audio.isPlaying}>
                <div style={styles.refDesc}>{prog.description}</div>
              </Accordion>
            );
          })}
        </div>
      );

      const IntervalsPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Intervals</h2>
          {Object.entries(INTERVALS).map(([key, interval]) => {
            const baseNote = 'C';
            const octave = 4;
            const noteIndex = NOTES.indexOf(baseNote);
            const secondNote = NOTES[(noteIndex + parseInt(key)) % 12];
            const secondOctave = octave + Math.floor((noteIndex + parseInt(key)) / 12);
            const notes = [`${baseNote}${octave}`, `${secondNote}${secondOctave}`];
            return (
              <Accordion key={key} title={`${interval.name} (${interval.short})`} onPlay={() => audio.playSequence(notes)} isPlaying={audio.isPlaying}>
                <div style={styles.refNotes}>{baseNote} â†’ {secondNote}</div>
                <div style={styles.refDesc}>Sounds like: {interval.songs.join(', ')}</div>
                <PianoVisualization highlightedNotes={notes} startOctave={4} octaves={1} />
              </Accordion>
            );
          })}
        </div>
      );

      const GuitarPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Guitar Chords</h2>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '12px' }}>
            {Object.entries(GUITAR_CHORDS).map(([key, chord]) => (
              <div key={key} style={{ backgroundColor: 'rgba(255,255,255,0.05)', borderRadius: '12px', padding: '8px' }}>
                <GuitarChordChart chord={key} size="small" />
              </div>
            ))}
          </div>
        </div>
      );

      const pages = { intervals: <IntervalsPage />, scales: <ScalesPage />, chords: <ChordsPage />, progressions: <ProgressionsPage />, guitar: <GuitarPage /> };

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Learn' }]} />

          {/* Learning Tools */}
          <div style={{ display: 'flex', gap: '12px', marginBottom: '16px' }}>
            <button onClick={onCircleOfFifths} className="btn-press card-lift"
              style={{ flex: 1, padding: '16px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(99, 102, 241, 0.1))', color: 'white', textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', marginBottom: '8px' }}>â­•</div>
              <div style={{ fontWeight: '600' }}>Circle of Fifths</div>
            </button>
            <button onClick={onReferenceLibrary} className="btn-press card-lift"
              style={{ flex: 1, padding: '16px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(139, 92, 246, 0.1))', color: 'white', textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', marginBottom: '8px' }}>ðŸ“š</div>
              <div style={{ fontWeight: '600' }}>Reference Library</div>
            </button>
          </div>

          <p style={{ textAlign: 'center', color: '#64748b', fontSize: '0.8rem', marginBottom: '12px' }}>Swipe left/right to navigate</p>
          <SwipeContainer pages={pages} currentPage={currentPage} setCurrentPage={setCurrentPage} />
        </div>
      );
    }

    // Stats View
    function StatsView() {
      const { stats, resetStats, getWeaknesses } = useStats();
      const { sessionStats, resetSessionStats } = useSessionStats();
      const { addToast } = useToast();
      const [showAchievements, setShowAchievements] = useState(false);
      const [sessionTime, setSessionTime] = useState(0);

      // Update session time every second
      useEffect(() => {
        const interval = setInterval(() => {
          setSessionTime(Math.floor((Date.now() - sessionStats.startTime) / 1000));
        }, 1000);
        return () => clearInterval(interval);
      }, [sessionStats.startTime]);

      const formatDuration = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const getAccuracy = (correct, total) => total === 0 ? 0 : Math.round((correct / total) * 100);
      const totalAnswered = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalAnswered, 0);
      const totalCorrect = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalCorrect, 0);
      const overallAccuracy = getAccuracy(totalCorrect, totalAnswered);
      const bestStreak = Math.max(...Object.keys(GAME_MODES).map(key => stats[key].bestStreak));
      const sessionAccuracy = getAccuracy(sessionStats.totalCorrect, sessionStats.totalAnswered);

      // Check unlocked achievements
      const unlockedAchievements = Object.values(ACHIEVEMENTS).filter(a => a.requirement(stats));
      const lockedAchievements = Object.values(ACHIEVEMENTS).filter(a => !a.requirement(stats));

      const handleShare = async () => {
        const text = getShareText(stats);
        triggerHaptic('light');
        try {
          if (navigator.share) {
            await navigator.share({ title: 'KeyPerfect Stats', text });
          } else if (navigator.clipboard) {
            await navigator.clipboard.writeText(text);
            addToast('Copied to clipboard!', 'success');
          }
        } catch (err) {}
      };

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Stats' }]} />

          {/* Session Stats Card */}
          {sessionStats.totalAnswered > 0 && (
            <div style={{ ...styles.statsCard, marginBottom: '16px', background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.1))' }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <div style={styles.statsTitle}>Current Session</div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  <span style={{ fontSize: '0.85rem', color: '#94a3b8' }}>{formatDuration(sessionTime)}</span>
                  <button onClick={() => { resetSessionStats(); triggerHaptic('light'); addToast('Session reset!', 'info'); }}
                    style={{ padding: '4px 8px', fontSize: '0.7rem', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.2)', background: 'rgba(255,255,255,0.1)', color: '#94a3b8' }}>
                    Reset
                  </button>
                </div>
              </div>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '8px', textAlign: 'center' }}>
                <div>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{sessionStats.totalCorrect}/{sessionStats.totalAnswered}</div>
                  <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Correct</div>
                </div>
                <div>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: sessionAccuracy >= 80 ? '#22c55e' : sessionAccuracy >= 50 ? '#fbbf24' : '#ef4444' }}>{sessionAccuracy}%</div>
                  <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Accuracy</div>
                </div>
                <div>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#a855f7' }}>{sessionStats.currentStreak}</div>
                  <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Streak</div>
                </div>
                <div>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#f97316' }}>{sessionStats.bestStreak}</div>
                  <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Best</div>
                </div>
              </div>
              {Object.keys(sessionStats.byMode).length > 0 && (
                <div style={{ marginTop: '12px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' }}>
                  <div style={{ fontSize: '0.75rem', color: '#64748b', marginBottom: '8px' }}>By Mode</div>
                  <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                    {Object.entries(sessionStats.byMode).map(([mode, modeStats]) => (
                      <div key={mode} style={{ padding: '4px 10px', background: 'rgba(255,255,255,0.05)', borderRadius: '8px', fontSize: '0.75rem' }}>
                        <span style={{ color: '#94a3b8' }}>{GAME_MODES[mode]?.icon || ''} </span>
                        <span style={{ color: '#e2e8f0' }}>{modeStats.correct}/{modeStats.total}</span>
                        <span style={{ color: '#64748b' }}> ({getAccuracy(modeStats.correct, modeStats.total)}%)</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Overall Stats with Progress Rings */}
          <div style={{ ...styles.statsCard, marginBottom: '16px' }}>
            <div style={styles.statsTitle}>ðŸ“Š Overall Progress</div>
            <div style={{ display: 'flex', justifyContent: 'space-around', alignItems: 'center', padding: '16px 0' }}>
              <div style={{ position: 'relative', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                <ProgressRing progress={overallAccuracy} size={90} strokeWidth={8} color="#22c55e" value={`${overallAccuracy}%`} />
                <div style={{ marginTop: '36px', fontSize: '0.75rem', color: '#94a3b8', textTransform: 'uppercase' }}>Accuracy</div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '2.5rem', fontWeight: '700', background: 'linear-gradient(135deg, #a855f7, #ec4899)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>{totalAnswered}</div>
                <div style={{ fontSize: '0.75rem', color: '#94a3b8', textTransform: 'uppercase' }}>Questions</div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '2.5rem', fontWeight: '700', color: '#f97316', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}>
                  {bestStreak}
                  {bestStreak >= 5 && <span style={{ fontSize: '1.5rem' }}>ðŸ”¥</span>}
                </div>
                <div style={{ fontSize: '0.75rem', color: '#94a3b8', textTransform: 'uppercase' }}>Best Streak</div>
              </div>
            </div>
          </div>

          {/* Weaknesses Section */}
          {(() => {
            const getItemName = (mode, item) => {
              if (mode === 'intervals') return INTERVALS[item]?.name || item;
              if (mode === 'chords') return CHORD_TYPES[item]?.name || item;
              if (mode === 'scales') return SCALE_TYPES[item]?.name || item;
              if (mode === 'progressions') return PROGRESSIONS[item]?.name || item;
              return item;
            };
            const allWeaknesses = Object.keys(GAME_MODES)
              .flatMap(mode => getWeaknesses(mode, 3).map(w => ({ ...w, mode })))
              .filter(w => w.accuracy < 70)
              .sort((a, b) => a.accuracy - b.accuracy)
              .slice(0, 5);
            if (allWeaknesses.length === 0) return null;
            return (
              <div style={{ ...styles.statsCard, marginBottom: '16px', background: 'linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.05))' }}>
                <div style={styles.statsTitle}>Areas to Improve</div>
                <div style={{ marginTop: '12px' }}>
                  {allWeaknesses.map((w, i) => (
                    <div key={`${w.mode}-${w.item}`} style={{
                      display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                      padding: '10px 12px', marginBottom: i < allWeaknesses.length - 1 ? '8px' : 0,
                      background: 'rgba(255,255,255,0.05)', borderRadius: '10px'
                    }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                        <span style={{ fontSize: '1.1rem' }}>{GAME_MODES[w.mode]?.icon || ''}</span>
                        <div>
                          <div style={{ fontWeight: '600', fontSize: '0.9rem' }}>{getItemName(w.mode, w.item)}</div>
                          <div style={{ fontSize: '0.75rem', color: '#64748b' }}>{w.correct}/{w.total} correct</div>
                        </div>
                      </div>
                      <div style={{
                        padding: '4px 10px', borderRadius: '8px', fontSize: '0.85rem', fontWeight: '600',
                        background: w.accuracy < 40 ? 'rgba(239, 68, 68, 0.3)' : 'rgba(251, 191, 36, 0.3)',
                        color: w.accuracy < 40 ? '#fca5a5' : '#fcd34d'
                      }}>
                        {w.accuracy}%
                      </div>
                    </div>
                  ))}
                </div>
                <div style={{ marginTop: '12px', fontSize: '0.75rem', color: '#64748b', textAlign: 'center' }}>
                  Based on questions answered 3+ times
                </div>
              </div>
            );
          })()}

          {/* Achievements Section */}
          <div style={styles.statsCard}>
            <button onClick={() => setShowAchievements(!showAchievements)} className="btn-press"
              style={{ background: 'none', border: 'none', color: 'white', width: '100%', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: 'pointer' }}>
              <div style={styles.statsTitle}>ðŸ† Achievements ({unlockedAchievements.length}/{Object.keys(ACHIEVEMENTS).length})</div>
              <span style={{ transform: showAchievements ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.3s' }}>â–¼</span>
            </button>
            <div className="accordion-content" style={{ maxHeight: showAchievements ? '600px' : '0', opacity: showAchievements ? 1 : 0 }}>
              <div style={{ marginTop: '12px' }}>
                {unlockedAchievements.length > 0 && (
                  <div style={{ marginBottom: '16px' }}>
                    <div style={{ fontSize: '0.8rem', color: '#22c55e', marginBottom: '8px', fontWeight: '600' }}>Unlocked</div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '10px' }}>
                      {unlockedAchievements.map(a => (
                        <div key={a.id} className="card-lift" style={{ textAlign: 'center', padding: '14px 6px', background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(16, 185, 129, 0.15))', borderRadius: '16px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                          <div style={{ fontSize: '1.8rem', marginBottom: '6px' }} className="badge-shine">{a.icon}</div>
                          <div style={{ fontSize: '0.75rem', fontWeight: '600' }}>{a.name}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                {lockedAchievements.length > 0 && (
                  <div>
                    <div style={{ fontSize: '0.8rem', color: '#64748b', marginBottom: '8px', fontWeight: '600' }}>Locked</div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '10px' }}>
                      {lockedAchievements.map(a => (
                        <div key={a.id} style={{ textAlign: 'center', padding: '14px 6px', backgroundColor: 'rgba(255,255,255,0.03)', borderRadius: '16px', opacity: 0.6, border: '1px solid rgba(255,255,255,0.05)' }}>
                          <div style={{ fontSize: '1.8rem', marginBottom: '6px', filter: 'grayscale(100%)' }}>ðŸ”’</div>
                          <div style={{ fontSize: '0.75rem', fontWeight: '600', marginBottom: '4px' }}>{a.name}</div>
                          <div style={{ fontSize: '0.6rem', color: '#64748b', lineHeight: 1.3 }}>{a.description}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Mode Stats */}
          {Object.entries(GAME_MODES).map(([key, mode]) => {
            const modeAccuracy = getAccuracy(stats[key].totalCorrect, stats[key].totalAnswered);
            return (
              <div key={key} style={styles.statsCard} className="card-lift">
                <div style={styles.statsTitle}><span>{mode.icon}</span><span>{mode.name}</span></div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
                  <div style={{ position: 'relative' }}>
                    <ProgressRing progress={modeAccuracy} size={60} strokeWidth={5} color={modeAccuracy >= 80 ? '#22c55e' : modeAccuracy >= 50 ? '#f97316' : '#ef4444'} value={`${modeAccuracy}%`} />
                  </div>
                  <div style={{ flex: 1, display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }}>
                    <div style={styles.statItem}><div style={styles.statValue}>{stats[key].totalAnswered}</div><div style={styles.statLabel}>Answered</div></div>
                    <div style={styles.statItem}><div style={styles.statValue}>{stats[key].bestStreak}</div><div style={styles.statLabel}>Best Streak</div></div>
                    <div style={styles.statItem}><div style={styles.statValue}>{stats[key].totalCorrect}</div><div style={styles.statLabel}>Correct</div></div>
                  </div>
                </div>
              </div>
            );
          })}
          {/* History Review Section */}
          {stats.history && stats.history.length > 0 && (
            <div style={styles.statsCard}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <div style={styles.statsTitle}>Recent Activity</div>
                <span style={{ fontSize: '0.75rem', color: '#64748b' }}>Last {Math.min(stats.history.length, 20)} answers</span>
              </div>
              <div style={{ maxHeight: '300px', overflowY: 'auto', paddingRight: '4px' }}>
                {stats.history.slice(-20).reverse().map((entry, i) => {
                  const mode = GAME_MODES[entry.mode];
                  const timeAgo = (() => {
                    const diff = Date.now() - entry.timestamp;
                    if (diff < 60000) return 'just now';
                    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
                    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
                    return `${Math.floor(diff / 86400000)}d ago`;
                  })();
                  const itemLabel = entry.item !== null ? (() => {
                    if (entry.mode === 'intervals') return INTERVALS[entry.item]?.name || entry.item;
                    if (entry.mode === 'chords') return CHORD_TYPES[entry.item]?.name || entry.item;
                    if (entry.mode === 'scales') return SCALE_TYPES[entry.item]?.name || entry.item;
                    if (entry.mode === 'progressions') return PROGRESSIONS[entry.item]?.name || entry.item;
                    return entry.item;
                  })() : null;
                  return (
                    <div key={i} style={{
                      display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                      padding: '10px 12px', marginBottom: '6px',
                      background: entry.correct ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                      borderRadius: '10px', borderLeft: `3px solid ${entry.correct ? '#22c55e' : '#ef4444'}`
                    }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                        <span style={{ fontSize: '1rem' }}>{mode?.icon || 'ðŸŽµ'}</span>
                        <div>
                          <div style={{ fontWeight: '500', fontSize: '0.85rem' }}>{mode?.name || entry.mode}</div>
                          {itemLabel && <div style={{ fontSize: '0.75rem', color: '#94a3b8' }}>{itemLabel}</div>}
                        </div>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <span style={{ fontSize: '0.7rem', color: '#64748b' }}>{timeAgo}</span>
                        <span style={{
                          width: '20px', height: '20px', borderRadius: '50%',
                          display: 'flex', alignItems: 'center', justifyContent: 'center',
                          fontSize: '0.7rem', fontWeight: '700',
                          background: entry.correct ? '#22c55e' : '#ef4444', color: 'white'
                        }}>
                          {entry.correct ? 'âœ“' : 'âœ—'}
                        </span>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Practice Heatmap */}
          <PracticeHeatmap />

          <button onClick={handleShare} className="btn-press" style={styles.shareBtn}>ðŸ“¤ Share Results</button>
          <button onClick={() => { if (confirm('Reset all statistics?')) { resetStats(); addToast('Stats reset', 'info'); } }} className="btn-press" style={styles.dangerBtn}>
            Reset All Statistics
          </button>
        </div>
      );
    }

    // Settings View
    function SettingsView() {
      const { settings, updateSettings } = useSettings();
      const { sfxEnabled, setSfxEnabled } = useSoundEffects();

      const Toggle = ({ checked, onChange }) => (
        <button onClick={() => { onChange(!checked); triggerHaptic('light'); }} className="btn-press"
          style={{ ...styles.toggle, backgroundColor: checked ? '#a855f7' : 'rgba(255, 255, 255, 0.2)' }}>
          <div style={{ ...styles.toggleKnob, left: checked ? '24px' : '2px' }} />
        </button>
      );

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Settings' }]} />

          {/* Sound Settings */}
          <div style={styles.card}>
            <h3 style={styles.cardTitle}>Sound</h3>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Instrument</span>
              <select value={settings.instrument} onChange={(e) => updateSettings({ instrument: e.target.value })} style={styles.select}>
                {Object.entries(INSTRUMENTS).map(([key, inst]) => (<option key={key} value={key}>{inst.name}</option>))}
              </select>
            </div>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Preview Sound</span>
              <SoundPreview instrument={settings.instrument} useMidi={settings.useMidi} volume={settings.volume} />
            </div>
            <div style={styles.settingRow}>
              <div>
                <span style={styles.settingLabel}>Use MIDI sounds</span>
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginTop: '2px' }}>Realistic sampled instruments</div>
              </div>
              <Toggle checked={settings.useMidi} onChange={(val) => updateSettings({ useMidi: val })} />
            </div>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Volume</span>
              <VolumeSlider value={settings.volume} onChange={(val) => updateSettings({ volume: val })} />
            </div>
            <div style={{ ...styles.settingRow, borderBottom: 'none' }}>
              <span style={styles.settingLabel}>Sound effects</span>
              <Toggle checked={sfxEnabled} onChange={setSfxEnabled} />
            </div>
          </div>

          {/* Game Settings */}
          <div style={{ ...styles.card, marginTop: '16px' }}>
            <h3 style={styles.cardTitle}>Game</h3>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Auto-play on new round</span>
              <Toggle checked={settings.autoPlayOnStart} onChange={(val) => updateSettings({ autoPlayOnStart: val })} />
            </div>
            <div style={styles.settingRow}>
              <div>
                <span style={styles.settingLabel}>Practice Mode</span>
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginTop: '2px' }}>Learn without scoring pressure</div>
              </div>
              <Toggle checked={settings.practiceMode} onChange={(val) => updateSettings({ practiceMode: val })} />
            </div>
            <div style={styles.settingRow}>
              <div>
                <span style={styles.settingLabel}>Timed Mode</span>
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginTop: '2px' }}>Race against the clock for bonus points</div>
              </div>
              <Toggle checked={settings.timedMode} onChange={(val) => updateSettings({ timedMode: val })} />
            </div>
            {settings.timedMode && (
              <div style={{ ...styles.settingRow, flexDirection: 'column', alignItems: 'stretch', gap: '12px' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <span style={styles.settingLabel}>Timer Duration</span>
                  <span style={{ fontSize: '1.1rem', fontWeight: '700', color: '#fbbf24' }}>{settings.timerDuration}s</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <span style={{ fontSize: '0.75rem', color: '#64748b' }}>3s</span>
                  <input
                    type="range"
                    min={3}
                    max={30}
                    step={1}
                    value={settings.timerDuration}
                    onChange={(e) => updateSettings({ timerDuration: parseInt(e.target.value) })}
                    style={{ flex: 1, background: `linear-gradient(to right, #fbbf24 ${((settings.timerDuration - 3) / 27) * 100}%, rgba(255,255,255,0.2) ${((settings.timerDuration - 3) / 27) * 100}%)` }}
                  />
                  <span style={{ fontSize: '0.75rem', color: '#64748b' }}>30s</span>
                </div>
                <div style={{ display: 'flex', justifyContent: 'center', gap: '8px' }}>
                  {[5, 10, 15, 20].map(t => (
                    <button key={t} onClick={() => { updateSettings({ timerDuration: t }); triggerHaptic('light'); }}
                      className="btn-press" style={{
                        padding: '6px 12px', borderRadius: '8px', fontSize: '0.75rem', fontWeight: '600',
                        border: settings.timerDuration === t ? '2px solid #fbbf24' : '1px solid rgba(255,255,255,0.2)',
                        background: settings.timerDuration === t ? 'rgba(251, 191, 36, 0.2)' : 'rgba(255,255,255,0.05)',
                        color: settings.timerDuration === t ? '#fbbf24' : '#94a3b8'
                      }}>
                      {t}s
                    </button>
                  ))}
                </div>
              </div>
            )}
            <div style={{ ...styles.settingRow, borderBottom: 'none' }}>
              <span style={styles.settingLabel}>Show octave in choices</span>
              <Toggle checked={settings.showOctaveInChoices} onChange={(val) => updateSettings({ showOctaveInChoices: val })} />
            </div>
          </div>

          {/* Interval Settings */}
          <div style={{ ...styles.card, marginTop: '16px' }}>
            <h3 style={styles.cardTitle}>Intervals</h3>
            <div style={styles.settingRow}>
              <div>
                <span style={styles.settingLabel}>Interval Playback</span>
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginTop: '2px' }}>
                  {settings.intervalPlayback === 'melodic' ? 'Notes played one after another' : 'Notes played together'}
                </div>
              </div>
              <div style={{ display: 'flex', gap: '8px' }}>
                <button onClick={() => { updateSettings({ intervalPlayback: 'melodic' }); triggerHaptic('light'); }}
                  className="btn-press" style={{
                    padding: '10px 16px', borderRadius: '10px', fontSize: '0.85rem', fontWeight: '600',
                    border: settings.intervalPlayback === 'melodic' ? '2px solid #a855f7' : '2px solid rgba(255,255,255,0.2)',
                    background: settings.intervalPlayback === 'melodic' ? 'rgba(168, 85, 247, 0.3)' : 'rgba(255,255,255,0.05)',
                    color: 'white'
                  }}>
                  Melodic
                </button>
                <button onClick={() => { updateSettings({ intervalPlayback: 'harmonic' }); triggerHaptic('light'); }}
                  className="btn-press" style={{
                    padding: '10px 16px', borderRadius: '10px', fontSize: '0.85rem', fontWeight: '600',
                    border: settings.intervalPlayback === 'harmonic' ? '2px solid #a855f7' : '2px solid rgba(255,255,255,0.2)',
                    background: settings.intervalPlayback === 'harmonic' ? 'rgba(168, 85, 247, 0.3)' : 'rgba(255,255,255,0.05)',
                    color: 'white'
                  }}>
                  Harmonic
                </button>
              </div>
            </div>
            <div style={{ ...styles.settingRow, borderBottom: 'none' }}>
              <div>
                <span style={styles.settingLabel}>Interval Direction</span>
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginTop: '2px' }}>
                  {settings.intervalDirection === 'ascending' ? 'Second note goes up' :
                   settings.intervalDirection === 'descending' ? 'Second note goes down' : 'Random direction each time'}
                </div>
              </div>
              <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', justifyContent: 'flex-end' }}>
                <button onClick={() => { updateSettings({ intervalDirection: 'ascending' }); triggerHaptic('light'); }}
                  className="btn-press" style={{
                    padding: '8px 12px', borderRadius: '10px', fontSize: '0.8rem', fontWeight: '600',
                    border: settings.intervalDirection === 'ascending' ? '2px solid #a855f7' : '2px solid rgba(255,255,255,0.2)',
                    background: settings.intervalDirection === 'ascending' ? 'rgba(168, 85, 247, 0.3)' : 'rgba(255,255,255,0.05)',
                    color: 'white'
                  }}>
                  Up
                </button>
                <button onClick={() => { updateSettings({ intervalDirection: 'descending' }); triggerHaptic('light'); }}
                  className="btn-press" style={{
                    padding: '8px 12px', borderRadius: '10px', fontSize: '0.8rem', fontWeight: '600',
                    border: settings.intervalDirection === 'descending' ? '2px solid #a855f7' : '2px solid rgba(255,255,255,0.2)',
                    background: settings.intervalDirection === 'descending' ? 'rgba(168, 85, 247, 0.3)' : 'rgba(255,255,255,0.05)',
                    color: 'white'
                  }}>
                  Down
                </button>
                <button onClick={() => { updateSettings({ intervalDirection: 'random' }); triggerHaptic('light'); }}
                  className="btn-press" style={{
                    padding: '8px 12px', borderRadius: '10px', fontSize: '0.8rem', fontWeight: '600',
                    border: settings.intervalDirection === 'random' ? '2px solid #a855f7' : '2px solid rgba(255,255,255,0.2)',
                    background: settings.intervalDirection === 'random' ? 'rgba(168, 85, 247, 0.3)' : 'rgba(255,255,255,0.05)',
                    color: 'white'
                  }}>
                  Random
                </button>
              </div>
            </div>
          </div>

          {/* Theme Settings */}
          <div style={{ ...styles.card, marginTop: '16px' }}>
            <h3 style={styles.cardTitle}>Appearance</h3>
            <div style={{ marginTop: '12px' }}>
              <ThemeSelector />
            </div>
          </div>

          <div style={{ ...styles.card, marginTop: '16px' }}>
            <h3 style={styles.cardTitle}>About</h3>
            <p style={{ color: '#94a3b8', fontSize: '0.9rem', lineHeight: 1.6 }}>
              KeyPerfect is an ear training app to help musicians recognize notes, intervals, chords, scales, and progressions.
            </p>
            <p style={{ color: '#64748b', fontSize: '0.8rem', marginTop: '12px' }}>Version 9.0</p>
          </div>
        </div>
      );
    }

    // Main Menu
    function MainMenu({ onStartGame, onStartDaily, onStartSpeedRun, onStartSurvival, onStartInversions, onStartSeventhChords, onStartMelodicDictation, onStartRelativePitch, onStartTempo, onStartTimeSignature }) {
      const [selectedMode, setSelectedMode] = useState('notes');
      const [selectedDifficulty, setSelectedDifficulty] = useState('easy');
      const [showAdvanced, setShowAdvanced] = useState(false);
      const { settings } = useSettings();
      const { dailyStats, hasPlayedToday } = useDailyChallenge();
      const { speedRunStats } = useSpeedRun();
      const { survivalStats } = useSurvival();

      const getDifficulties = () => {
        const map = { notes: NOTE_DIFFICULTIES, intervals: INTERVAL_DIFFICULTIES, chords: CHORD_DIFFICULTIES, scales: SCALE_DIFFICULTIES, progressions: PROGRESSION_DIFFICULTIES };
        return map[selectedMode];
      };

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play' }]} />

          {/* XP Display */}
          <XPDisplayCard />

          {/* Daily Challenge Card */}
          <div className={hasPlayedToday ? '' : 'daily-badge'} style={{
            ...styles.card,
            background: hasPlayedToday
              ? 'rgba(255, 255, 255, 0.08)'
              : 'linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.15))',
            border: hasPlayedToday ? '1px solid rgba(255,255,255,0.1)' : '1px solid rgba(251, 191, 36, 0.4)',
            marginBottom: '16px'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
              <div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                  <span style={{ fontSize: '1.5rem' }}>ðŸ“…</span>
                  <span style={{ fontSize: '1.1rem', fontWeight: '700', color: hasPlayedToday ? '#94a3b8' : '#fbbf24' }}>Daily Challenge</span>
                </div>
                {hasPlayedToday ? (
                  <div style={{ fontSize: '0.85rem', color: '#94a3b8' }}>
                    Completed! Score: {dailyStats.score} | Streak: {dailyStats.streak}
                  </div>
                ) : (
                  <div style={{ fontSize: '0.85rem', color: '#fbbf24' }}>
                    10 questions, one attempt. Can you beat yesterday?
                  </div>
                )}
              </div>
              <button onClick={() => { if (!hasPlayedToday) { onStartDaily(); triggerHaptic('medium'); } }}
                disabled={hasPlayedToday}
                className="btn-press" style={{
                  padding: '12px 20px', borderRadius: '12px', border: 'none',
                  background: hasPlayedToday ? 'rgba(255,255,255,0.1)' : 'linear-gradient(135deg, #fbbf24, #f59e0b)',
                  color: hasPlayedToday ? '#64748b' : '#1a1a2e',
                  fontWeight: '700', fontSize: '0.9rem',
                  cursor: hasPlayedToday ? 'not-allowed' : 'pointer',
                  opacity: hasPlayedToday ? 0.6 : 1
                }}>
                {hasPlayedToday ? 'âœ“ Done' : 'Play'}
              </button>
            </div>
          </div>

          {/* Speed Run Card */}
          <div style={{
            ...styles.card,
            background: 'linear-gradient(135deg, rgba(236, 72, 153, 0.15), rgba(249, 115, 22, 0.1))',
            border: '1px solid rgba(236, 72, 153, 0.3)',
            marginBottom: '16px'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
              <div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                  <span style={{ fontSize: '1.5rem' }}>âš¡</span>
                  <span style={{ fontSize: '1.1rem', fontWeight: '700', background: 'linear-gradient(135deg, #ec4899, #f97316)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>Speed Run</span>
                </div>
                <div style={{ fontSize: '0.85rem', color: '#94a3b8' }}>
                  60 seconds Â· High Score: <span style={{ color: '#fbbf24', fontWeight: '600' }}>{speedRunStats.highScore}</span>
                </div>
              </div>
              <button onClick={() => { onStartSpeedRun(); triggerHaptic('medium'); }}
                className="btn-press" style={{
                  padding: '12px 20px', borderRadius: '12px', border: 'none',
                  background: 'linear-gradient(135deg, #ec4899, #f97316)',
                  color: 'white', fontWeight: '700', fontSize: '0.9rem', cursor: 'pointer'
                }}>
                Play
              </button>
            </div>
          </div>

          {/* Survival Mode Card */}
          <div style={{
            ...styles.card,
            background: 'linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1))',
            border: '1px solid rgba(239, 68, 68, 0.3)',
            marginBottom: '16px'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
              <div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                  <span style={{ fontSize: '1.5rem' }}>â¤ï¸</span>
                  <span style={{ fontSize: '1.1rem', fontWeight: '700', color: '#ef4444' }}>Survival Mode</span>
                </div>
                <div style={{ fontSize: '0.85rem', color: '#94a3b8' }}>
                  3 lives Â· Best: <span style={{ color: '#ef4444', fontWeight: '600' }}>{survivalStats.bestScore}</span>
                </div>
              </div>
              <button onClick={() => { onStartSurvival(); triggerHaptic('medium'); }}
                className="btn-press" style={{
                  padding: '12px 20px', borderRadius: '12px', border: 'none',
                  background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                  color: 'white', fontWeight: '700', fontSize: '0.9rem', cursor: 'pointer'
                }}>
                Play
              </button>
            </div>
          </div>

          {/* Chord Inversions Card */}
          <div style={{
            ...styles.card,
            background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.1))',
            border: '1px solid rgba(34, 197, 94, 0.3)',
            marginBottom: '16px'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
              <div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                  <span style={{ fontSize: '1.5rem' }}>ðŸ”„</span>
                  <span style={{ fontSize: '1.1rem', fontWeight: '700', color: '#22c55e' }}>Chord Inversions</span>
                </div>
                <div style={{ fontSize: '0.85rem', color: '#94a3b8' }}>
                  Root Â· 1st Â· 2nd inversions
                </div>
              </div>
              <button onClick={() => { onStartInversions(); triggerHaptic('medium'); }}
                className="btn-press" style={{
                  padding: '12px 20px', borderRadius: '12px', border: 'none',
                  background: 'linear-gradient(135deg, #22c55e, #10b981)',
                  color: 'white', fontWeight: '700', fontSize: '0.9rem', cursor: 'pointer'
                }}>
                Play
              </button>
            </div>
          </div>

          {/* Daily Quests */}
          <DailyQuestsCard />

          {/* Weekly Challenges */}
          <WeeklyChallengesCard />

          {/* Advanced Training Modes */}
          <div style={{ ...styles.card, marginBottom: '16px' }}>
            <button onClick={() => setShowAdvanced(!showAdvanced)} className="btn-press"
              style={{ background: 'none', border: 'none', color: 'white', width: '100%', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: 'pointer', padding: '0' }}>
              <h2 style={{ ...styles.cardTitle, margin: 0 }}>Advanced Training</h2>
              <span style={{ transform: showAdvanced ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.3s' }}>â–¼</span>
            </button>
            <div className="accordion-content" style={{ maxHeight: showAdvanced ? '600px' : '0', opacity: showAdvanced ? 1 : 0, marginTop: showAdvanced ? '16px' : '0' }}>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '12px' }}>
                <button onClick={() => { onStartSeventhChords(); triggerHaptic('medium'); }} className="btn-press card-lift"
                  style={{ padding: '16px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(168, 85, 247, 0.1))', color: 'white', textAlign: 'left' }}>
                  <div style={{ fontSize: '1.5rem', marginBottom: '8px' }}>ðŸŽ¹</div>
                  <div style={{ fontWeight: '600', marginBottom: '4px' }}>7th Chords</div>
                  <div style={{ fontSize: '0.75rem', color: '#94a3b8' }}>maj7, m7, dom7, dim7</div>
                </button>
                <button onClick={() => { onStartMelodicDictation(); triggerHaptic('medium'); }} className="btn-press card-lift"
                  style={{ padding: '16px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(99, 102, 241, 0.1))', color: 'white', textAlign: 'left' }}>
                  <div style={{ fontSize: '1.5rem', marginBottom: '8px' }}>ðŸŽ¶</div>
                  <div style={{ fontWeight: '600', marginBottom: '4px' }}>Melodic Dictation</div>
                  <div style={{ fontSize: '0.75rem', color: '#94a3b8' }}>Transcribe melodies</div>
                </button>
                <button onClick={() => { onStartRelativePitch(); triggerHaptic('medium'); }} className="btn-press card-lift"
                  style={{ padding: '16px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(16, 185, 129, 0.1))', color: 'white', textAlign: 'left' }}>
                  <div style={{ fontSize: '1.5rem', marginBottom: '8px' }}>ðŸŽ¯</div>
                  <div style={{ fontWeight: '600', marginBottom: '4px' }}>Relative Pitch</div>
                  <div style={{ fontSize: '0.75rem', color: '#94a3b8' }}>Intervals from reference</div>
                </button>
                <button onClick={() => { onStartTempo(); triggerHaptic('medium'); }} className="btn-press card-lift"
                  style={{ padding: '16px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, rgba(249, 115, 22, 0.2), rgba(251, 146, 60, 0.1))', color: 'white', textAlign: 'left' }}>
                  <div style={{ fontSize: '1.5rem', marginBottom: '8px' }}>ðŸ¥</div>
                  <div style={{ fontWeight: '600', marginBottom: '4px' }}>Tempo Trainer</div>
                  <div style={{ fontSize: '0.75rem', color: '#94a3b8' }}>Guess the BPM</div>
                </button>
                <button onClick={() => { onStartTimeSignature(); triggerHaptic('medium'); }} className="btn-press card-lift"
                  style={{ padding: '16px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(219, 39, 119, 0.1))', color: 'white', textAlign: 'left', gridColumn: 'span 2' }}>
                  <div style={{ fontSize: '1.5rem', marginBottom: '8px' }}>ðŸŽµ</div>
                  <div style={{ fontWeight: '600', marginBottom: '4px' }}>Time Signatures</div>
                  <div style={{ fontSize: '0.75rem', color: '#94a3b8' }}>4/4, 3/4, 6/8, and more</div>
                </button>
              </div>
            </div>
          </div>

          <div style={styles.card}>
            <h2 style={styles.cardTitle}>Select Game Mode</h2>

            {/* Horizontal scrolling mode selector */}
            <div style={styles.modeScroll}>
              {Object.entries(GAME_MODES).map(([key, mode]) => (
                <button key={key} onClick={() => { setSelectedMode(key); triggerHaptic('light'); }}
                  className="btn-press card-lift" style={{ ...styles.modeCard, ...(selectedMode === key ? styles.modeCardActive : {}) }}>
                  <span style={styles.modeIcon}>{mode.icon}</span>
                  <div style={styles.modeName}>{mode.name}</div>
                  <div style={styles.modeDesc}>{mode.description}</div>
                </button>
              ))}
            </div>

            <h3 style={{ ...styles.cardTitle, marginTop: '24px', marginBottom: '16px' }}>Difficulty</h3>

            {/* Chip-style difficulty selector */}
            <div style={styles.difficultyChips}>
              {Object.entries(getDifficulties()).map(([key, diff]) => (
                <button key={key} onClick={() => { setSelectedDifficulty(key); triggerHaptic('light'); }}
                  className="btn-press" style={{ ...styles.difficultyChip, ...(selectedDifficulty === key ? styles.difficultyChipActive : {}) }}>
                  {diff.label}
                </button>
              ))}
            </div>

            {/* Difficulty description */}
            <p style={{ textAlign: 'center', color: '#94a3b8', fontSize: '0.85rem', marginBottom: '24px' }}>
              {getDifficulties()[selectedDifficulty]?.description}
            </p>

            {/* Mode indicators */}
            <div style={{ display: 'flex', gap: '8px', justifyContent: 'center', marginBottom: '16px', flexWrap: 'wrap' }}>
              {settings.practiceMode && (
                <div style={{ padding: '8px 14px', backgroundColor: 'rgba(168, 85, 247, 0.15)', borderRadius: '20px', fontSize: '0.8rem', color: '#a855f7', border: '1px solid rgba(168, 85, 247, 0.3)' }}>
                  ðŸŽ“ Practice
                </div>
              )}
              {settings.timedMode && !settings.practiceMode && (
                <div style={{ padding: '8px 14px', backgroundColor: 'rgba(251, 191, 36, 0.15)', borderRadius: '20px', fontSize: '0.8rem', color: '#fbbf24', border: '1px solid rgba(251, 191, 36, 0.3)' }}>
                  â± {settings.timerDuration}s Timer
                </div>
              )}
            </div>

            <button onClick={() => { onStartGame(selectedMode, selectedDifficulty); triggerHaptic('medium'); }}
              className="btn-press floating-btn" style={styles.startBtn}>
              Start Game
            </button>
          </div>
        </div>
      );
    }

    // Daily Challenge Component
    function DailyChallenge({ onBack }) {
      const { settings } = useSettings();
      const { addToast } = useToast();
      const { playSound } = useSoundEffects();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const { seed, startDaily, completeDaily, hasPlayedToday } = useDailyChallenge();

      const [questionIndex, setQuestionIndex] = useState(0);
      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(0);
      const [gameState, setGameState] = useState('playing');
      const [questions, setQuestions] = useState([]);
      const [selectedAnswer, setSelectedAnswer] = useState(null);
      const [lastResult, setLastResult] = useState(null);
      const [completed, setCompleted] = useState(false);
      const [confettiTrigger, setConfettiTrigger] = useState(0);

      const TOTAL_QUESTIONS = 10;

      // Generate all questions using seeded random at start
      useEffect(() => {
        if (hasPlayedToday) {
          setCompleted(true);
          return;
        }
        startDaily();

        const newQuestions = [];
        const modes = ['notes', 'intervals', 'chords', 'scales'];

        for (let i = 0; i < TOTAL_QUESTIONS; i++) {
          const modeIndex = Math.floor(seededRandom(seed + i * 100) * modes.length);
          const mode = modes[modeIndex];

          if (mode === 'notes') {
            const noteIndex = Math.floor(seededRandom(seed + i * 101) * NOTES.length);
            const note = NOTES[noteIndex];
            const octave = 4;
            const available = NOTES.filter(n => n !== note);
            const wrongChoices = seededShuffle(available, seed + i * 102).slice(0, 3);
            const choices = seededShuffle([...wrongChoices, note], seed + i * 103);
            newQuestions.push({ mode, note, octave, choices, answer: note });
          } else if (mode === 'intervals') {
            const intervals = [0, 2, 4, 5, 7, 12];
            const intIndex = Math.floor(seededRandom(seed + i * 104) * intervals.length);
            const interval = intervals[intIndex];
            const baseNote = NOTES[Math.floor(seededRandom(seed + i * 105) * NOTES.length)];
            const baseIndex = getNoteIndex(baseNote);
            const secondIndex = (baseIndex + interval) % 12;
            const secondOctave = baseIndex + interval >= 12 ? 5 : 4;
            const notes = [`${baseNote}4`, `${NOTES[secondIndex]}${secondOctave}`];
            const available = intervals.filter(i => i !== interval);
            const wrongChoices = seededShuffle(available, seed + i * 106).slice(0, 3);
            const choices = seededShuffle([...wrongChoices, interval], seed + i * 107);
            newQuestions.push({ mode, interval, notes, choices, answer: interval });
          } else if (mode === 'chords') {
            const chords = ['major', 'minor', 'dim', 'aug'];
            const chordIndex = Math.floor(seededRandom(seed + i * 108) * chords.length);
            const chordType = chords[chordIndex];
            const rootNote = NOTES[Math.floor(seededRandom(seed + i * 109) * NOTES.length)];
            const notes = buildChord(rootNote, chordType, 4);
            const available = chords.filter(c => c !== chordType);
            const wrongChoices = seededShuffle(available, seed + i * 110).slice(0, 3);
            const choices = seededShuffle([...wrongChoices, chordType], seed + i * 111);
            newQuestions.push({ mode, chordType, notes, choices, answer: chordType });
          } else if (mode === 'scales') {
            const scales = ['major', 'minor', 'dorian', 'mixolydian'];
            const scaleIndex = Math.floor(seededRandom(seed + i * 112) * scales.length);
            const scaleType = scales[scaleIndex];
            const rootNote = NOTES[Math.floor(seededRandom(seed + i * 113) * NOTES.length)];
            const notes = buildScale(rootNote, scaleType, 4);
            const available = scales.filter(s => s !== scaleType);
            const wrongChoices = seededShuffle(available, seed + i * 114).slice(0, 3);
            const choices = seededShuffle([...wrongChoices, scaleType], seed + i * 115);
            newQuestions.push({ mode, scaleType, notes, choices, answer: scaleType });
          }
        }
        setQuestions(newQuestions);
      }, [seed, hasPlayedToday, startDaily]);

      const currentQuestion = questions[questionIndex];

      const playCurrentQuestion = useCallback(() => {
        if (!currentQuestion || audio.isLoading) return;
        if (currentQuestion.mode === 'notes') {
          audio.playNote(currentQuestion.note, currentQuestion.octave);
        } else if (currentQuestion.mode === 'intervals') {
          audio.playSequence(currentQuestion.notes);
        } else if (currentQuestion.mode === 'chords') {
          audio.playNotes(currentQuestion.notes);
        } else if (currentQuestion.mode === 'scales') {
          audio.playSequence(currentQuestion.notes);
        }
      }, [currentQuestion, audio]);

      useEffect(() => {
        if (currentQuestion && !audio.isLoading && settings.autoPlayOnStart && gameState === 'playing') {
          setTimeout(playCurrentQuestion, 300);
        }
      }, [questionIndex, audio.isLoading]);

      const getChoiceLabel = (choice) => {
        if (!currentQuestion) return '';
        if (currentQuestion.mode === 'notes') return choice;
        if (currentQuestion.mode === 'intervals') return INTERVALS[choice]?.name || choice;
        if (currentQuestion.mode === 'chords') return CHORD_TYPES[choice]?.name || choice;
        if (currentQuestion.mode === 'scales') return SCALE_TYPES[choice]?.name || choice;
        return choice;
      };

      const handleGuess = (guess) => {
        if (gameState !== 'playing') return;
        const correct = guess === currentQuestion.answer;
        setSelectedAnswer(guess);

        if (correct) {
          playSound('success');
          triggerHaptic('success');
          setScore(s => s + 1);
          const newStreak = streak + 1;
          setStreak(newStreak);
          if (newStreak > bestStreak) setBestStreak(newStreak);
          setLastResult({ correct: true, message: 'âœ“ Correct!' });
          if (newStreak === 5) setConfettiTrigger(Date.now());
        } else {
          playSound('error');
          triggerHaptic('error');
          setStreak(0);
          setLastResult({ correct: false, message: `âœ— Wrong! It was ${getChoiceLabel(currentQuestion.answer)}` });
        }
        setGameState('result');
      };

      const handleNext = () => {
        if (questionIndex >= TOTAL_QUESTIONS - 1) {
          setCompleted(true);
          completeDaily(score, bestStreak);
          setConfettiTrigger(Date.now());
          addToast(`Daily Complete! Score: ${score}/${TOTAL_QUESTIONS}`, 'success');
        } else {
          setQuestionIndex(i => i + 1);
          setSelectedAnswer(null);
          setLastResult(null);
          setGameState('playing');
        }
      };

      if (completed) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Confetti trigger={confettiTrigger} />
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Daily Challenge' }]} />
            <div style={{ ...styles.card, textAlign: 'center', padding: '32px' }}>
              <div style={{ fontSize: '4rem', marginBottom: '16px' }}>ðŸ†</div>
              <h2 style={{ fontSize: '1.5rem', marginBottom: '8px', color: '#fbbf24' }}>Daily Complete!</h2>
              <p style={{ color: '#94a3b8', marginBottom: '24px' }}>Come back tomorrow for a new challenge</p>
              <div style={{ display: 'flex', justifyContent: 'center', gap: '32px', marginBottom: '24px' }}>
                <div><div style={{ fontSize: '2rem', fontWeight: '700', color: '#22c55e' }}>{score}/{TOTAL_QUESTIONS}</div><div style={{ fontSize: '0.8rem', color: '#94a3b8' }}>Score</div></div>
                <div><div style={{ fontSize: '2rem', fontWeight: '700', color: '#f97316' }}>{bestStreak}</div><div style={{ fontSize: '0.8rem', color: '#94a3b8' }}>Best Streak</div></div>
              </div>
              <button onClick={onBack} className="btn-press" style={styles.startBtn}>Back to Menu</button>
            </div>
          </div>
        );
      }

      if (!currentQuestion || audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }}>
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Daily Challenge' }]} />
            <Skeleton height={60} />
            <Skeleton height={100} />
            <Skeleton height={200} />
          </div>
        );
      }

      const modeLabels = { notes: 'Note', intervals: 'Interval', chords: 'Chord', scales: 'Scale' };

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Confetti trigger={confettiTrigger} />
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Daily Challenge' }]} />

          {/* Progress bar */}
          <div style={{ background: 'rgba(255,255,255,0.1)', borderRadius: '10px', overflow: 'hidden', height: '8px' }}>
            <div style={{ width: `${((questionIndex + 1) / TOTAL_QUESTIONS) * 100}%`, height: '100%', background: 'linear-gradient(90deg, #fbbf24, #f59e0b)', transition: 'width 0.3s ease' }} />
          </div>

          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <div style={{ fontSize: '0.9rem', color: '#fbbf24', fontWeight: '600' }}>ðŸ“… Question {questionIndex + 1}/{TOTAL_QUESTIONS}</div>
            <div style={{ fontSize: '0.9rem', color: '#94a3b8' }}>
              Score: <span style={{ color: '#22c55e', fontWeight: '700' }}>{score}</span> | Streak: <span style={{ color: '#f97316', fontWeight: '700' }}>{streak}</span>
            </div>
          </div>

          <div style={{ ...styles.card, textAlign: 'center', padding: '20px' }}>
            <div style={{ fontSize: '0.8rem', color: '#94a3b8', marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '1px' }}>
              Identify the {modeLabels[currentQuestion.mode]}
            </div>
          </div>

          {lastResult && (
            <div className={lastResult.correct ? 'success-check' : ''} style={{ ...styles.resultBox, backgroundColor: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)', borderColor: lastResult.correct ? '#22c55e' : '#ef4444' }}>
              <div style={{ fontSize: '1.2rem' }}>{lastResult.message}</div>
            </div>
          )}

          <div style={styles.choicesGrid}>
            {currentQuestion.choices.map((choice, i) => {
              const isCorrect = gameState === 'result' && choice === currentQuestion.answer;
              const isWrong = gameState === 'result' && choice === selectedAnswer && choice !== currentQuestion.answer;
              return (
                <button key={i} onClick={() => handleGuess(choice)} disabled={gameState === 'result'}
                  className={`btn-press ${isCorrect ? 'glow-green' : ''} ${isWrong ? 'glow-red' : ''}`}
                  style={{ ...styles.choiceBtn, fontSize: '0.9rem', ...(isCorrect ? styles.choiceBtnCorrect : {}), ...(isWrong ? styles.choiceBtnWrong : {}), ...(gameState === 'result' ? { cursor: 'default' } : {}) }}>
                  {getChoiceLabel(choice)}
                </button>
              );
            })}
          </div>

          <div style={styles.actionButtons}>
            {gameState === 'result' && (
              <button onClick={handleNext} className="btn-press" style={styles.nextBtn}>
                {questionIndex >= TOTAL_QUESTIONS - 1 ? 'Finish' : 'Next â†’'}
              </button>
            )}
          </div>

          <FloatingPlayButton onClick={playCurrentQuestion} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Speed Run Component - 60 second challenge
    function SpeedRun({ onBack }) {
      const { settings } = useSettings();
      const { addToast } = useToast();
      const { playSound } = useSoundEffects();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const { speedRunStats, saveRun } = useSpeedRun();

      const DURATION = 60; // 60 seconds
      const [timeLeft, setTimeLeft] = useState(DURATION);
      const [score, setScore] = useState(0);
      const [correct, setCorrect] = useState(0);
      const [total, setTotal] = useState(0);
      const [gameState, setGameState] = useState('ready'); // ready, playing, finished
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [selectedAnswer, setSelectedAnswer] = useState(null);
      const [scorePop, setScorePop] = useState(0);
      const [isNewHighScore, setIsNewHighScore] = useState(false);

      // Generate a random question
      const generateQuestion = useCallback(() => {
        const modes = ['notes', 'intervals', 'chords', 'scales'];
        const mode = modes[Math.floor(Math.random() * modes.length)];
        let question = null;

        if (mode === 'notes') {
          const note = NOTES[Math.floor(Math.random() * NOTES.length)];
          const octave = 4;
          const available = NOTES.filter(n => n !== note);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, note]);
          question = { mode, note, octave, choices, answer: note, play: () => audio.playNote(note, octave) };
        } else if (mode === 'intervals') {
          const intervals = [2, 3, 4, 5, 7, 12];
          const interval = intervals[Math.floor(Math.random() * intervals.length)];
          const baseNote = NOTES[Math.floor(Math.random() * NOTES.length)];
          const baseIndex = getNoteIndex(baseNote);
          const secondIndex = (baseIndex + interval) % 12;
          const secondOctave = baseIndex + interval >= 12 ? 5 : 4;
          const notes = [`${baseNote}4`, `${NOTES[secondIndex]}${secondOctave}`];
          const available = intervals.filter(i => i !== interval);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, interval]);
          question = { mode, interval, notes, choices, answer: interval, play: () => audio.playSequence(notes) };
        } else if (mode === 'chords') {
          const chords = ['major', 'minor', 'diminished', 'augmented'];
          const chordType = chords[Math.floor(Math.random() * chords.length)];
          const rootNote = NOTES[Math.floor(Math.random() * NOTES.length)];
          const notes = buildChord(rootNote, chordType, 4);
          const available = chords.filter(c => c !== chordType);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, chordType]);
          question = { mode, chordType, notes, choices, answer: chordType, play: () => audio.playNotes(notes) };
        } else if (mode === 'scales') {
          const scales = ['major', 'natural_minor', 'pentatonic_major', 'blues'];
          const scaleType = scales[Math.floor(Math.random() * scales.length)];
          const rootNote = NATURAL_NOTES[Math.floor(Math.random() * NATURAL_NOTES.length)];
          const notes = buildScale(rootNote, scaleType, 4);
          const available = scales.filter(s => s !== scaleType);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, scaleType]);
          question = { mode, scaleType, notes, choices, answer: scaleType, play: () => audio.playSequence(notes, 0.2) };
        }

        setCurrentQuestion(question);
        setSelectedAnswer(null);
        if (question && settings.autoPlayOnStart) {
          setTimeout(() => question.play(), 200);
        }
      }, [audio, settings.autoPlayOnStart]);

      // Timer
      useEffect(() => {
        if (gameState !== 'playing') return;
        if (timeLeft <= 0) {
          setGameState('finished');
          const newHigh = saveRun(score, correct, total);
          setIsNewHighScore(newHigh);
          if (newHigh) {
            addToast('ðŸ† NEW HIGH SCORE!', 'success');
          }
          return;
        }
        const timer = setTimeout(() => setTimeLeft(t => t - 1), 1000);
        return () => clearTimeout(timer);
      }, [timeLeft, gameState, score, correct, total, saveRun, addToast]);

      // Start game
      const startGame = () => {
        setGameState('playing');
        setTimeLeft(DURATION);
        setScore(0);
        setCorrect(0);
        setTotal(0);
        setIsNewHighScore(false);
        generateQuestion();
      };

      // Get choice label
      const getChoiceLabel = (choice) => {
        if (!currentQuestion) return '';
        if (currentQuestion.mode === 'notes') return choice;
        if (currentQuestion.mode === 'intervals') return INTERVALS[choice]?.name || choice;
        if (currentQuestion.mode === 'chords') return CHORD_TYPES[choice]?.name || choice;
        if (currentQuestion.mode === 'scales') return SCALE_TYPES[choice]?.name || choice;
        return choice;
      };

      // Handle guess
      const handleGuess = (guess) => {
        if (gameState !== 'playing') return;
        const isCorrect = guess === currentQuestion.answer;
        setSelectedAnswer(guess);
        setTotal(t => t + 1);

        if (isCorrect) {
          playSound('success');
          triggerHaptic('success');
          const points = timeLeft > 45 ? 3 : timeLeft > 20 ? 2 : 1; // More points for quick answers
          setScore(s => s + points);
          setCorrect(c => c + 1);
          setScorePop(Date.now());
        } else {
          playSound('error');
          triggerHaptic('error');
        }

        // Quick transition to next question
        setTimeout(() => generateQuestion(), isCorrect ? 300 : 600);
      };

      // Replay
      const handleReplay = () => {
        if (currentQuestion?.play) {
          triggerHaptic('light');
          currentQuestion.play();
        }
      };

      // Keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT') return;
          if ((e.code === 'Space' || e.key === 'r') && currentQuestion?.play && gameState === 'playing') {
            e.preventDefault();
            currentQuestion.play();
          }
          if (gameState === 'playing' && currentQuestion?.choices) {
            const num = parseInt(e.key);
            if (num >= 1 && num <= currentQuestion.choices.length) {
              e.preventDefault();
              handleGuess(currentQuestion.choices[num - 1]);
            }
          }
          if (gameState === 'ready' && (e.key === 'Enter' || e.code === 'Space')) {
            e.preventDefault();
            startGame();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [gameState, currentQuestion]);

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Speed Run' }]} />
            <Skeleton height={100} />
            <Skeleton height={200} />
          </div>
        );
      }

      // Ready state
      if (gameState === 'ready') {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Speed Run' }]} />
            <div style={{ ...styles.card, textAlign: 'center', padding: '32px 20px' }}>
              <div style={{ fontSize: '3rem', marginBottom: '16px' }}>âš¡</div>
              <h2 style={{ fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px', background: 'linear-gradient(135deg, #ec4899, #f97316)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>Speed Run</h2>
              <p style={{ color: '#94a3b8', marginBottom: '24px' }}>Answer as many questions as possible in 60 seconds!</p>
              <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', marginBottom: '24px' }}>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.8rem', fontWeight: '700', color: '#fbbf24' }}>{speedRunStats.highScore}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b', textTransform: 'uppercase' }}>High Score</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.8rem', fontWeight: '700', color: '#a855f7' }}>{speedRunStats.totalRuns}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b', textTransform: 'uppercase' }}>Total Runs</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.8rem', fontWeight: '700', color: '#22c55e' }}>{speedRunStats.bestAccuracy}%</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b', textTransform: 'uppercase' }}>Best Accuracy</div>
                </div>
              </div>
              <button onClick={startGame} className="btn-press floating-btn" style={{
                padding: '16px 48px', fontSize: '1.1rem', fontWeight: '700', borderRadius: '16px', border: 'none',
                background: 'linear-gradient(135deg, #ec4899, #f97316)', color: 'white', cursor: 'pointer'
              }}>
                START
              </button>
            </div>
            <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Back to Menu</button>
          </div>
        );
      }

      // Finished state
      if (gameState === 'finished') {
        const accuracy = total > 0 ? Math.round((correct / total) * 100) : 0;
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Speed Run' }]} />
            <Confetti trigger={isNewHighScore ? Date.now() : 0} />
            <div style={{ ...styles.card, textAlign: 'center', padding: '32px 20px' }}>
              <div style={{ fontSize: '3rem', marginBottom: '16px' }}>{isNewHighScore ? 'ðŸ†' : 'âš¡'}</div>
              <h2 style={{ fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px', color: isNewHighScore ? '#fbbf24' : 'white' }}>
                {isNewHighScore ? 'NEW HIGH SCORE!' : 'Time\'s Up!'}
              </h2>
              <div style={{ fontSize: '4rem', fontWeight: '800', marginBottom: '16px', background: 'linear-gradient(135deg, #ec4899, #f97316)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>{score}</div>
              <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', marginBottom: '24px' }}>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{correct}/{total}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b' }}>Correct</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#a855f7' }}>{accuracy}%</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b' }}>Accuracy</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#fbbf24' }}>{speedRunStats.highScore}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b' }}>High Score</div>
                </div>
              </div>
              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                <button onClick={startGame} className="btn-press" style={{
                  padding: '14px 32px', fontSize: '1rem', fontWeight: '700', borderRadius: '12px', border: 'none',
                  background: 'linear-gradient(135deg, #ec4899, #f97316)', color: 'white', cursor: 'pointer'
                }}>
                  Play Again
                </button>
                <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
              </div>
            </div>
          </div>
        );
      }

      // Playing state
      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Speed Run' }]} />

          {/* Timer and Score Bar */}
          <div className="speed-run-active" style={{
            ...styles.card,
            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
            background: 'linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(249, 115, 22, 0.15))',
            border: '1px solid rgba(236, 72, 153, 0.4)'
          }}>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '2rem', fontWeight: '800', color: timeLeft <= 10 ? '#ef4444' : '#ec4899' }} className={timeLeft <= 10 ? 'timer-warning' : ''}>
                {timeLeft}s
              </div>
              <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Time</div>
            </div>
            <div style={{ textAlign: 'center' }}>
              <div key={scorePop} className={scorePop ? 'score-pop' : ''} style={{ fontSize: '2.5rem', fontWeight: '800', background: 'linear-gradient(135deg, #ec4899, #f97316)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>
                {score}
              </div>
              <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Score</div>
            </div>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{correct}/{total}</div>
              <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Correct</div>
            </div>
          </div>

          {/* Mode indicator */}
          <div style={{ textAlign: 'center', fontSize: '0.85rem', color: '#94a3b8' }}>
            {currentQuestion && GAME_MODES[currentQuestion.mode]?.icon} {currentQuestion && GAME_MODES[currentQuestion.mode]?.name}
          </div>

          {/* Choices */}
          <div style={styles.choicesGrid}>
            {currentQuestion?.choices.map((choice, i) => (
              <button key={i} onClick={() => handleGuess(choice)}
                className="btn-press"
                style={{ ...styles.choiceBtn, fontSize: '0.9rem', position: 'relative' }}>
                <span style={{ position: 'absolute', top: '4px', left: '8px', fontSize: '0.65rem', color: 'rgba(255,255,255,0.3)', fontWeight: '500' }}>{i + 1}</span>
                {getChoiceLabel(choice)}
              </button>
            ))}
          </div>

          <FloatingPlayButton onClick={handleReplay} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Survival Mode Component - 3 lives, go as far as you can
    function SurvivalMode({ onBack }) {
      const { settings } = useSettings();
      const { addToast } = useToast();
      const { playSound } = useSoundEffects();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const { survivalStats, saveSurvival } = useSurvival();

      const [lives, setLives] = useState(3);
      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(0);
      const [gameState, setGameState] = useState('ready');
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [lostLifeKey, setLostLifeKey] = useState(0);
      const [isNewBest, setIsNewBest] = useState(false);

      const generateQuestion = useCallback(() => {
        const modes = ['notes', 'intervals', 'chords', 'scales'];
        const mode = modes[Math.floor(Math.random() * modes.length)];
        let question = null;

        if (mode === 'notes') {
          const note = NOTES[Math.floor(Math.random() * NOTES.length)];
          const octave = 4;
          const available = NOTES.filter(n => n !== note);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, note]);
          question = { mode, note, octave, choices, answer: note, play: () => audio.playNote(note, octave) };
        } else if (mode === 'intervals') {
          const intervals = [2, 3, 4, 5, 7, 12];
          const interval = intervals[Math.floor(Math.random() * intervals.length)];
          const baseNote = NOTES[Math.floor(Math.random() * NOTES.length)];
          const baseIndex = getNoteIndex(baseNote);
          const secondIndex = (baseIndex + interval) % 12;
          const secondOctave = baseIndex + interval >= 12 ? 5 : 4;
          const notes = [`${baseNote}4`, `${NOTES[secondIndex]}${secondOctave}`];
          const available = intervals.filter(i => i !== interval);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, interval]);
          question = { mode, interval, notes, choices, answer: interval, play: () => audio.playSequence(notes) };
        } else if (mode === 'chords') {
          const chords = ['major', 'minor', 'diminished', 'augmented'];
          const chordType = chords[Math.floor(Math.random() * chords.length)];
          const rootNote = NOTES[Math.floor(Math.random() * NOTES.length)];
          const notes = buildChord(rootNote, chordType, 4);
          const available = chords.filter(c => c !== chordType);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, chordType]);
          question = { mode, chordType, notes, choices, answer: chordType, play: () => audio.playNotes(notes) };
        } else if (mode === 'scales') {
          const scales = ['major', 'natural_minor', 'pentatonic_major', 'blues'];
          const scaleType = scales[Math.floor(Math.random() * scales.length)];
          const rootNote = NATURAL_NOTES[Math.floor(Math.random() * NATURAL_NOTES.length)];
          const notes = buildScale(rootNote, scaleType, 4);
          const available = scales.filter(s => s !== scaleType);
          const wrong = shuffle(available).slice(0, 3);
          const choices = shuffle([...wrong, scaleType]);
          question = { mode, scaleType, notes, choices, answer: scaleType, play: () => audio.playSequence(notes, 0.2) };
        }

        setCurrentQuestion(question);
        if (question && settings.autoPlayOnStart) {
          setTimeout(() => question.play(), 200);
        }
      }, [audio, settings.autoPlayOnStart]);

      const startGame = () => {
        setGameState('playing');
        setLives(3);
        setScore(0);
        setStreak(0);
        setBestStreak(0);
        setIsNewBest(false);
        generateQuestion();
      };

      const getChoiceLabel = (choice) => {
        if (!currentQuestion) return '';
        if (currentQuestion.mode === 'notes') return choice;
        if (currentQuestion.mode === 'intervals') return INTERVALS[choice]?.name || choice;
        if (currentQuestion.mode === 'chords') return CHORD_TYPES[choice]?.name || choice;
        if (currentQuestion.mode === 'scales') return SCALE_TYPES[choice]?.name || choice;
        return choice;
      };

      const handleGuess = (guess) => {
        if (gameState !== 'playing') return;
        const isCorrect = guess === currentQuestion.answer;

        if (isCorrect) {
          playSound('success');
          triggerHaptic('success');
          setScore(s => s + 1);
          const newStreak = streak + 1;
          setStreak(newStreak);
          if (newStreak > bestStreak) setBestStreak(newStreak);
          setTimeout(() => generateQuestion(), 300);
        } else {
          playSound('error');
          triggerHaptic('error');
          setStreak(0);
          setLostLifeKey(Date.now());
          const newLives = lives - 1;
          setLives(newLives);

          if (newLives <= 0) {
            setGameState('finished');
            const newBest = saveSurvival(score, bestStreak);
            setIsNewBest(newBest);
            if (newBest) addToast('ðŸ† NEW BEST SCORE!', 'success');
          } else {
            addToast(`ðŸ’” ${newLives} ${newLives === 1 ? 'life' : 'lives'} remaining`, 'error');
            setTimeout(() => generateQuestion(), 600);
          }
        }
      };

      const handleReplay = () => {
        if (currentQuestion?.play) {
          triggerHaptic('light');
          currentQuestion.play();
        }
      };

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Survival' }]} />
            <Skeleton height={100} />
            <Skeleton height={200} />
          </div>
        );
      }

      if (gameState === 'ready') {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Survival' }]} />
            <div style={{ ...styles.card, textAlign: 'center', padding: '32px 20px' }}>
              <div style={{ fontSize: '3rem', marginBottom: '16px' }}>â¤ï¸â¤ï¸â¤ï¸</div>
              <h2 style={{ fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px', color: '#ef4444' }}>Survival Mode</h2>
              <p style={{ color: '#94a3b8', marginBottom: '24px' }}>3 lives. One wrong answer = lose a life. How far can you go?</p>
              <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', marginBottom: '24px' }}>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.8rem', fontWeight: '700', color: '#fbbf24' }}>{survivalStats.bestScore}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b', textTransform: 'uppercase' }}>Best Score</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.8rem', fontWeight: '700', color: '#a855f7' }}>{survivalStats.totalGames}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b', textTransform: 'uppercase' }}>Games</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.8rem', fontWeight: '700', color: '#f97316' }}>{survivalStats.bestStreak}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b', textTransform: 'uppercase' }}>Best Streak</div>
                </div>
              </div>
              <button onClick={startGame} className="btn-press floating-btn" style={{
                padding: '16px 48px', fontSize: '1.1rem', fontWeight: '700', borderRadius: '16px', border: 'none',
                background: 'linear-gradient(135deg, #ef4444, #dc2626)', color: 'white', cursor: 'pointer'
              }}>
                START
              </button>
            </div>
            <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Back to Menu</button>
          </div>
        );
      }

      if (gameState === 'finished') {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Survival' }]} />
            <Confetti trigger={isNewBest ? Date.now() : 0} />
            <div style={{ ...styles.card, textAlign: 'center', padding: '32px 20px' }}>
              <div style={{ fontSize: '3rem', marginBottom: '16px' }}>{isNewBest ? 'ðŸ†' : 'ðŸ’€'}</div>
              <h2 style={{ fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px', color: isNewBest ? '#fbbf24' : 'white' }}>
                {isNewBest ? 'NEW BEST!' : 'Game Over'}
              </h2>
              <div style={{ fontSize: '4rem', fontWeight: '800', marginBottom: '16px', color: '#ef4444' }}>{score}</div>
              <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', marginBottom: '24px' }}>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#f97316' }}>{bestStreak}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b' }}>Best Streak</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#fbbf24' }}>{survivalStats.bestScore}</div>
                  <div style={{ fontSize: '0.75rem', color: '#64748b' }}>All-Time Best</div>
                </div>
              </div>
              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                <button onClick={startGame} className="btn-press" style={{
                  padding: '14px 32px', fontSize: '1rem', fontWeight: '700', borderRadius: '12px', border: 'none',
                  background: 'linear-gradient(135deg, #ef4444, #dc2626)', color: 'white', cursor: 'pointer'
                }}>
                  Try Again
                </button>
                <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Survival' }]} />

          <div style={{
            ...styles.card,
            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
            background: 'linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.15))',
            border: '1px solid rgba(239, 68, 68, 0.4)'
          }}>
            <div style={{ display: 'flex', gap: '8px' }}>
              {[...Array(3)].map((_, i) => (
                <span key={i} className={i === lives && lostLifeKey ? 'lose-life' : i < lives ? 'heart-beat' : ''}
                  style={{ fontSize: '1.8rem', opacity: i < lives ? 1 : 0.2, transition: 'opacity 0.3s' }}>
                  â¤ï¸
                </span>
              ))}
            </div>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '2rem', fontWeight: '800', color: '#ef4444' }}>{score}</div>
              <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Score</div>
            </div>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#f97316' }}>{streak}</div>
              <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase' }}>Streak</div>
            </div>
          </div>

          <div style={{ textAlign: 'center', fontSize: '0.85rem', color: '#94a3b8' }}>
            {currentQuestion && GAME_MODES[currentQuestion.mode]?.icon} {currentQuestion && GAME_MODES[currentQuestion.mode]?.name}
          </div>

          <div style={styles.choicesGrid}>
            {currentQuestion?.choices.map((choice, i) => (
              <button key={i} onClick={() => handleGuess(choice)}
                className="btn-press"
                style={{ ...styles.choiceBtn, fontSize: '0.9rem', position: 'relative' }}>
                <span style={{ position: 'absolute', top: '4px', left: '8px', fontSize: '0.65rem', color: 'rgba(255,255,255,0.3)', fontWeight: '500' }}>{i + 1}</span>
                {getChoiceLabel(choice)}
              </button>
            ))}
          </div>

          <FloatingPlayButton onClick={handleReplay} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Chord Inversions Game
    function ChordInversionsGame({ onBack }) {
      const { settings } = useSettings();
      const { recordAnswer } = useStats();
      const { addToast } = useToast();
      const { playSound } = useSoundEffects();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);

      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(0);
      const [total, setTotal] = useState(0);
      const [gameState, setGameState] = useState('playing');
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [lastResult, setLastResult] = useState(null);

      const buildInvertedChord = (root, chordType, inversion, octave = 4) => {
        const chord = CHORD_TYPES[chordType];
        if (!chord) return [];
        const rootIndex = getNoteIndex(root);
        let notes = chord.intervals.map(interval => {
          const noteIndex = (rootIndex + interval) % 12;
          return `${NOTES[noteIndex]}${octave}`;
        });
        // Apply inversion
        for (let i = 0; i < inversion; i++) {
          const note = notes.shift();
          const noteName = note.replace(/\d+/g, '');
          const noteOctave = parseInt(note.match(/\d+/)[0]) + 1;
          notes.push(`${noteName}${noteOctave}`);
        }
        return notes;
      };

      const generateQuestion = useCallback(() => {
        const chordTypes = ['major', 'minor'];
        const inversions = ['root', 'first', 'second'];
        const chordType = chordTypes[Math.floor(Math.random() * chordTypes.length)];
        const inversion = inversions[Math.floor(Math.random() * inversions.length)];
        const rootNote = NOTES[Math.floor(Math.random() * NOTES.length)];
        const inversionIndex = inversions.indexOf(inversion);
        const notes = buildInvertedChord(rootNote, chordType, inversionIndex, 4);
        const choices = shuffle(inversions);

        const question = {
          chordType,
          rootNote,
          inversion,
          notes,
          choices,
          answer: inversion,
          play: () => audio.playNotes(notes),
        };

        setCurrentQuestion(question);
        setLastResult(null);
        setGameState('playing');
        if (settings.autoPlayOnStart) {
          setTimeout(() => question.play(), 300);
        }
      }, [audio, settings.autoPlayOnStart]);

      useEffect(() => {
        if (!audio.isLoading) generateQuestion();
      }, [audio.isLoading]);

      const handleGuess = (guess) => {
        if (gameState !== 'playing') return;
        const correct = guess === currentQuestion.answer;
        setTotal(t => t + 1);

        if (correct) {
          playSound('success');
          triggerHaptic('success');
          setScore(s => s + 1);
          const newStreak = streak + 1;
          setStreak(newStreak);
          if (newStreak > bestStreak) setBestStreak(newStreak);
          setLastResult({ correct: true, message: 'âœ“ Correct!' });
        } else {
          playSound('error');
          triggerHaptic('error');
          setStreak(0);
          setLastResult({ correct: false, message: `âœ— It was ${CHORD_INVERSIONS[currentQuestion.answer].name}` });
        }
        recordAnswer('chords', 'medium', correct, correct ? streak + 1 : 0, `inv_${currentQuestion.answer}`);
        setGameState('result');
      };

      const handleReplay = () => {
        if (currentQuestion?.play) {
          triggerHaptic('light');
          currentQuestion.play();
        }
      };

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Inversions' }]} />
            <Skeleton height={60} />
            <Skeleton height={100} />
          </div>
        );
      }

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Chord Inversions' }]} />

          <ScoreBoard score={score} streak={streak} total={total} bestStreak={bestStreak} />

          <div style={{ textAlign: 'center', color: '#94a3b8', fontSize: '0.9rem' }}>
            What inversion is this <span style={{ color: '#a855f7', fontWeight: '600' }}>{currentQuestion?.rootNote} {CHORD_TYPES[currentQuestion?.chordType]?.name}</span> chord?
          </div>

          {lastResult && (
            <div style={{ ...styles.resultBox, backgroundColor: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)', borderColor: lastResult.correct ? '#22c55e' : '#ef4444' }}>
              <div style={{ fontSize: '1.2rem' }}>{lastResult.message}</div>
            </div>
          )}

          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            {currentQuestion?.choices.map((choice, i) => {
              const inv = CHORD_INVERSIONS[choice];
              const isCorrect = gameState === 'result' && choice === currentQuestion.answer;
              const isWrong = gameState === 'result' && choice !== currentQuestion.answer;
              return (
                <button key={i} onClick={() => handleGuess(choice)} disabled={gameState === 'result'}
                  className={`btn-press ${isCorrect ? 'glow-green' : ''}`}
                  style={{
                    ...styles.choiceBtn, padding: '16px', textAlign: 'left',
                    ...(isCorrect ? styles.choiceBtnCorrect : {}),
                    ...(gameState === 'result' && isWrong ? { opacity: 0.5 } : {})
                  }}>
                  <div style={{ fontWeight: '600' }}>{inv.name}</div>
                  <div style={{ fontSize: '0.75rem', color: '#94a3b8', marginTop: '4px' }}>{inv.description}</div>
                </button>
              );
            })}
          </div>

          <div style={styles.actionButtons}>
            {gameState === 'result' && <button onClick={generateQuestion} className="btn-press" style={styles.nextBtn}>Next â†’</button>}
            <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
          </div>

          <FloatingPlayButton onClick={handleReplay} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Seventh Chords Dedicated Training
    function SeventhChordsGame({ onBack }) {
      const { settings } = useSettings();
      const { recordAnswer } = useStats();
      const { addToast } = useToast();
      const { playSound } = useSoundEffects();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const { addXP } = useXP();

      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(0);
      const [total, setTotal] = useState(0);
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [lastResult, setLastResult] = useState(null);
      const [gameState, setGameState] = useState('playing');

      const generateQuestion = useCallback(() => {
        const chordTypes = Object.keys(SEVENTH_CHORD_TYPES);
        const chordType = chordTypes[Math.floor(Math.random() * chordTypes.length)];
        const rootNote = NOTES[Math.floor(Math.random() * NOTES.length)];
        const chord = SEVENTH_CHORD_TYPES[chordType];
        const rootIndex = getNoteIndex(rootNote);
        const notes = chord.intervals.map(interval => {
          const noteIndex = (rootIndex + interval) % 12;
          const octave = rootIndex + interval >= 12 ? 5 : 4;
          return `${NOTES[noteIndex]}${octave}`;
        });
        const choices = shuffle(chordTypes).slice(0, 4);
        if (!choices.includes(chordType)) choices[0] = chordType;

        const question = {
          chordType,
          rootNote,
          notes,
          choices: shuffle(choices),
          answer: chordType,
          play: () => audio.playNotes(notes),
        };

        setCurrentQuestion(question);
        setLastResult(null);
        setGameState('playing');
        if (settings.autoPlayOnStart) setTimeout(() => question.play(), 300);
      }, [audio, settings.autoPlayOnStart]);

      useEffect(() => {
        if (!audio.isLoading) generateQuestion();
      }, [audio.isLoading]);

      const handleGuess = (guess) => {
        if (gameState !== 'playing') return;
        const correct = guess === currentQuestion.answer;
        setTotal(t => t + 1);

        if (correct) {
          playSound('success');
          triggerHaptic('success');
          setScore(s => s + 1);
          const newStreak = streak + 1;
          setStreak(newStreak);
          if (newStreak > bestStreak) setBestStreak(newStreak);
          setLastResult({ correct: true, message: 'âœ“ Correct!' });
          addXP(15, 'seventh_chords');
        } else {
          playSound('error');
          triggerHaptic('error');
          setStreak(0);
          setLastResult({ correct: false, message: `âœ— It was ${SEVENTH_CHORD_TYPES[currentQuestion.answer].name}` });
        }
        recordAnswer('chords', 'hard', correct, correct ? streak + 1 : 0, `7th_${currentQuestion.answer}`);
        setGameState('result');
      };

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: '7th Chords' }]} />
            <div style={{ ...styles.card, flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
              <div>Loading sounds...</div>
            </div>
          </div>
        );
      }

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: '7th Chords' }]} />

          <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', padding: '8px', background: 'rgba(255,255,255,0.05)', borderRadius: '12px' }}>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{score}/{total}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Score</div>
            </div>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#f97316' }}>{streak}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Streak</div>
            </div>
          </div>

          {currentQuestion && (
            <div style={styles.card}>
              <h3 style={{ textAlign: 'center', marginBottom: '20px', color: '#e2e8f0' }}>
                What type of 7th chord is this?
              </h3>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                {currentQuestion.choices.map((choice) => (
                  <button key={choice} onClick={() => handleGuess(choice)}
                    disabled={gameState !== 'playing'}
                    className="btn-press" style={{
                      ...styles.choiceBtn,
                      background: gameState === 'result' && choice === currentQuestion.answer
                        ? 'linear-gradient(135deg, #22c55e, #16a34a)'
                        : gameState === 'result' && lastResult && !lastResult.correct && choice !== currentQuestion.answer
                        ? 'rgba(255,255,255,0.05)'
                        : 'linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(168, 85, 247, 0.2))',
                    }}>
                    <div style={{ fontWeight: '700', marginBottom: '4px' }}>{SEVENTH_CHORD_TYPES[choice].name}</div>
                    <div style={{ fontSize: '0.75rem', color: '#94a3b8' }}>{SEVENTH_CHORD_TYPES[choice].symbol}</div>
                  </button>
                ))}
              </div>
            </div>
          )}

          {lastResult && (
            <div style={{
              ...styles.feedbackCard,
              background: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)',
            }}>
              <span style={{ fontSize: '1.1rem' }}>{lastResult.message}</span>
              {!lastResult.correct && currentQuestion && (
                <span style={{ fontSize: '0.85rem', color: '#94a3b8', marginTop: '4px' }}>
                  {SEVENTH_CHORD_TYPES[currentQuestion.answer].description}
                </span>
              )}
            </div>
          )}

          <div style={{ display: 'flex', gap: '12px' }}>
            {gameState === 'result' && (
              <button onClick={generateQuestion} className="btn-press floating-btn" style={{ ...styles.startBtn, flex: 1 }}>
                Next
              </button>
            )}
            <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
          </div>

          <FloatingPlayButton onClick={() => currentQuestion?.play()} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Melodic Dictation Game
    function MelodicDictation({ onBack }) {
      const { settings } = useSettings();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const { playSound } = useSoundEffects();
      const { addXP } = useXP();

      const [score, setScore] = useState(0);
      const [total, setTotal] = useState(0);
      const [melody, setMelody] = useState([]);
      const [userGuess, setUserGuess] = useState([]);
      const [gameState, setGameState] = useState('listening');
      const [difficulty, setDifficulty] = useState(3); // Number of notes

      const generateMelody = useCallback(() => {
        const notes = [];
        for (let i = 0; i < difficulty; i++) {
          const note = NATURAL_NOTES[Math.floor(Math.random() * NATURAL_NOTES.length)];
          notes.push(note);
        }
        setMelody(notes);
        setUserGuess([]);
        setGameState('listening');
        setTimeout(() => playMelody(notes), 500);
      }, [difficulty]);

      const playMelody = (notes) => {
        notes.forEach((note, i) => {
          setTimeout(() => audio.playNote(`${note}4`), i * 600);
        });
      };

      useEffect(() => {
        if (!audio.isLoading) generateMelody();
      }, [audio.isLoading, difficulty]);

      const handleNoteClick = (note) => {
        if (gameState !== 'guessing') return;
        const newGuess = [...userGuess, note];
        setUserGuess(newGuess);

        if (newGuess.length === melody.length) {
          const correct = newGuess.every((n, i) => n === melody[i]);
          setTotal(t => t + 1);
          if (correct) {
            playSound('success');
            setScore(s => s + 1);
            addXP(20 + difficulty * 5, 'melodic_dictation');
          } else {
            playSound('error');
          }
          setGameState(correct ? 'correct' : 'wrong');
        }
      };

      const startGuessing = () => setGameState('guessing');

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Melodic Dictation' }]} />
            <div style={{ ...styles.card, flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
              <div>Loading sounds...</div>
            </div>
          </div>
        );
      }

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Melodic Dictation' }]} />

          <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', padding: '8px', background: 'rgba(255,255,255,0.05)', borderRadius: '12px' }}>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{score}/{total}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Score</div>
            </div>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#a855f7' }}>{difficulty}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Notes</div>
            </div>
          </div>

          <div style={styles.card}>
            <h3 style={{ textAlign: 'center', marginBottom: '16px' }}>
              {gameState === 'listening' ? 'Listen carefully...' :
               gameState === 'guessing' ? `Enter ${melody.length} notes (${userGuess.length}/${melody.length})` :
               gameState === 'correct' ? 'âœ“ Perfect!' : `âœ— It was: ${melody.join(' â†’ ')}`}
            </h3>

            {gameState === 'guessing' && (
              <div style={{ display: 'flex', justifyContent: 'center', gap: '8px', marginBottom: '16px', flexWrap: 'wrap' }}>
                {userGuess.map((note, i) => (
                  <div key={i} style={{ padding: '8px 16px', background: 'rgba(168, 85, 247, 0.3)', borderRadius: '8px', fontWeight: '600' }}>
                    {note}
                  </div>
                ))}
              </div>
            )}

            {gameState === 'listening' && (
              <button onClick={startGuessing} className="btn-press floating-btn" style={{ ...styles.startBtn, width: '100%' }}>
                Ready to guess!
              </button>
            )}

            {gameState === 'guessing' && (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: '8px' }}>
                {NATURAL_NOTES.map(note => (
                  <button key={note} onClick={() => handleNoteClick(note)}
                    className="btn-press" style={{
                      padding: '16px 8px', borderRadius: '10px', border: 'none',
                      background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(139, 92, 246, 0.2))',
                      color: 'white', fontWeight: '700', fontSize: '1rem'
                    }}>
                    {note}
                  </button>
                ))}
              </div>
            )}

            {(gameState === 'correct' || gameState === 'wrong') && (
              <button onClick={generateMelody} className="btn-press floating-btn" style={{ ...styles.startBtn, width: '100%' }}>
                Next Melody
              </button>
            )}
          </div>

          <div style={{ display: 'flex', gap: '8px', justifyContent: 'center' }}>
            {[3, 4, 5, 6].map(d => (
              <button key={d} onClick={() => setDifficulty(d)}
                className="btn-press" style={{
                  padding: '8px 16px', borderRadius: '8px', border: 'none',
                  background: d === difficulty ? 'linear-gradient(135deg, #a855f7, #ec4899)' : 'rgba(255,255,255,0.1)',
                  color: 'white', fontWeight: '600'
                }}>
                {d} notes
              </button>
            ))}
          </div>

          <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
          <FloatingPlayButton onClick={() => playMelody(melody)} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Relative Pitch Game
    function RelativePitchGame({ onBack }) {
      const { settings } = useSettings();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const { playSound } = useSoundEffects();
      const { addXP } = useXP();

      const [score, setScore] = useState(0);
      const [total, setTotal] = useState(0);
      const [referenceNote, setReferenceNote] = useState('C');
      const [targetInterval, setTargetInterval] = useState(null);
      const [gameState, setGameState] = useState('playing');
      const [lastResult, setLastResult] = useState(null);

      const generateQuestion = useCallback(() => {
        const intervals = [2, 3, 4, 5, 7, 8, 9, 12];
        const interval = intervals[Math.floor(Math.random() * intervals.length)];
        setTargetInterval(interval);
        setGameState('playing');
        setLastResult(null);
        setTimeout(() => {
          audio.playNote(`${referenceNote}4`);
          setTimeout(() => {
            const refIdx = getNoteIndex(referenceNote);
            const targetIdx = (refIdx + interval) % 12;
            const targetOctave = refIdx + interval >= 12 ? 5 : 4;
            audio.playNote(`${NOTES[targetIdx]}${targetOctave}`);
          }, 800);
        }, 300);
      }, [referenceNote, audio]);

      useEffect(() => {
        if (!audio.isLoading) generateQuestion();
      }, [audio.isLoading, referenceNote]);

      const handleGuess = (guessedInterval) => {
        if (gameState !== 'playing') return;
        const correct = guessedInterval === targetInterval;
        setTotal(t => t + 1);

        if (correct) {
          playSound('success');
          setScore(s => s + 1);
          addXP(12, 'relative_pitch');
          setLastResult({ correct: true, message: 'âœ“ Correct!' });
        } else {
          playSound('error');
          setLastResult({ correct: false, message: `âœ— It was ${INTERVALS[targetInterval]?.name || targetInterval}` });
        }
        setGameState('result');
      };

      const intervalChoices = [2, 3, 4, 5, 7, 8, 9, 12];

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Relative Pitch' }]} />
            <div style={{ ...styles.card, flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
              <div>Loading sounds...</div>
            </div>
          </div>
        );
      }

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Relative Pitch' }]} />

          <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', padding: '8px', background: 'rgba(255,255,255,0.05)', borderRadius: '12px' }}>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{score}/{total}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Score</div>
            </div>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#3b82f6' }}>{referenceNote}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Reference</div>
            </div>
          </div>

          <div style={styles.card}>
            <h3 style={{ textAlign: 'center', marginBottom: '16px' }}>
              What interval from {referenceNote}?
            </h3>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '10px' }}>
              {intervalChoices.map(int => (
                <button key={int} onClick={() => handleGuess(int)}
                  disabled={gameState !== 'playing'}
                  className="btn-press" style={{
                    ...styles.choiceBtn,
                    background: gameState === 'result' && int === targetInterval
                      ? 'linear-gradient(135deg, #22c55e, #16a34a)'
                      : 'linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(139, 92, 246, 0.2))',
                  }}>
                  {INTERVALS[int]?.name || int}
                </button>
              ))}
            </div>
          </div>

          {lastResult && (
            <div style={{
              ...styles.feedbackCard,
              background: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)',
            }}>
              {lastResult.message}
            </div>
          )}

          <div style={{ display: 'flex', gap: '8px', justifyContent: 'center', flexWrap: 'wrap' }}>
            {['C', 'D', 'E', 'F', 'G', 'A', 'B'].map(note => (
              <button key={note} onClick={() => setReferenceNote(note)}
                className="btn-press" style={{
                  padding: '8px 12px', borderRadius: '8px', border: 'none',
                  background: note === referenceNote ? 'linear-gradient(135deg, #3b82f6, #8b5cf6)' : 'rgba(255,255,255,0.1)',
                  color: 'white', fontWeight: '600'
                }}>
                {note}
              </button>
            ))}
          </div>

          <div style={{ display: 'flex', gap: '12px' }}>
            {gameState === 'result' && (
              <button onClick={generateQuestion} className="btn-press floating-btn" style={{ ...styles.startBtn, flex: 1 }}>
                Next
              </button>
            )}
            <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
          </div>

          <FloatingPlayButton onClick={generateQuestion} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Tempo Trainer
    function TempoTrainer({ onBack }) {
      const { playSound } = useSoundEffects();
      const { addXP } = useXP();
      const [score, setScore] = useState(0);
      const [total, setTotal] = useState(0);
      const [currentTempo, setCurrentTempo] = useState(null);
      const [gameState, setGameState] = useState('ready');
      const [lastResult, setLastResult] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const intervalRef = useRef(null);

      const generateTempo = useCallback(() => {
        const tempo = Math.floor(Math.random() * 140) + 60; // 60-200 BPM
        setCurrentTempo(tempo);
        setGameState('listening');
        setLastResult(null);
        playBeat(tempo);
      }, []);

      const playBeat = (bpm) => {
        if (intervalRef.current) clearInterval(intervalRef.current);
        setIsPlaying(true);
        const interval = 60000 / bpm;
        let count = 0;
        const maxBeats = 8;

        const tick = () => {
          playSound('click');
          count++;
          if (count >= maxBeats) {
            clearInterval(intervalRef.current);
            setIsPlaying(false);
            setGameState('guessing');
          }
        };

        tick();
        intervalRef.current = setInterval(tick, interval);
      };

      useEffect(() => {
        return () => {
          if (intervalRef.current) clearInterval(intervalRef.current);
        };
      }, []);

      const handleGuess = (guessedBpm) => {
        if (gameState !== 'guessing') return;
        const diff = Math.abs(guessedBpm - currentTempo);
        const correct = diff <= 10;
        setTotal(t => t + 1);

        if (correct) {
          playSound('success');
          setScore(s => s + 1);
          addXP(15, 'tempo_trainer');
          setLastResult({ correct: true, message: `âœ“ Correct! It was ${currentTempo} BPM` });
        } else {
          playSound('error');
          setLastResult({ correct: false, message: `âœ— It was ${currentTempo} BPM (you guessed ${guessedBpm})` });
        }
        setGameState('result');
      };

      const tempoChoices = currentTempo ? [
        Math.max(60, currentTempo - 30),
        Math.max(60, currentTempo - 15),
        currentTempo,
        Math.min(200, currentTempo + 15),
        Math.min(200, currentTempo + 30),
      ].sort(() => Math.random() - 0.5).slice(0, 4) : [];

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Tempo Trainer' }]} />

          <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', padding: '8px', background: 'rgba(255,255,255,0.05)', borderRadius: '12px' }}>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{score}/{total}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Score</div>
            </div>
          </div>

          <div style={styles.card}>
            <h3 style={{ textAlign: 'center', marginBottom: '16px' }}>
              {gameState === 'ready' ? 'Ready to test your tempo sense?' :
               gameState === 'listening' ? 'Listen to the beat...' :
               gameState === 'guessing' ? 'What was the tempo?' :
               lastResult?.correct ? 'âœ“ Great ear!' : 'âœ— Keep practicing!'}
            </h3>

            {isPlaying && (
              <div style={{ textAlign: 'center', marginBottom: '16px' }}>
                <div style={{ fontSize: '3rem', animation: 'pulse 0.5s ease-in-out infinite' }}>ðŸ¥</div>
              </div>
            )}

            {gameState === 'ready' && (
              <button onClick={generateTempo} className="btn-press floating-btn" style={{ ...styles.startBtn, width: '100%' }}>
                Start
              </button>
            )}

            {gameState === 'guessing' && (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '10px' }}>
                {tempoChoices.map(bpm => (
                  <button key={bpm} onClick={() => handleGuess(bpm)}
                    className="btn-press" style={{
                      ...styles.choiceBtn,
                      background: 'linear-gradient(135deg, rgba(249, 115, 22, 0.3), rgba(236, 72, 153, 0.2))',
                    }}>
                    {bpm} BPM
                  </button>
                ))}
              </div>
            )}

            {gameState === 'result' && (
              <button onClick={generateTempo} className="btn-press floating-btn" style={{ ...styles.startBtn, width: '100%' }}>
                Next
              </button>
            )}
          </div>

          {lastResult && (
            <div style={{
              ...styles.feedbackCard,
              background: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)',
            }}>
              {lastResult.message}
            </div>
          )}

          <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
        </div>
      );
    }

    // Time Signature Quiz
    function TimeSignatureQuiz({ onBack }) {
      const { playSound } = useSoundEffects();
      const { addXP } = useXP();
      const [score, setScore] = useState(0);
      const [total, setTotal] = useState(0);
      const [currentSig, setCurrentSig] = useState(null);
      const [gameState, setGameState] = useState('ready');
      const [lastResult, setLastResult] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const intervalRef = useRef(null);

      const generateQuestion = useCallback(() => {
        const sigs = Object.keys(TIME_SIGNATURES);
        const sig = sigs[Math.floor(Math.random() * sigs.length)];
        setCurrentSig(sig);
        setGameState('listening');
        setLastResult(null);
        playPattern(sig);
      }, []);

      const playPattern = (sig) => {
        if (intervalRef.current) clearInterval(intervalRef.current);
        setIsPlaying(true);
        const timeSig = TIME_SIGNATURES[sig];
        const bpm = 120;
        const beatDuration = 60000 / bpm;
        let beat = 0;
        const measures = 2;
        const totalBeats = timeSig.beats * measures;

        const tick = () => {
          const patternIdx = beat % timeSig.beats;
          const emphasis = timeSig.pattern[patternIdx];
          if (emphasis > 0) {
            playSound(emphasis === 1 ? 'click' : 'tick');
          }
          beat++;
          if (beat >= totalBeats) {
            clearInterval(intervalRef.current);
            setIsPlaying(false);
            setGameState('guessing');
          }
        };

        tick();
        intervalRef.current = setInterval(tick, beatDuration);
      };

      useEffect(() => {
        return () => {
          if (intervalRef.current) clearInterval(intervalRef.current);
        };
      }, []);

      const handleGuess = (guess) => {
        if (gameState !== 'guessing') return;
        const correct = guess === currentSig;
        setTotal(t => t + 1);

        if (correct) {
          playSound('success');
          setScore(s => s + 1);
          addXP(18, 'time_signature');
          setLastResult({ correct: true, message: 'âœ“ Correct!' });
        } else {
          playSound('error');
          setLastResult({ correct: false, message: `âœ— It was ${TIME_SIGNATURES[currentSig].name}` });
        }
        setGameState('result');
      };

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: 'Time Signatures' }]} />

          <div style={{ display: 'flex', justifyContent: 'center', gap: '24px', padding: '8px', background: 'rgba(255,255,255,0.05)', borderRadius: '12px' }}>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '1.5rem', fontWeight: '700', color: '#22c55e' }}>{score}/{total}</div>
              <div style={{ fontSize: '0.7rem', color: '#64748b' }}>Score</div>
            </div>
          </div>

          <div style={styles.card}>
            <h3 style={{ textAlign: 'center', marginBottom: '16px' }}>
              {gameState === 'ready' ? 'Identify the time signature!' :
               gameState === 'listening' ? 'Listen carefully...' :
               gameState === 'guessing' ? 'What time signature was that?' :
               lastResult?.correct ? 'âœ“ Perfect!' : 'âœ— Keep practicing!'}
            </h3>

            {isPlaying && (
              <div style={{ textAlign: 'center', marginBottom: '16px' }}>
                <div style={{ fontSize: '3rem', animation: 'pulse 0.5s ease-in-out infinite' }}>ðŸŽµ</div>
              </div>
            )}

            {gameState === 'ready' && (
              <button onClick={generateQuestion} className="btn-press floating-btn" style={{ ...styles.startBtn, width: '100%' }}>
                Start
              </button>
            )}

            {gameState === 'guessing' && (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '10px' }}>
                {Object.keys(TIME_SIGNATURES).map(sig => (
                  <button key={sig} onClick={() => handleGuess(sig)}
                    className="btn-press" style={{
                      ...styles.choiceBtn,
                      background: gameState === 'result' && sig === currentSig
                        ? 'linear-gradient(135deg, #22c55e, #16a34a)'
                        : 'linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.2))',
                    }}>
                    <div style={{ fontWeight: '700', fontSize: '1.2rem' }}>{sig}</div>
                  </button>
                ))}
              </div>
            )}

            {gameState === 'result' && (
              <button onClick={generateQuestion} className="btn-press floating-btn" style={{ ...styles.startBtn, width: '100%' }}>
                Next
              </button>
            )}
          </div>

          {lastResult && (
            <div style={{
              ...styles.feedbackCard,
              background: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)',
            }}>
              {lastResult.message}
            </div>
          )}

          <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
        </div>
      );
    }

    // Interactive Circle of Fifths Component
    function CircleOfFifths({ onBack }) {
      const { settings } = useSettings();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const [selectedKey, setSelectedKey] = useState(null);
      const [showMinor, setShowMinor] = useState(false);

      const playScale = (root, isMinor = false) => {
        const rootIdx = getNoteIndex(root.replace(/[#b]/g, match => match === '#' ? 'â™¯' : 'â™­').charAt(0));
        const scaleType = isMinor ? SCALE_TYPES.natural_minor : SCALE_TYPES.major;
        const notes = scaleType.intervals.map(interval => {
          const noteIdx = (rootIdx + interval) % 12;
          const octave = rootIdx + interval >= 12 ? 5 : 4;
          return `${NOTES[noteIdx]}${octave}`;
        });
        notes.forEach((note, i) => setTimeout(() => audio.playNote(note), i * 200));
      };

      const playChord = (root, isMinor = false) => {
        const rootIdx = getNoteIndex(root.replace(/[#b]/g, '').charAt(0));
        const chordType = isMinor ? CHORD_TYPES.minor : CHORD_TYPES.major;
        const notes = chordType.intervals.map(interval => {
          const noteIdx = (rootIdx + interval) % 12;
          return `${NOTES[noteIdx]}4`;
        });
        audio.playNotes(notes);
      };

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Learn', onClick: onBack }, { label: 'Circle of Fifths' }]} />

          <div style={{ display: 'flex', justifyContent: 'center', gap: '12px', marginBottom: '8px' }}>
            <button onClick={() => setShowMinor(false)} className="btn-press"
              style={{ padding: '8px 16px', borderRadius: '8px', border: 'none', background: !showMinor ? 'linear-gradient(135deg, #3b82f6, #8b5cf6)' : 'rgba(255,255,255,0.1)', color: 'white', fontWeight: '600' }}>
              Major Keys
            </button>
            <button onClick={() => setShowMinor(true)} className="btn-press"
              style={{ padding: '8px 16px', borderRadius: '8px', border: 'none', background: showMinor ? 'linear-gradient(135deg, #ec4899, #a855f7)' : 'rgba(255,255,255,0.1)', color: 'white', fontWeight: '600' }}>
              Minor Keys
            </button>
          </div>

          <div style={{ ...styles.card, position: 'relative', aspectRatio: '1', maxWidth: '350px', margin: '0 auto', borderRadius: '50%' }}>
            <svg viewBox="0 0 200 200" style={{ width: '100%', height: '100%' }}>
              {CIRCLE_OF_FIFTHS.map((key, i) => {
                const angle = (i * 30 - 90) * (Math.PI / 180);
                const x = 100 + 75 * Math.cos(angle);
                const y = 100 + 75 * Math.sin(angle);
                const keyName = showMinor ? key.minor : key.major;
                const isSelected = selectedKey === keyName;

                return (
                  <g key={i} onClick={() => { setSelectedKey(keyName); playChord(keyName.split('/')[0], showMinor); }}
                    style={{ cursor: 'pointer' }}>
                    <circle cx={x} cy={y} r="22"
                      fill={isSelected ? (showMinor ? '#ec4899' : '#3b82f6') : 'rgba(255,255,255,0.1)'}
                      stroke={isSelected ? 'white' : 'rgba(255,255,255,0.3)'} strokeWidth="2" />
                    <text x={x} y={y} textAnchor="middle" dominantBaseline="middle"
                      fill="white" fontSize="12" fontWeight="600">
                      {keyName.length > 4 ? keyName.split('/')[0] : keyName}
                    </text>
                  </g>
                );
              })}
              <circle cx="100" cy="100" r="35" fill="rgba(255,255,255,0.05)" stroke="rgba(255,255,255,0.2)" strokeWidth="1" />
              <text x="100" y="95" textAnchor="middle" fill="#94a3b8" fontSize="10">Circle of</text>
              <text x="100" y="110" textAnchor="middle" fill="white" fontSize="12" fontWeight="600">Fifths</text>
            </svg>
          </div>

          {selectedKey && (
            <div style={styles.card}>
              <h3 style={{ textAlign: 'center', marginBottom: '12px' }}>{selectedKey} {showMinor ? 'Minor' : 'Major'}</h3>
              <div style={{ display: 'flex', justifyContent: 'center', gap: '12px' }}>
                <button onClick={() => playScale(selectedKey.split('/')[0], showMinor)} className="btn-press"
                  style={{ padding: '10px 20px', borderRadius: '10px', border: 'none', background: 'linear-gradient(135deg, #22c55e, #10b981)', color: 'white', fontWeight: '600' }}>
                  Play Scale
                </button>
                <button onClick={() => playChord(selectedKey.split('/')[0], showMinor)} className="btn-press"
                  style={{ padding: '10px 20px', borderRadius: '10px', border: 'none', background: 'linear-gradient(135deg, #f59e0b, #f97316)', color: 'white', fontWeight: '600' }}>
                  Play Chord
                </button>
              </div>
              <div style={{ marginTop: '12px', textAlign: 'center', color: '#94a3b8', fontSize: '0.85rem' }}>
                {CIRCLE_OF_FIFTHS.find(k => (showMinor ? k.minor : k.major) === selectedKey)?.sharps > 0 &&
                  `${CIRCLE_OF_FIFTHS.find(k => (showMinor ? k.minor : k.major) === selectedKey).sharps} sharp(s)`}
                {CIRCLE_OF_FIFTHS.find(k => (showMinor ? k.minor : k.major) === selectedKey)?.flats > 0 &&
                  `${CIRCLE_OF_FIFTHS.find(k => (showMinor ? k.minor : k.major) === selectedKey).flats} flat(s)`}
                {CIRCLE_OF_FIFTHS.find(k => (showMinor ? k.minor : k.major) === selectedKey)?.sharps === 0 &&
                  CIRCLE_OF_FIFTHS.find(k => (showMinor ? k.minor : k.major) === selectedKey)?.flats === 0 && 'No sharps or flats'}
              </div>
            </div>
          )}

          <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Back</button>
        </div>
      );
    }

    // Reference Library Component
    function ReferenceLibrary({ onBack }) {
      const { settings } = useSettings();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const [activeTab, setActiveTab] = useState('intervals');

      const playInterval = (semitones) => {
        const baseNote = 'C4';
        const baseIdx = getNoteIndex('C');
        const secondIdx = (baseIdx + semitones) % 12;
        const secondOctave = semitones >= 12 ? 5 : 4;
        audio.playNote(baseNote);
        setTimeout(() => audio.playNote(`${NOTES[secondIdx]}${secondOctave}`), 500);
      };

      const playChord = (chordType) => {
        const chord = CHORD_TYPES[chordType];
        const notes = chord.intervals.map(i => `${NOTES[i % 12]}${i >= 12 ? 5 : 4}`);
        audio.playNotes(notes);
      };

      const playScale = (scaleType) => {
        const scale = SCALE_TYPES[scaleType];
        scale.intervals.forEach((interval, i) => {
          setTimeout(() => audio.playNote(`${NOTES[interval % 12]}${interval >= 12 ? 5 : 4}`), i * 250);
        });
      };

      const tabs = ['intervals', 'chords', 'scales'];

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Learn', onClick: onBack }, { label: 'Reference' }]} />

          <div style={{ display: 'flex', gap: '8px', justifyContent: 'center' }}>
            {tabs.map(tab => (
              <button key={tab} onClick={() => setActiveTab(tab)} className="btn-press"
                style={{
                  padding: '10px 20px', borderRadius: '10px', border: 'none',
                  background: activeTab === tab ? 'linear-gradient(135deg, #a855f7, #ec4899)' : 'rgba(255,255,255,0.1)',
                  color: 'white', fontWeight: '600', textTransform: 'capitalize'
                }}>
                {tab}
              </button>
            ))}
          </div>

          <div style={{ ...styles.card, maxHeight: '400px', overflowY: 'auto' }}>
            {activeTab === 'intervals' && (
              <div style={{ display: 'grid', gap: '8px' }}>
                {Object.entries(INTERVALS).map(([semitones, interval]) => (
                  <button key={semitones} onClick={() => playInterval(parseInt(semitones))} className="btn-press card-lift"
                    style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '12px 16px', background: 'rgba(255,255,255,0.05)', borderRadius: '10px', border: 'none', color: 'white', textAlign: 'left' }}>
                    <div>
                      <div style={{ fontWeight: '600' }}>{interval.name}</div>
                      <div style={{ fontSize: '0.75rem', color: '#64748b' }}>{interval.short} Â· {semitones} semitones</div>
                    </div>
                    <span>â–¶</span>
                  </button>
                ))}
              </div>
            )}

            {activeTab === 'chords' && (
              <div style={{ display: 'grid', gap: '8px' }}>
                {Object.entries(CHORD_TYPES).map(([key, chord]) => (
                  <button key={key} onClick={() => playChord(key)} className="btn-press card-lift"
                    style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '12px 16px', background: 'rgba(255,255,255,0.05)', borderRadius: '10px', border: 'none', color: 'white', textAlign: 'left' }}>
                    <div>
                      <div style={{ fontWeight: '600' }}>{chord.name}</div>
                      <div style={{ fontSize: '0.75rem', color: '#64748b' }}>C{chord.symbol}</div>
                    </div>
                    <span>â–¶</span>
                  </button>
                ))}
              </div>
            )}

            {activeTab === 'scales' && (
              <div style={{ display: 'grid', gap: '8px' }}>
                {Object.entries(SCALE_TYPES).map(([key, scale]) => (
                  <button key={key} onClick={() => playScale(key)} className="btn-press card-lift"
                    style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '12px 16px', background: 'rgba(255,255,255,0.05)', borderRadius: '10px', border: 'none', color: 'white', textAlign: 'left' }}>
                    <div>
                      <div style={{ fontWeight: '600' }}>{scale.name}</div>
                      <div style={{ fontSize: '0.75rem', color: '#64748b' }}>{scale.description}</div>
                    </div>
                    <span>â–¶</span>
                  </button>
                ))}
              </div>
            )}
          </div>

          <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Back</button>
        </div>
      );
    }

    // XP Display Card Component
    function XPDisplayCard() {
      const { xpData, getCurrentLevel, getNextLevel, getProgress } = useXP();
      const currentLevel = getCurrentLevel();
      const nextLevel = getNextLevel();
      const progress = getProgress();

      return (
        <div style={{ ...styles.card, background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.15), rgba(139, 92, 246, 0.1))', border: '1px solid rgba(168, 85, 247, 0.3)', marginBottom: '16px' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
            <div style={{ width: '60px', height: '60px', borderRadius: '50%', background: currentLevel.color.includes('gradient') ? currentLevel.color : `linear-gradient(135deg, ${currentLevel.color}, ${currentLevel.color}88)`, display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1.5rem', fontWeight: '700', border: '3px solid rgba(255,255,255,0.3)' }}>
              {currentLevel.level}
            </div>
            <div style={{ flex: 1 }}>
              <div style={{ fontWeight: '700', fontSize: '1.1rem', marginBottom: '4px' }}>{currentLevel.title}</div>
              <div style={{ fontSize: '0.8rem', color: '#94a3b8', marginBottom: '8px' }}>{xpData.totalXP} XP</div>
              {nextLevel && (
                <div>
                  <div style={{ height: '8px', background: 'rgba(255,255,255,0.1)', borderRadius: '4px', overflow: 'hidden' }}>
                    <div style={{ height: '100%', width: `${progress}%`, background: 'linear-gradient(90deg, #a855f7, #ec4899)', borderRadius: '4px', transition: 'width 0.3s' }} />
                  </div>
                  <div style={{ fontSize: '0.7rem', color: '#64748b', marginTop: '4px' }}>{nextLevel.xpRequired - xpData.totalXP} XP to {nextLevel.title}</div>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    // Weekly Challenges Card
    function WeeklyChallengesCard() {
      const { challengeData, generateChallenges } = useWeeklyChallenge();
      const [challenges, setChallenges] = useState([]);

      useEffect(() => {
        setChallenges(generateChallenges());
      }, []);

      if (challenges.length === 0) return null;

      return (
        <div style={{ ...styles.card, marginBottom: '16px' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
            <div style={styles.statsTitle}>Weekly Challenges</div>
            <span style={{ fontSize: '0.75rem', color: '#64748b' }}>
              {challengeData.completed.length}/{challenges.length} complete
            </span>
          </div>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            {challenges.map(c => {
              const progress = challengeData.progress[c.id] || 0;
              const isComplete = challengeData.completed.includes(c.id);
              const percent = Math.min(100, Math.round((progress / c.target) * 100));
              return (
                <div key={c.id} style={{
                  padding: '12px', background: isComplete ? 'rgba(34, 197, 94, 0.15)' : 'rgba(255,255,255,0.05)',
                  borderRadius: '10px', border: isComplete ? '1px solid rgba(34, 197, 94, 0.3)' : '1px solid rgba(255,255,255,0.1)'
                }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <span>{c.icon}</span>
                      <span style={{ fontWeight: '600', fontSize: '0.9rem' }}>{c.name}</span>
                    </div>
                    <span style={{ fontSize: '0.75rem', color: '#fbbf24' }}>+{c.reward} XP</span>
                  </div>
                  <div style={{ fontSize: '0.8rem', color: '#94a3b8', marginBottom: '8px' }}>{c.description}</div>
                  <div style={{ height: '6px', background: 'rgba(255,255,255,0.1)', borderRadius: '3px', overflow: 'hidden' }}>
                    <div style={{ height: '100%', width: `${percent}%`, background: isComplete ? '#22c55e' : 'linear-gradient(90deg, #3b82f6, #8b5cf6)', borderRadius: '3px' }} />
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // Theme Selector Component
    function ThemeSelector() {
      const { theme, setTheme, availableThemes } = useTheme();

      return (
        <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
          {availableThemes.map(t => (
            <button key={t} onClick={() => setTheme(t)} className="btn-press"
              style={{
                padding: '12px 16px', borderRadius: '10px', border: theme === t ? '2px solid white' : '2px solid transparent',
                background: THEMES[t].background, color: THEMES[t].text, fontWeight: '600', minWidth: '80px'
              }}>
              {THEMES[t].name}
            </button>
          ))}
        </div>
      );
    }

    // Focus Mode Game
    function FocusModeGame({ mode, difficulty, onBack }) {
      const { settings } = useSettings();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);

      // Minimal UI version of the game
      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', background: '#0a0a0f', minHeight: '100vh', padding: '20px' }} className="page-enter">
          <div style={{ textAlign: 'center', marginBottom: '40px' }}>
            <h2 style={{ color: '#e2e8f0', marginBottom: '8px' }}>Focus Mode</h2>
            <p style={{ color: '#64748b', fontSize: '0.85rem' }}>Distraction-free practice</p>
          </div>

          <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <div style={{ textAlign: 'center' }}>
              <div style={{ fontSize: '4rem', marginBottom: '20px' }}>ðŸŽ§</div>
              <p style={{ color: '#94a3b8', marginBottom: '30px' }}>Coming soon: Minimal practice interface</p>
              <button onClick={onBack} className="btn-press"
                style={{ padding: '16px 40px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, #a855f7, #ec4899)', color: 'white', fontWeight: '700', fontSize: '1rem' }}>
                Exit Focus Mode
              </button>
            </div>
          </div>
        </div>
      );
    }

    // Wordle-style Share Score Component
    function ShareScoreCard({ score, total, mode, streak }) {
      const [copied, setCopied] = useState(false);

      const generateShareText = () => {
        const accuracy = total > 0 ? Math.round((score / total) * 100) : 0;
        const blocks = [];
        const correctBlocks = Math.round((score / Math.max(total, 1)) * 5);
        for (let i = 0; i < 5; i++) {
          blocks.push(i < correctBlocks ? 'ðŸŸ©' : 'â¬›');
        }

        return `ðŸŽµ KeyPerfect ${mode}
${blocks.join('')} ${accuracy}%
${score}/${total} correct
ðŸ”¥ ${streak} streak

Play at keyperfect.app`;
      };

      const handleShare = async () => {
        const text = generateShareText();
        try {
          if (navigator.share) {
            await navigator.share({ text });
          } else {
            await navigator.clipboard.writeText(text);
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
          }
        } catch (err) {}
      };

      return (
        <button onClick={handleShare} className="btn-press"
          style={{ padding: '12px 24px', borderRadius: '10px', border: 'none', background: 'linear-gradient(135deg, #22c55e, #10b981)', color: 'white', fontWeight: '600', display: 'flex', alignItems: 'center', gap: '8px' }}>
          {copied ? 'âœ“ Copied!' : 'ðŸ“¤ Share Score'}
        </button>
      );
    }

    // Challenge Friend Component
    function ChallengeFriendCard({ score, mode, seed }) {
      const [copied, setCopied] = useState(false);

      const generateChallengeLink = () => {
        const baseUrl = window.location.origin;
        return `${baseUrl}?challenge=${mode}&seed=${seed}&score=${score}`;
      };

      const handleChallenge = async () => {
        const link = generateChallengeLink();
        const text = `ðŸŽµ I scored ${score} in KeyPerfect ${mode}! Can you beat me?\n${link}`;
        try {
          if (navigator.share) {
            await navigator.share({ text });
          } else {
            await navigator.clipboard.writeText(text);
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
          }
        } catch (err) {}
      };

      return (
        <button onClick={handleChallenge} className="btn-press"
          style={{ padding: '12px 24px', borderRadius: '10px', border: 'none', background: 'linear-gradient(135deg, #f59e0b, #f97316)', color: 'white', fontWeight: '600', display: 'flex', alignItems: 'center', gap: '8px' }}>
          {copied ? 'âœ“ Copied!' : 'ðŸŽ¯ Challenge Friend'}
        </button>
      );
    }

    // Practice Heatmap Component
    function PracticeHeatmap() {
      const { heatmapData, getLast12Weeks } = usePracticeHeatmap();
      const weeks = getLast12Weeks();

      const getColor = (count) => {
        if (count === 0) return 'rgba(255,255,255,0.05)';
        if (count < 5) return 'rgba(34, 197, 94, 0.3)';
        if (count < 15) return 'rgba(34, 197, 94, 0.5)';
        if (count < 30) return 'rgba(34, 197, 94, 0.7)';
        return 'rgba(34, 197, 94, 0.9)';
      };

      return (
        <div style={{ ...styles.statsCard }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
            <div style={styles.statsTitle}>Practice Activity</div>
            <div style={{ display: 'flex', gap: '16px', fontSize: '0.8rem' }}>
              <span style={{ color: '#22c55e' }}>ðŸ”¥ {heatmapData.currentStreak} day streak</span>
              <span style={{ color: '#64748b' }}>Best: {heatmapData.longestStreak}</span>
            </div>
          </div>
          <div style={{ display: 'flex', gap: '3px', overflowX: 'auto', paddingBottom: '8px' }}>
            {weeks.map((week, wi) => (
              <div key={wi} style={{ display: 'flex', flexDirection: 'column', gap: '3px' }}>
                {week.map((day, di) => (
                  <div key={di} title={`${day.date}: ${day.count} questions`}
                    style={{
                      width: '12px', height: '12px', borderRadius: '2px',
                      background: getColor(day.count),
                      cursor: 'default'
                    }} />
                ))}
              </div>
            ))}
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '8px', fontSize: '0.7rem', color: '#64748b' }}>
            <span>12 weeks ago</span>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <span>Less</span>
              {[0, 5, 15, 30, 50].map(n => (
                <div key={n} style={{ width: '10px', height: '10px', borderRadius: '2px', background: getColor(n) }} />
              ))}
              <span>More</span>
            </div>
            <span>Today</span>
          </div>
        </div>
      );
    }

    // Daily Quests Component
    function DailyQuestsCard() {
      const { quests, questData } = useDailyQuests();
      const completedCount = quests.filter(q => q.completed).length;

      return (
        <div style={{ ...styles.card, marginBottom: '16px' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <span style={{ fontSize: '1.2rem' }}>ðŸ“‹</span>
              <span style={{ fontWeight: '700' }}>Daily Quests</span>
            </div>
            <span style={{ fontSize: '0.85rem', color: completedCount === 3 ? '#22c55e' : '#94a3b8' }}>
              {completedCount}/3 Complete
            </span>
          </div>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {quests.map((quest, i) => (
              <div key={i} className={quest.completed ? 'quest-complete' : ''}
                style={{
                  display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                  padding: '12px', borderRadius: '10px',
                  background: quest.completed ? 'rgba(34, 197, 94, 0.2)' : 'rgba(251, 191, 36, 0.1)',
                  border: `1px solid ${quest.completed ? 'rgba(34, 197, 94, 0.3)' : 'rgba(251, 191, 36, 0.2)'}`
                }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '1.2rem' }}>{quest.icon}</span>
                  <div>
                    <div style={{ fontWeight: '500', fontSize: '0.9rem', color: quest.completed ? '#22c55e' : 'white' }}>
                      {quest.description}
                    </div>
                    <div style={{ fontSize: '0.75rem', color: '#64748b' }}>
                      Progress: {Math.min(quest.progress, quest.target)}/{quest.target}
                    </div>
                  </div>
                </div>
                {quest.completed ? (
                  <span style={{ fontSize: '1.2rem' }}>âœ…</span>
                ) : (
                  <div style={{
                    width: '40px', height: '40px', borderRadius: '50%',
                    background: `conic-gradient(#fbbf24 ${(quest.progress / quest.target) * 360}deg, rgba(255,255,255,0.1) 0deg)`,
                    display: 'flex', alignItems: 'center', justifyContent: 'center'
                  }}>
                    <div style={{ width: '32px', height: '32px', borderRadius: '50%', background: '#1a1a2e', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.7rem', fontWeight: '600' }}>
                      {Math.round((quest.progress / quest.target) * 100)}%
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      );
    }

    // ============================================
    // MAIN APP
    // ============================================

    function App() {
      const [view, setView] = useState('play');
      const [gameMode, setGameMode] = useState(null);
      const [gameDifficulty, setGameDifficulty] = useState(null);
      const [specialMode, setSpecialMode] = useState(null);
      const [learnMode, setLearnMode] = useState(null);

      const handleStartGame = (mode, difficulty) => { setGameMode(mode); setGameDifficulty(difficulty); setSpecialMode(null); };
      const handleStartDaily = () => { setGameMode('daily'); setSpecialMode('daily'); };
      const handleStartSpeedRun = () => { setGameMode('speedrun'); setSpecialMode('speedrun'); };
      const handleStartSurvival = () => { setGameMode('survival'); setSpecialMode('survival'); };
      const handleStartInversions = () => { setGameMode('inversions'); setSpecialMode('inversions'); };
      const handleStartSeventhChords = () => { setGameMode('seventh'); setSpecialMode('seventh'); };
      const handleStartMelodicDictation = () => { setGameMode('melodic'); setSpecialMode('melodic'); };
      const handleStartRelativePitch = () => { setGameMode('relative'); setSpecialMode('relative'); };
      const handleStartTempo = () => { setGameMode('tempo'); setSpecialMode('tempo'); };
      const handleStartTimeSignature = () => { setGameMode('timesig'); setSpecialMode('timesig'); };
      const handleBackToMenu = () => { setGameMode(null); setGameDifficulty(null); setSpecialMode(null); setLearnMode(null); };
      const handleTitleClick = () => { setView('play'); handleBackToMenu(); };

      const renderGameView = () => {
        if (!gameMode) return <MainMenu
          onStartGame={handleStartGame}
          onStartDaily={handleStartDaily}
          onStartSpeedRun={handleStartSpeedRun}
          onStartSurvival={handleStartSurvival}
          onStartInversions={handleStartInversions}
          onStartSeventhChords={handleStartSeventhChords}
          onStartMelodicDictation={handleStartMelodicDictation}
          onStartRelativePitch={handleStartRelativePitch}
          onStartTempo={handleStartTempo}
          onStartTimeSignature={handleStartTimeSignature}
        />;
        if (specialMode === 'daily') return <DailyChallenge onBack={handleBackToMenu} />;
        if (specialMode === 'speedrun') return <SpeedRun onBack={handleBackToMenu} />;
        if (specialMode === 'survival') return <SurvivalMode onBack={handleBackToMenu} />;
        if (specialMode === 'inversions') return <ChordInversionsGame onBack={handleBackToMenu} />;
        if (specialMode === 'seventh') return <SeventhChordsGame onBack={handleBackToMenu} />;
        if (specialMode === 'melodic') return <MelodicDictation onBack={handleBackToMenu} />;
        if (specialMode === 'relative') return <RelativePitchGame onBack={handleBackToMenu} />;
        if (specialMode === 'tempo') return <TempoTrainer onBack={handleBackToMenu} />;
        if (specialMode === 'timesig') return <TimeSignatureQuiz onBack={handleBackToMenu} />;
        const games = { notes: NoteGame, intervals: IntervalGame, chords: ChordGame, scales: ScaleGame, progressions: ProgressionGame };
        const GameComp = games[gameMode];
        return <GameComp difficulty={gameDifficulty} onBack={handleBackToMenu} />;
      };

      const renderLearnView = () => {
        if (learnMode === 'circle') return <CircleOfFifths onBack={() => setLearnMode(null)} />;
        if (learnMode === 'reference') return <ReferenceLibrary onBack={() => setLearnMode(null)} />;
        return <LearnView onCircleOfFifths={() => setLearnMode('circle')} onReferenceLibrary={() => setLearnMode('reference')} />;
      };

      return (
        <div style={styles.container}>
          <header style={styles.header}>
            <h1 style={styles.title} onClick={handleTitleClick}>KeyPerfect</h1>
            <p style={styles.subtitle}>Train your musical ear</p>
          </header>

          {view === 'play' && renderGameView()}
          {view === 'learn' && !gameMode && renderLearnView()}
          {view === 'stats' && !gameMode && <StatsView />}
          {view === 'settings' && !gameMode && <SettingsView />}

          {!gameMode && !learnMode && <BottomNav currentView={view} setView={setView} />}
        </div>
      );
    }

    // ============================================
    // RENDER
    // ============================================

    ReactDOM.render(
      <SettingsProvider>
        <StatsProvider>
          <SessionStatsProvider>
            <ToastProvider>
              <App />
            </ToastProvider>
          </SessionStatsProvider>
        </StatsProvider>
      </SettingsProvider>,
      document.getElementById('root')
    );
  </script>
</body>
</html>
