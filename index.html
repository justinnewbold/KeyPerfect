<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>KeyPerfect - Music Ear Training</title>
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <script src="https://unpkg.com/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Animated gradient background */
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(-45deg, #0f0c29, #302b63, #24243e, #0f0c29);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      min-height: 100vh;
      color: white;
      overflow-x: hidden;
    }
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #root { min-height: 100vh; }
    select option { background: #1a1a2e; color: white; }

    /* Glassmorphism base */
    .glass {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    /* Button with ripple effect */
    .btn-press {
      position: relative;
      overflow: hidden;
      transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.15s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .btn-press:active {
      transform: scale(0.97);
    }
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.4);
      transform: scale(0);
      animation: rippleEffect 0.6s linear;
      pointer-events: none;
    }
    @keyframes rippleEffect {
      to { transform: scale(4); opacity: 0; }
    }

    /* Prevent text selection on buttons */
    button, .btn-press {
      -webkit-user-select: none;
      user-select: none;
    }

    /* Enhanced skeleton loading */
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.05) 25%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.05) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 16px;
    }

    /* Toast animations */
    @keyframes slideIn {
      from { transform: translateY(-100%) scale(0.8); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateY(0) scale(1); opacity: 1; }
      to { transform: translateY(-100%) scale(0.8); opacity: 0; }
    }
    .toast-enter { animation: slideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; }
    .toast-exit { animation: slideOut 0.3s ease forwards; }

    /* Page transitions */
    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .page-enter {
      animation: fadeSlideIn 0.4s ease forwards;
    }

    /* Swipe container */
    .swipe-container {
      overflow: hidden;
      touch-action: pan-y;
    }

    /* Floating button pulse */
    @keyframes pulse {
      0%, 100% { box-shadow: 0 8px 30px rgba(139, 92, 246, 0.5), 0 0 0 0 rgba(139, 92, 246, 0.4); }
      50% { box-shadow: 0 12px 40px rgba(139, 92, 246, 0.7), 0 0 0 10px rgba(139, 92, 246, 0); }
    }
    .floating-btn {
      animation: pulse 2s ease-in-out infinite;
    }

    /* Confetti animation */
    @keyframes confettiFall {
      0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      top: -10px;
      animation: confettiFall 3s linear forwards;
      z-index: 9999;
      pointer-events: none;
    }

    /* Shake animation for wrong answers */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake {
      animation: shake 0.5s ease-in-out;
    }

    /* Success checkmark animation */
    @keyframes successPop {
      0% { transform: scale(0) rotate(-45deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(-45deg); }
      100% { transform: scale(1) rotate(-45deg); opacity: 1; }
    }
    .success-check {
      animation: successPop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
    }

    /* Fire/streak animation */
    @keyframes fireGlow {
      0%, 100% { filter: drop-shadow(0 0 5px #ff6b35) drop-shadow(0 0 10px #ff6b35); transform: scale(1); }
      50% { filter: drop-shadow(0 0 15px #ff6b35) drop-shadow(0 0 25px #ff6b35); transform: scale(1.1); }
    }
    .fire-glow {
      animation: fireGlow 0.5s ease-in-out infinite;
    }

    /* Number count up */
    @keyframes countPop {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    .count-pop {
      animation: countPop 0.3s ease;
    }

    /* Progress ring animation */
    @keyframes progressFill {
      from { stroke-dashoffset: 283; }
    }
    .progress-ring-circle {
      transition: stroke-dashoffset 0.5s ease;
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
    }

    /* Accordion animation */
    .accordion-content {
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
    }

    /* Achievement unlock animation */
    @keyframes achievementUnlock {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(10deg); }
      70% { transform: scale(0.9) rotate(-5deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    .achievement-unlock {
      animation: achievementUnlock 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
    }

    /* Badge shine effect */
    @keyframes badgeShine {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }
    .badge-shine {
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%);
      background-size: 200% 100%;
      animation: badgeShine 2s ease-in-out infinite;
    }

    /* Waveform animation */
    @keyframes waveform {
      0%, 100% { height: 20%; }
      50% { height: 100%; }
    }
    .waveform-bar {
      animation: waveform 0.5s ease-in-out infinite;
    }

    /* Nav pill indicator */
    .nav-pill {
      position: absolute;
      bottom: 0;
      height: 3px;
      background: linear-gradient(90deg, #a855f7, #ec4899);
      border-radius: 3px 3px 0 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Bottom nav safe area */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .bottom-nav { padding-bottom: calc(12px + env(safe-area-inset-bottom)); }
    }

    /* Mobile-first responsive bottom nav */
    .bottom-nav {
      display: flex !important;
      justify-content: stretch !important;
      width: 100%;
    }
    .bottom-nav button {
      flex: 1;
      min-height: 60px;
      transition: all 0.3s ease;
    }

    /* Mobile touch improvements */
    * {
      -webkit-tap-highlight-color: transparent;
    }

    input, select, button {
      font-size: 16px;
    }

    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, #a855f7, #ec4899);
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(168, 85, 247, 0.5);
    }

    /* Smooth scrolling */
    html {
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
    }

    /* Hide scrollbars on mobile */
    ::-webkit-scrollbar { display: none; }
    body {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    /* Glow effects */
    .glow-purple { box-shadow: 0 0 20px rgba(168, 85, 247, 0.5); }
    .glow-green { box-shadow: 0 0 20px rgba(34, 197, 94, 0.5); }
    .glow-red { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }

    /* Gradient text */
    .gradient-text {
      background: linear-gradient(135deg, #a855f7 0%, #ec4899 50%, #f97316 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Card hover lift */
    .card-lift {
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .card-lift:active {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, createContext, useContext, useRef } = React;

    // ============================================
    // CONSTANTS & CONFIGURATION
    // ============================================

    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NATURAL_NOTES = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
    const OCTAVES = [3, 4, 5];

    const INTERVALS = {
      0: { name: 'Unison', short: 'P1', songs: ['Same note repeated'] },
      1: { name: 'Minor 2nd', short: 'm2', songs: ['Jaws theme', 'Pink Panther'] },
      2: { name: 'Major 2nd', short: 'M2', songs: ['Happy Birthday', 'Fr√®re Jacques'] },
      3: { name: 'Minor 3rd', short: 'm3', songs: ['Greensleeves', 'Hey Jude (verse)'] },
      4: { name: 'Major 3rd', short: 'M3', songs: ['When the Saints', 'Kumbaya'] },
      5: { name: 'Perfect 4th', short: 'P4', songs: ['Here Comes the Bride', 'Amazing Grace'] },
      6: { name: 'Tritone', short: 'TT', songs: ['The Simpsons', 'Maria (West Side Story)'] },
      7: { name: 'Perfect 5th', short: 'P5', songs: ['Star Wars', 'Twinkle Twinkle'] },
      8: { name: 'Minor 6th', short: 'm6', songs: ['The Entertainer', 'Love Story theme'] },
      9: { name: 'Major 6th', short: 'M6', songs: ['NBC chimes', 'My Bonnie'] },
      10: { name: 'Minor 7th', short: 'm7', songs: ['Star Trek theme', 'Somewhere (West Side)'] },
      11: { name: 'Major 7th', short: 'M7', songs: ['Take On Me', 'Superman theme'] },
      12: { name: 'Octave', short: 'P8', songs: ['Somewhere Over the Rainbow', 'Singin\' in the Rain'] },
    };

    // Achievement Badges
    const ACHIEVEMENTS = {
      first_correct: { id: 'first_correct', name: 'First Steps', description: 'Get your first correct answer', icon: 'üåü', requirement: (stats) => Object.values(stats).some(s => s.totalCorrect >= 1) },
      streak_5: { id: 'streak_5', name: 'On Fire', description: 'Get a 5 streak', icon: 'üî•', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 5) },
      streak_10: { id: 'streak_10', name: 'Unstoppable', description: 'Get a 10 streak', icon: 'üí´', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 10) },
      streak_25: { id: 'streak_25', name: 'Legendary', description: 'Get a 25 streak', icon: 'üëë', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 25) },
      correct_50: { id: 'correct_50', name: 'Getting Started', description: 'Answer 50 questions correctly', icon: 'üìö', requirement: (stats) => Object.values(stats).reduce((sum, s) => sum + (s.totalCorrect || 0), 0) >= 50 },
      correct_100: { id: 'correct_100', name: 'Dedicated', description: 'Answer 100 questions correctly', icon: 'üéØ', requirement: (stats) => Object.values(stats).reduce((sum, s) => sum + (s.totalCorrect || 0), 0) >= 100 },
      correct_500: { id: 'correct_500', name: 'Expert', description: 'Answer 500 questions correctly', icon: 'üèÜ', requirement: (stats) => Object.values(stats).reduce((sum, s) => sum + (s.totalCorrect || 0), 0) >= 500 },
      all_modes: { id: 'all_modes', name: 'Well Rounded', description: 'Play all 5 game modes', icon: 'üé≠', requirement: (stats) => Object.keys(GAME_MODES).every(mode => stats[mode]?.totalAnswered > 0) },
      perfect_10: { id: 'perfect_10', name: 'Perfect Ten', description: 'Get 10 correct in a row in any mode', icon: 'üíØ', requirement: (stats) => Object.values(stats).some(s => s.bestStreak >= 10) },
      interval_master: { id: 'interval_master', name: 'Interval Master', description: 'Answer 50 interval questions correctly', icon: '‚ÜîÔ∏è', requirement: (stats) => stats.intervals?.totalCorrect >= 50 },
      chord_master: { id: 'chord_master', name: 'Chord Master', description: 'Answer 50 chord questions correctly', icon: 'üéπ', requirement: (stats) => stats.chords?.totalCorrect >= 50 },
      scale_master: { id: 'scale_master', name: 'Scale Master', description: 'Answer 50 scale questions correctly', icon: 'üéº', requirement: (stats) => stats.scales?.totalCorrect >= 50 },
    };

    // Guitar chord fingerings (fret positions: -1 = muted, 0 = open, 1-5 = fret number)
    const GUITAR_CHORDS = {
      'C': { name: 'C Major', frets: [-1, 3, 2, 0, 1, 0], fingers: [0, 3, 2, 0, 1, 0] },
      'D': { name: 'D Major', frets: [-1, -1, 0, 2, 3, 2], fingers: [0, 0, 0, 1, 3, 2] },
      'E': { name: 'E Major', frets: [0, 2, 2, 1, 0, 0], fingers: [0, 2, 3, 1, 0, 0] },
      'G': { name: 'G Major', frets: [3, 2, 0, 0, 0, 3], fingers: [2, 1, 0, 0, 0, 3] },
      'A': { name: 'A Major', frets: [-1, 0, 2, 2, 2, 0], fingers: [0, 0, 1, 2, 3, 0] },
      'Am': { name: 'A Minor', frets: [-1, 0, 2, 2, 1, 0], fingers: [0, 0, 2, 3, 1, 0] },
      'Em': { name: 'E Minor', frets: [0, 2, 2, 0, 0, 0], fingers: [0, 2, 3, 0, 0, 0] },
      'Dm': { name: 'D Minor', frets: [-1, -1, 0, 2, 3, 1], fingers: [0, 0, 0, 2, 3, 1] },
      'F': { name: 'F Major', frets: [1, 3, 3, 2, 1, 1], fingers: [1, 3, 4, 2, 1, 1], barre: true },
      'Bm': { name: 'B Minor', frets: [-1, 2, 4, 4, 3, 2], fingers: [0, 1, 3, 4, 2, 1], barre: true },
      'C7': { name: 'C7', frets: [-1, 3, 2, 3, 1, 0], fingers: [0, 3, 2, 4, 1, 0] },
      'G7': { name: 'G7', frets: [3, 2, 0, 0, 0, 1], fingers: [3, 2, 0, 0, 0, 1] },
    };

    const CHORD_TYPES = {
      major: { name: 'Major', intervals: [0, 4, 7], symbol: '' },
      minor: { name: 'Minor', intervals: [0, 3, 7], symbol: 'm' },
      diminished: { name: 'Diminished', intervals: [0, 3, 6], symbol: 'dim' },
      augmented: { name: 'Augmented', intervals: [0, 4, 8], symbol: 'aug' },
      major7: { name: 'Major 7th', intervals: [0, 4, 7, 11], symbol: 'maj7' },
      minor7: { name: 'Minor 7th', intervals: [0, 3, 7, 10], symbol: 'm7' },
      dominant7: { name: 'Dominant 7th', intervals: [0, 4, 7, 10], symbol: '7' },
      sus2: { name: 'Suspended 2nd', intervals: [0, 2, 7], symbol: 'sus2' },
      sus4: { name: 'Suspended 4th', intervals: [0, 5, 7], symbol: 'sus4' },
    };

    const SCALE_TYPES = {
      major: { name: 'Major', intervals: [0, 2, 4, 5, 7, 9, 11, 12], description: 'Happy, bright sound' },
      natural_minor: { name: 'Natural Minor', intervals: [0, 2, 3, 5, 7, 8, 10, 12], description: 'Sad, dark sound' },
      harmonic_minor: { name: 'Harmonic Minor', intervals: [0, 2, 3, 5, 7, 8, 11, 12], description: 'Exotic, Middle Eastern feel' },
      melodic_minor: { name: 'Melodic Minor', intervals: [0, 2, 3, 5, 7, 9, 11, 12], description: 'Jazz minor scale' },
      pentatonic_major: { name: 'Major Pentatonic', intervals: [0, 2, 4, 7, 9, 12], description: 'Folk, country sound' },
      pentatonic_minor: { name: 'Minor Pentatonic', intervals: [0, 3, 5, 7, 10, 12], description: 'Blues, rock sound' },
      blues: { name: 'Blues', intervals: [0, 3, 5, 6, 7, 10, 12], description: 'Blues with blue note' },
      dorian: { name: 'Dorian', intervals: [0, 2, 3, 5, 7, 9, 10, 12], description: 'Minor with raised 6th' },
      mixolydian: { name: 'Mixolydian', intervals: [0, 2, 4, 5, 7, 9, 10, 12], description: 'Major with flat 7th' },
      phrygian: { name: 'Phrygian', intervals: [0, 1, 3, 5, 7, 8, 10, 12], description: 'Spanish, flamenco sound' },
    };

    const PROGRESSIONS = {
      'I-IV-V-I': { name: 'I - IV - V - I', chords: ['major', 'major', 'major', 'major'], degrees: [0, 5, 7, 0], description: 'Classic rock/pop progression' },
      'I-V-vi-IV': { name: 'I - V - vi - IV', chords: ['major', 'major', 'minor', 'major'], degrees: [0, 7, 9, 5], description: 'Pop punk, modern pop' },
      'ii-V-I': { name: 'ii - V - I', chords: ['minor', 'major', 'major'], degrees: [2, 7, 0], description: 'Jazz standard progression' },
      'I-vi-IV-V': { name: 'I - vi - IV - V', chords: ['major', 'minor', 'major', 'major'], degrees: [0, 9, 5, 7], description: '50s doo-wop progression' },
      'vi-IV-I-V': { name: 'vi - IV - I - V', chords: ['minor', 'major', 'major', 'major'], degrees: [9, 5, 0, 7], description: 'Emotional pop progression' },
      'I-IV-vi-V': { name: 'I - IV - vi - V', chords: ['major', 'major', 'minor', 'major'], degrees: [0, 5, 9, 7], description: 'Axis progression variant' },
      'i-VI-III-VII': { name: 'i - VI - III - VII', chords: ['minor', 'major', 'major', 'major'], degrees: [0, 8, 3, 10], description: 'Andalusian cadence' },
      'I-V-IV-V': { name: 'I - V - IV - V', chords: ['major', 'major', 'major', 'major'], degrees: [0, 7, 5, 7], description: 'Country/folk progression' },
    };

    const INSTRUMENTS = {
      piano: { name: 'Piano', midi: 'acoustic_grand_piano', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.4, release: 1.5 } } },
      electric_piano: { name: 'Electric Piano', midi: 'electric_piano_1', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.3, release: 1.2 } } },
      synth: { name: 'Synth', midi: 'synth_brass_1', config: { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.8 } } },
      organ: { name: 'Organ', midi: 'church_organ', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.3 } } },
      strings: { name: 'Strings', midi: 'string_ensemble_1', config: { oscillator: { type: 'fatsawtooth', spread: 20, count: 3 }, envelope: { attack: 0.3, decay: 0.1, sustain: 0.7, release: 1.0 } } },
      cello: { name: 'Cello', midi: 'cello', config: { oscillator: { type: 'fatsawtooth', spread: 10, count: 2 }, envelope: { attack: 0.4, decay: 0.2, sustain: 0.6, release: 1.2 } } },
      bell: { name: 'Bell', midi: 'tubular_bells', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 2.0 } } },
      vibraphone: { name: 'Vibraphone', midi: 'vibraphone', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.8, sustain: 0.2, release: 2.5 } } },
      marimba: { name: 'Marimba', midi: 'marimba', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.3, sustain: 0.05, release: 0.8 } } },
      guitar: { name: 'Guitar', midi: 'acoustic_guitar_nylon', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.4, sustain: 0.2, release: 1.0 } } },
      harpsichord: { name: 'Harpsichord', midi: 'harpsichord', config: { oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.5 } } },
      brass: { name: 'Brass', midi: 'brass_section', config: { oscillator: { type: 'fatsawtooth', spread: 15, count: 2 }, envelope: { attack: 0.15, decay: 0.2, sustain: 0.6, release: 0.6 } } },
      flute: { name: 'Flute', midi: 'flute', config: { oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.1, sustain: 0.7, release: 0.5 } } },
      bass: { name: 'Bass', midi: 'acoustic_bass', config: { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.5, release: 0.8 } } },
      pad: { name: 'Ambient Pad', midi: 'pad_2_warm', config: { oscillator: { type: 'fatsine', spread: 30, count: 3 }, envelope: { attack: 0.5, decay: 0.3, sustain: 0.8, release: 2.0 } } },
    };

    const GAME_MODES = {
      notes: { name: 'Note Recognition', icon: 'üéµ', description: 'Identify single notes' },
      intervals: { name: 'Interval Training', icon: '‚ÜîÔ∏è', description: 'Recognize intervals between notes' },
      chords: { name: 'Chord Recognition', icon: 'üéπ', description: 'Identify chord types' },
      scales: { name: 'Scale Recognition', icon: 'üéº', description: 'Identify scale types' },
      progressions: { name: 'Chord Progressions', icon: 'üîÑ', description: 'Recognize chord progressions' },
    };

    const NOTE_DIFFICULTIES = {
      easy: { notes: NATURAL_NOTES, choices: 4, octaves: [4], label: 'Easy', description: 'Natural notes, single octave' },
      medium: { notes: NOTES, choices: 4, octaves: [4], label: 'Medium', description: 'All notes, single octave' },
      hard: { notes: NOTES, choices: 6, octaves: [3, 4, 5], label: 'Hard', description: 'All notes, multiple octaves' },
    };

    const INTERVAL_DIFFICULTIES = {
      easy: { intervals: [3, 4, 5, 7], choices: 4, label: 'Easy', description: '3rds, 4ths, 5ths only' },
      medium: { intervals: [1, 2, 3, 4, 5, 7, 8, 9], choices: 4, label: 'Medium', description: 'Common intervals' },
      hard: { intervals: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], choices: 6, label: 'Hard', description: 'All intervals' },
    };

    const CHORD_DIFFICULTIES = {
      easy: { chords: ['major', 'minor'], choices: 2, label: 'Easy', description: 'Major vs Minor' },
      medium: { chords: ['major', 'minor', 'diminished', 'augmented'], choices: 4, label: 'Medium', description: 'Triads' },
      hard: { chords: ['major', 'minor', 'diminished', 'augmented', 'major7', 'minor7', 'dominant7'], choices: 6, label: 'Hard', description: 'Triads & 7th chords' },
    };

    const SCALE_DIFFICULTIES = {
      easy: { scales: ['major', 'natural_minor', 'pentatonic_major'], choices: 3, label: 'Easy', description: 'Major, Minor, Pentatonic' },
      medium: { scales: ['major', 'natural_minor', 'harmonic_minor', 'pentatonic_major', 'pentatonic_minor', 'blues'], choices: 4, label: 'Medium', description: 'Common scales' },
      hard: { scales: Object.keys(SCALE_TYPES), choices: 5, label: 'Hard', description: 'All scales including modes' },
    };

    const PROGRESSION_DIFFICULTIES = {
      easy: { progressions: ['I-IV-V-I', 'I-V-vi-IV', 'I-vi-IV-V'], choices: 3, label: 'Easy', description: 'Common pop progressions' },
      medium: { progressions: ['I-IV-V-I', 'I-V-vi-IV', 'ii-V-I', 'I-vi-IV-V', 'vi-IV-I-V'], choices: 4, label: 'Medium', description: 'Pop & jazz basics' },
      hard: { progressions: Object.keys(PROGRESSIONS), choices: 5, label: 'Hard', description: 'All progressions' },
    };

    const NAV_ITEMS = [
      { id: 'play', label: 'Play', icon: 'üéÆ' },
      { id: 'learn', label: 'Learn', icon: 'üìö' },
      { id: 'stats', label: 'Stats', icon: 'üìä' },
      { id: 'settings', label: 'Settings', icon: '‚öôÔ∏è' },
    ];

    // ============================================
    // TOAST CONTEXT
    // ============================================

    const ToastContext = createContext();

    function ToastProvider({ children }) {
      const [toasts, setToasts] = useState([]);

      const addToast = useCallback((message, type = 'info', duration = 3000) => {
        const id = Date.now();
        setToasts(prev => [...prev, { id, message, type, exiting: false }]);
        setTimeout(() => {
          setToasts(prev => prev.map(t => t.id === id ? { ...t, exiting: true } : t));
          setTimeout(() => {
            setToasts(prev => prev.filter(t => t.id !== id));
          }, 300);
        }, duration);
      }, []);

      return (
        <ToastContext.Provider value={{ addToast }}>
          {children}
          <div style={{ position: 'fixed', top: 20, right: 20, zIndex: 1000, display: 'flex', flexDirection: 'column', gap: 10 }}>
            {toasts.map(toast => (
              <div key={toast.id} className={toast.exiting ? 'toast-exit' : 'toast-enter'}
                style={{
                  padding: '12px 20px', borderRadius: 12, fontWeight: 600, fontSize: '0.9rem',
                  backgroundColor: toast.type === 'success' ? 'rgba(34, 197, 94, 0.95)' : toast.type === 'error' ? 'rgba(239, 68, 68, 0.95)' : 'rgba(59, 130, 246, 0.95)',
                  color: 'white', boxShadow: '0 4px 20px rgba(0,0,0,0.3)', maxWidth: 280
                }}>
                {toast.message}
              </div>
            ))}
          </div>
        </ToastContext.Provider>
      );
    }

    function useToast() {
      return useContext(ToastContext);
    }

    // ============================================
    // LOCAL STORAGE HOOKS
    // ============================================

    function useLocalStorage(key, initialValue) {
      const [storedValue, setStoredValue] = useState(() => {
        try {
          const item = window.localStorage.getItem(key);
          return item ? JSON.parse(item) : initialValue;
        } catch (error) {
          return initialValue;
        }
      });

      const setValue = useCallback((value) => {
        try {
          const valueToStore = value instanceof Function ? value(storedValue) : value;
          setStoredValue(valueToStore);
          window.localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {}
      }, [key, storedValue]);

      return [storedValue, setValue];
    }

    // ============================================
    // HAPTIC FEEDBACK
    // ============================================

    function triggerHaptic(type = 'light') {
      if ('vibrate' in navigator) {
        const patterns = { light: 10, medium: 25, heavy: 50, success: [10, 50, 10], error: [50, 30, 50] };
        navigator.vibrate(patterns[type] || 10);
      }
    }

    // ============================================
    // SOUND EFFECTS
    // ============================================

    function useSoundEffects() {
      const [enabled, setEnabled] = useLocalStorage('keyperfect_sfx', true);
      const audioCtx = useRef(null);

      const playSound = useCallback((type) => {
        if (!enabled) return;
        try {
          if (!audioCtx.current) audioCtx.current = new (window.AudioContext || window.webkitAudioContext)();
          const ctx = audioCtx.current;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);

          if (type === 'success') {
            osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
            osc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.1); // E5
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.3);
          } else if (type === 'error') {
            osc.frequency.setValueAtTime(200, ctx.currentTime);
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.2);
          }
        } catch (e) {}
      }, [enabled]);

      return { playSound, sfxEnabled: enabled, setSfxEnabled: setEnabled };
    }

    // ============================================
    // AUDIO HOOK
    // ============================================

    // MIDI Audio Context for soundfont
    const audioContextRef = { current: null };
    function getAudioContext() {
      if (!audioContextRef.current) {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContextRef.current;
    }

    function useAudio(instrument, useMidi = false, volume = 0.7) {
      const [synth, setSynth] = useState(null);
      const [polySynth, setPolySynth] = useState(null);
      const [midiInstrument, setMidiInstrument] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const [isLoading, setIsLoading] = useState(true);
      const gainNodeRef = useRef(null);

      // Load synth instruments
      useEffect(() => {
        if (useMidi) return;
        setIsLoading(true);
        const config = INSTRUMENTS[instrument]?.config || INSTRUMENTS.piano.config;
        const gainNode = new Tone.Gain(volume).toDestination();
        gainNodeRef.current = gainNode;
        const newSynth = new Tone.Synth(config).connect(gainNode);
        const newPolySynth = new Tone.PolySynth(Tone.Synth, config).connect(gainNode);
        setSynth(newSynth);
        setPolySynth(newPolySynth);
        setTimeout(() => setIsLoading(false), 300);
        return () => { newSynth.dispose(); newPolySynth.dispose(); gainNode.dispose(); };
      }, [instrument, useMidi]);

      // Update volume
      useEffect(() => {
        if (gainNodeRef.current) {
          gainNodeRef.current.gain.value = volume;
        }
      }, [volume]);

      // Load MIDI instrument
      useEffect(() => {
        if (!useMidi) return;
        setIsLoading(true);
        const midiName = INSTRUMENTS[instrument]?.midi || 'acoustic_grand_piano';
        const ac = getAudioContext();
        Soundfont.instrument(ac, midiName, {
          soundfont: 'MusyngKite',
          format: 'mp3'
        }).then(inst => {
          setMidiInstrument(inst);
          setIsLoading(false);
        }).catch(err => {
          console.error('Failed to load MIDI instrument:', err);
          setIsLoading(false);
        });
      }, [instrument, useMidi]);

      const playNote = useCallback(async (note, octave = 4, duration = '2n') => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            midiInstrument.play(`${note}${octave}`, ac.currentTime, { duration: 1.5, gain: volume });
          } else if (synth) {
            await Tone.start();
            synth.triggerAttackRelease(`${note}${octave}`, duration);
          }
          setTimeout(() => setIsPlaying(false), 1500);
        } catch (err) { setIsPlaying(false); }
      }, [synth, midiInstrument, isPlaying, useMidi]);

      const playNotes = useCallback(async (notes, duration = '2n') => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            notes.forEach(note => midiInstrument.play(note, ac.currentTime, { duration: 1.8, gain: volume }));
          } else if (polySynth) {
            await Tone.start();
            polySynth.triggerAttackRelease(notes, duration);
          }
          setTimeout(() => setIsPlaying(false), 1800);
        } catch (err) { setIsPlaying(false); }
      }, [polySynth, midiInstrument, isPlaying, useMidi]);

      const playSequence = useCallback(async (notes, interval = 0.5) => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            const now = ac.currentTime;
            notes.forEach((note, i) => midiInstrument.play(note, now + i * interval, { duration: 0.4, gain: volume }));
          } else if (synth) {
            await Tone.start();
            const now = Tone.now();
            notes.forEach((note, i) => synth.triggerAttackRelease(note, '4n', now + i * interval));
          }
          setTimeout(() => setIsPlaying(false), notes.length * interval * 1000 + 500);
        } catch (err) { setIsPlaying(false); }
      }, [synth, midiInstrument, isPlaying, useMidi]);

      const playChordSequence = useCallback(async (chordNotes, interval = 0.8) => {
        if (isPlaying) return;
        setIsPlaying(true);
        try {
          if (useMidi && midiInstrument) {
            const ac = getAudioContext();
            if (ac.state === 'suspended') await ac.resume();
            const now = ac.currentTime;
            chordNotes.forEach((chord, i) => {
              chord.forEach(note => midiInstrument.play(note, now + i * interval, { duration: 0.7, gain: volume }));
            });
          } else if (polySynth) {
            await Tone.start();
            const now = Tone.now();
            chordNotes.forEach((chord, i) => polySynth.triggerAttackRelease(chord, '2n', now + i * interval));
          }
          setTimeout(() => setIsPlaying(false), chordNotes.length * interval * 1000 + 800);
        } catch (err) { setIsPlaying(false); }
      }, [polySynth, midiInstrument, isPlaying, useMidi]);

      return { playNote, playNotes, playSequence, playChordSequence, isPlaying, isLoading };
    }

    // ============================================
    // STATISTICS CONTEXT
    // ============================================

    const StatsContext = createContext();

    function StatsProvider({ children }) {
      const [stats, setStats] = useLocalStorage('keyperfect_stats_v3', {
        notes: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
        intervals: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
        chords: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
        scales: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
        progressions: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
        history: [],
      });

      const recordAnswer = useCallback((mode, difficulty, correct, streak) => {
        setStats(prev => {
          const modeStats = { ...prev[mode] };
          modeStats.totalAnswered += 1;
          if (correct) modeStats.totalCorrect += 1;
          if (streak > modeStats.bestStreak) modeStats.bestStreak = streak;
          if (!modeStats.byDifficulty[difficulty]) modeStats.byDifficulty[difficulty] = { correct: 0, total: 0 };
          modeStats.byDifficulty[difficulty].total += 1;
          if (correct) modeStats.byDifficulty[difficulty].correct += 1;
          const newHistory = [...prev.history, { mode, difficulty, correct, timestamp: Date.now() }].slice(-100);
          return { ...prev, [mode]: modeStats, history: newHistory };
        });
      }, [setStats]);

      const resetStats = useCallback(() => {
        setStats({
          notes: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
          intervals: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
          chords: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
          scales: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
          progressions: { gamesPlayed: 0, totalCorrect: 0, totalAnswered: 0, bestStreak: 0, byDifficulty: {} },
          history: [],
        });
      }, [setStats]);

      return (
        <StatsContext.Provider value={{ stats, recordAnswer, resetStats }}>
          {children}
        </StatsContext.Provider>
      );
    }

    function useStats() { return useContext(StatsContext); }

    // ============================================
    // SETTINGS CONTEXT
    // ============================================

    const SettingsContext = createContext();

    function SettingsProvider({ children }) {
      const [settings, setSettings] = useLocalStorage('keyperfect_settings_v5', {
        instrument: 'piano',
        autoPlayOnStart: true,
        showOctaveInChoices: false,
        useMidi: false,
        volume: 0.7,
        practiceMode: false,
      });

      const updateSettings = useCallback((updates) => {
        setSettings(prev => ({ ...prev, ...updates }));
      }, [setSettings]);

      return (
        <SettingsContext.Provider value={{ settings, updateSettings }}>
          {children}
        </SettingsContext.Provider>
      );
    }

    function useSettings() { return useContext(SettingsContext); }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function shuffle(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function getNoteIndex(note) { return NOTES.indexOf(note); }

    function buildChord(rootNote, chordType, octave = 4) {
      const rootIndex = getNoteIndex(rootNote);
      const chord = CHORD_TYPES[chordType];
      return chord.intervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        const noteOctave = octave + Math.floor((rootIndex + interval) / 12);
        return `${NOTES[noteIndex]}${noteOctave}`;
      });
    }

    function buildScale(rootNote, scaleType, octave = 4) {
      const rootIndex = getNoteIndex(rootNote);
      const scale = SCALE_TYPES[scaleType];
      return scale.intervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        const noteOctave = octave + Math.floor((rootIndex + interval) / 12);
        return `${NOTES[noteIndex]}${noteOctave}`;
      });
    }

    function buildProgression(rootNote, progressionKey, octave = 3) {
      const progression = PROGRESSIONS[progressionKey];
      const rootIndex = getNoteIndex(rootNote);
      return progression.degrees.map((degree, i) => {
        const chordRoot = NOTES[(rootIndex + degree) % 12];
        const chordOctave = octave + Math.floor((rootIndex + degree) / 12);
        return buildChord(chordRoot, progression.chords[i], chordOctave);
      });
    }

    function getShareText(stats) {
      const totalAnswered = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalAnswered, 0);
      const totalCorrect = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalCorrect, 0);
      const accuracy = totalAnswered > 0 ? Math.round((totalCorrect / totalAnswered) * 100) : 0;
      const bestStreak = Math.max(...Object.keys(GAME_MODES).map(key => stats[key].bestStreak));
      return `üéµ KeyPerfect Stats üéµ\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìä ${totalAnswered} questions answered\n‚úÖ ${accuracy}% accuracy\nüî• ${bestStreak} best streak\n\nTrain your ear at KeyPerfect!`;
    }

    // ============================================
    // STYLES
    // ============================================

    const styles = {
      // Layout
      container: { minHeight: '100vh', display: 'flex', flexDirection: 'column', padding: '20px', paddingBottom: '110px', maxWidth: '100%', margin: '0 auto', width: '100%' },
      header: { textAlign: 'center', marginBottom: '20px', paddingTop: '10px' },
      title: { fontSize: '2rem', fontWeight: '700', marginBottom: '4px', background: 'linear-gradient(135deg, #a855f7 0%, #ec4899 50%, #f97316 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', cursor: 'pointer', letterSpacing: '-0.5px' },
      subtitle: { color: '#94a3b8', fontSize: '0.85rem', fontWeight: '500' },
      breadcrumbs: { display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '20px', fontSize: '0.9rem', color: '#94a3b8' },
      breadcrumbLink: { color: '#a855f7', cursor: 'pointer', background: 'none', border: 'none', fontSize: '0.9rem', padding: 0, fontWeight: '500' },
      breadcrumbSep: { color: '#475569' },
      breadcrumbCurrent: { color: 'white', fontWeight: '600' },

      // Cards - Glassmorphism
      card: { background: 'rgba(255, 255, 255, 0.08)', borderRadius: '24px', padding: '24px', backdropFilter: 'blur(20px)', WebkitBackdropFilter: 'blur(20px)', border: '1px solid rgba(255, 255, 255, 0.1)', boxShadow: '0 8px 32px rgba(0, 0, 0, 0.2)', width: '100%' },
      cardTitle: { fontSize: '1.2rem', fontWeight: '700', marginBottom: '20px', textAlign: 'center', background: 'linear-gradient(135deg, #fff 0%, #94a3b8 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' },

      // Mode Selection - Horizontal Scroll
      modeScroll: { display: 'flex', gap: '12px', overflowX: 'auto', paddingBottom: '12px', marginBottom: '20px', scrollSnapType: 'x mandatory', WebkitOverflowScrolling: 'touch' },
      modeCard: { minWidth: '140px', padding: '20px 16px', borderRadius: '20px', border: '2px solid rgba(255, 255, 255, 0.15)', background: 'rgba(255, 255, 255, 0.05)', backdropFilter: 'blur(10px)', color: 'white', cursor: 'pointer', textAlign: 'center', scrollSnapAlign: 'start', transition: 'all 0.3s ease' },
      modeCardActive: { borderColor: '#a855f7', background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(236, 72, 153, 0.2))', boxShadow: '0 0 30px rgba(168, 85, 247, 0.3)' },
      modeIcon: { fontSize: '2rem', marginBottom: '8px', display: 'block' },
      modeName: { fontSize: '0.9rem', fontWeight: '600', marginBottom: '4px' },
      modeDesc: { fontSize: '0.7rem', color: '#94a3b8', lineHeight: 1.3 },

      // Difficulty - Chip Style
      difficultyChips: { display: 'flex', gap: '10px', marginBottom: '24px', justifyContent: 'center', flexWrap: 'wrap' },
      difficultyChip: { padding: '12px 24px', borderRadius: '50px', border: '2px solid rgba(255, 255, 255, 0.2)', background: 'rgba(255, 255, 255, 0.05)', color: 'white', fontSize: '0.95rem', fontWeight: '600', cursor: 'pointer', transition: 'all 0.3s ease' },
      difficultyChipActive: { borderColor: '#a855f7', background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.4), rgba(236, 72, 153, 0.3))', boxShadow: '0 0 20px rgba(168, 85, 247, 0.3)' },

      // Start Button
      startBtn: { width: '100%', padding: '20px', borderRadius: '16px', border: 'none', background: 'linear-gradient(135deg, #a855f7, #ec4899, #f97316)', backgroundSize: '200% 200%', color: 'white', fontSize: '1.2rem', fontWeight: '700', cursor: 'pointer', minHeight: '60px', boxShadow: '0 8px 30px rgba(168, 85, 247, 0.4)', transition: 'all 0.3s ease', letterSpacing: '0.5px' },

      // Score Board - Enhanced
      scoreBoard: { display: 'flex', justifyContent: 'space-around', background: 'rgba(255, 255, 255, 0.08)', borderRadius: '20px', padding: '20px 16px', backdropFilter: 'blur(10px)', border: '1px solid rgba(255, 255, 255, 0.1)' },
      scoreStat: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px' },
      scoreLabel: { fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '1px', fontWeight: '500' },
      scoreValue: { fontSize: '1.4rem', fontWeight: '700' },

      // Floating Play Button
      floatingPlayBtn: { position: 'fixed', bottom: '120px', right: '24px', width: '72px', height: '72px', borderRadius: '50%', border: 'none', background: 'linear-gradient(135deg, #3b82f6, #8b5cf6, #a855f7)', color: 'white', fontSize: '1.8rem', cursor: 'pointer', boxShadow: '0 8px 30px rgba(139, 92, 246, 0.5)', zIndex: 100, display: 'flex', alignItems: 'center', justifyContent: 'center' },
      playHint: { marginTop: '12px', color: '#64748b', fontSize: '0.85rem', textAlign: 'center', fontWeight: '500' },

      // Choice Buttons - Enhanced
      choicesGrid: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '14px', marginTop: '20px' },
      choiceBtn: { padding: '22px 16px', borderRadius: '18px', border: '2px solid rgba(255, 255, 255, 0.15)', background: 'rgba(255, 255, 255, 0.08)', backdropFilter: 'blur(10px)', color: 'white', fontSize: '1rem', fontWeight: '600', cursor: 'pointer', minHeight: '70px', transition: 'all 0.2s ease', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center' },
      choiceBtnCorrect: { borderColor: '#22c55e', background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.4), rgba(22, 163, 74, 0.3))', boxShadow: '0 0 30px rgba(34, 197, 94, 0.4)' },
      choiceBtnWrong: { borderColor: '#ef4444', background: 'linear-gradient(135deg, rgba(239, 68, 68, 0.4), rgba(220, 38, 38, 0.3))', boxShadow: '0 0 30px rgba(239, 68, 68, 0.4)' },

      // Action Buttons
      actionButtons: { display: 'flex', gap: '14px', marginTop: '24px' },
      nextBtn: { flex: 1, padding: '18px', borderRadius: '14px', border: 'none', background: 'linear-gradient(135deg, #22c55e, #16a34a)', color: 'white', fontSize: '1.1rem', fontWeight: '700', cursor: 'pointer', minHeight: '56px', boxShadow: '0 8px 25px rgba(34, 197, 94, 0.4)' },
      resetBtn: { flex: 1, padding: '18px', borderRadius: '14px', border: '2px solid rgba(255, 255, 255, 0.2)', background: 'rgba(255, 255, 255, 0.05)', color: 'white', fontSize: '1rem', fontWeight: '600', cursor: 'pointer', minHeight: '56px' },

      // Result Box
      resultBox: { textAlign: 'center', padding: '20px', borderRadius: '16px', border: '2px solid', fontSize: '1.1rem', fontWeight: '700', backdropFilter: 'blur(10px)' },

      // Bottom Navigation - Enhanced
      bottomNav: { position: 'fixed', bottom: 0, left: 0, right: 0, background: 'rgba(15, 12, 41, 0.95)', backdropFilter: 'blur(20px)', WebkitBackdropFilter: 'blur(20px)', borderTop: '1px solid rgba(255,255,255,0.08)', display: 'flex', justifyContent: 'stretch', padding: '12px 8px 16px', zIndex: 999, width: '100%' },
      bottomNavItem: { display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', gap: '6px', background: 'none', border: 'none', color: '#64748b', fontSize: '0.7rem', fontWeight: '500', cursor: 'pointer', padding: '8px', borderRadius: '12px', flex: 1, minHeight: '60px', transition: 'all 0.3s ease', position: 'relative' },
      bottomNavItemActive: { color: '#a855f7' },
      bottomNavIcon: { fontSize: '1.5rem', transition: 'transform 0.3s ease' },

      // Stats Cards
      statsCard: { background: 'rgba(255, 255, 255, 0.06)', borderRadius: '20px', padding: '20px', marginBottom: '14px', backdropFilter: 'blur(10px)', border: '1px solid rgba(255, 255, 255, 0.08)' },
      statsTitle: { fontSize: '1.05rem', fontWeight: '700', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '10px' },
      statsGrid: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '16px' },
      statItem: { textAlign: 'center', padding: '12px', background: 'rgba(255, 255, 255, 0.04)', borderRadius: '12px' },
      statValue: { fontSize: '1.6rem', fontWeight: '700', background: 'linear-gradient(135deg, #a855f7, #ec4899)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' },
      statLabel: { fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '0.5px', marginTop: '4px', fontWeight: '500' },

      // Settings
      settingRow: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '18px 0', borderBottom: '1px solid rgba(255, 255, 255, 0.08)', minHeight: '60px' },
      settingLabel: { fontSize: '1rem', fontWeight: '500' },
      select: { padding: '14px 18px', borderRadius: '12px', border: '2px solid rgba(255, 255, 255, 0.15)', background: 'rgba(255, 255, 255, 0.08)', color: 'white', fontSize: '1rem', cursor: 'pointer', minHeight: '48px', appearance: 'none', backgroundImage: 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' fill=\'white\' viewBox=\'0 0 24 24\'%3E%3Cpath d=\'M7 10l5 5 5-5z\'/%3E%3C/svg%3E")', backgroundRepeat: 'no-repeat', backgroundPosition: 'right 12px center', backgroundSize: '20px', paddingRight: '40px' },
      toggle: { width: '56px', height: '32px', borderRadius: '16px', border: 'none', cursor: 'pointer', position: 'relative', transition: 'all 0.3s ease', minWidth: '56px' },
      toggleKnob: { width: '28px', height: '28px', borderRadius: '50%', backgroundColor: 'white', position: 'absolute', top: '2px', transition: 'left 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)', boxShadow: '0 2px 8px rgba(0,0,0,0.2)' },

      // Buttons
      dangerBtn: { padding: '18px', borderRadius: '14px', border: '2px solid #ef4444', background: 'rgba(239, 68, 68, 0.1)', color: '#ef4444', fontSize: '1rem', fontWeight: '600', cursor: 'pointer', marginTop: '20px', width: '100%', minHeight: '56px' },
      shareBtn: { padding: '18px', borderRadius: '14px', border: 'none', background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)', color: 'white', fontSize: '1rem', cursor: 'pointer', marginTop: '16px', width: '100%', fontWeight: '700', minHeight: '56px', boxShadow: '0 8px 25px rgba(59, 130, 246, 0.4)' },

      // Accordion
      accordion: { background: 'rgba(255, 255, 255, 0.05)', borderRadius: '16px', marginBottom: '12px', overflow: 'hidden', border: '1px solid rgba(255, 255, 255, 0.08)' },
      accordionHeader: { padding: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: 'pointer', background: 'none', border: 'none', width: '100%', color: 'white', textAlign: 'left', minHeight: '60px' },
      accordionTitle: { fontSize: '1rem', fontWeight: '600' },
      accordionArrow: { fontSize: '0.9rem', transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)' },
      accordionBody: { padding: '0 20px 20px' },
      refNotes: { fontSize: '0.95rem', color: '#a855f7', fontFamily: 'monospace', marginBottom: '10px', fontWeight: '500' },
      refDesc: { fontSize: '0.85rem', color: '#94a3b8', marginBottom: '12px', lineHeight: 1.5 },
      playSmallBtn: { padding: '14px 24px', borderRadius: '12px', border: 'none', background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)', color: 'white', fontSize: '0.95rem', fontWeight: '600', cursor: 'pointer', minHeight: '48px' },

      // Swipe Indicator
      swipeIndicator: { display: 'flex', justifyContent: 'center', gap: '10px', marginBottom: '20px' },
      swipeDot: { width: '8px', height: '8px', borderRadius: '50%', backgroundColor: 'rgba(255,255,255,0.2)', cursor: 'pointer', transition: 'all 0.3s ease' },
      swipeDotActive: { backgroundColor: '#a855f7', width: '24px', borderRadius: '4px' },

      // Skeleton
      skeleton: { height: '60px', marginBottom: '12px' },
    };

    // ============================================
    // COMPONENTS
    // ============================================

    // Skeleton Loader
    function Skeleton({ height = 60, style = {} }) {
      return <div className="skeleton" style={{ height, ...style }} />;
    }

    // Piano Visualization Component
    function PianoVisualization({ highlightedNotes = [], startOctave = 3, octaves = 2 }) {
      const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const blackKeys = { 'C': 'C#', 'D': 'D#', 'F': 'F#', 'G': 'G#', 'A': 'A#' };

      const isHighlighted = (note, octave) => {
        return highlightedNotes.some(n => n === `${note}${octave}` || n === note);
      };

      const keyStyle = {
        white: { width: '28px', height: '100px', backgroundColor: 'white', border: '1px solid #333', borderRadius: '0 0 4px 4px', display: 'flex', alignItems: 'flex-end', justifyContent: 'center', paddingBottom: '4px', fontSize: '0.6rem', color: '#333' },
        whiteHighlight: { backgroundColor: '#a855f7', color: 'white' },
        black: { width: '20px', height: '60px', backgroundColor: '#1a1a2e', border: '1px solid #000', borderRadius: '0 0 3px 3px', position: 'absolute', zIndex: 1 },
        blackHighlight: { backgroundColor: '#ec4899' },
      };

      return (
        <div style={{ display: 'flex', position: 'relative', justifyContent: 'center', padding: '10px 0', overflowX: 'auto' }}>
          {Array.from({ length: octaves }, (_, octIdx) => {
            const octave = startOctave + octIdx;
            return whiteKeys.map((key, idx) => (
              <div key={`${key}${octave}`} style={{ position: 'relative' }}>
                <div style={{ ...keyStyle.white, ...(isHighlighted(key, octave) ? keyStyle.whiteHighlight : {}) }}>
                  {key}{octave}
                </div>
                {blackKeys[key] && (
                  <div style={{ ...keyStyle.black, ...(isHighlighted(blackKeys[key], octave) ? keyStyle.blackHighlight : {}), left: '18px', top: '10px' }} />
                )}
              </div>
            ));
          })}
        </div>
      );
    }

    // Guitar Chord Chart Component
    function GuitarChordChart({ chord, size = 'medium' }) {
      const chordData = GUITAR_CHORDS[chord];
      if (!chordData) return null;

      const scale = size === 'small' ? 0.7 : size === 'large' ? 1.3 : 1;
      const fretWidth = 30 * scale;
      const fretHeight = 20 * scale;
      const stringSpacing = 16 * scale;
      const dotSize = 12 * scale;

      const strings = ['E', 'A', 'D', 'G', 'B', 'e'];
      const minFret = Math.max(1, Math.min(...chordData.frets.filter(f => f > 0)));
      const maxFret = Math.max(...chordData.frets);
      const startFret = maxFret <= 4 ? 1 : minFret;
      const showFrets = 4;

      return (
        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '10px' }}>
          <div style={{ fontWeight: '600', marginBottom: '8px', fontSize: `${14 * scale}px` }}>{chordData.name}</div>
          <svg width={fretWidth * 6 + 30} height={fretHeight * (showFrets + 1) + 30} style={{ overflow: 'visible' }}>
            {/* Nut or fret number */}
            {startFret === 1 ? (
              <rect x={15} y={20} width={stringSpacing * 5 + 10} height={4} fill="white" />
            ) : (
              <text x={5} y={35} fill="white" fontSize={12 * scale}>{startFret}</text>
            )}

            {/* Frets */}
            {Array.from({ length: showFrets + 1 }, (_, i) => (
              <line key={i} x1={15} y1={22 + i * fretHeight} x2={15 + stringSpacing * 5} y2={22 + i * fretHeight} stroke="rgba(255,255,255,0.3)" strokeWidth={1} />
            ))}

            {/* Strings */}
            {strings.map((_, i) => (
              <line key={i} x1={15 + i * stringSpacing} y1={22} x2={15 + i * stringSpacing} y2={22 + showFrets * fretHeight} stroke="rgba(255,255,255,0.5)" strokeWidth={1} />
            ))}

            {/* Finger positions */}
            {chordData.frets.map((fret, stringIdx) => {
              if (fret === -1) {
                return <text key={stringIdx} x={12 + stringIdx * stringSpacing} y={15} fill="#ef4444" fontSize={12 * scale}>√ó</text>;
              }
              if (fret === 0) {
                return <circle key={stringIdx} cx={15 + stringIdx * stringSpacing} cy={10} r={dotSize / 3} fill="none" stroke="white" strokeWidth={2} />;
              }
              const displayFret = fret - startFret + 1;
              if (displayFret > 0 && displayFret <= showFrets) {
                return (
                  <g key={stringIdx}>
                    <circle cx={15 + stringIdx * stringSpacing} cy={22 + (displayFret - 0.5) * fretHeight} r={dotSize / 2} fill="#a855f7" />
                    <text x={15 + stringIdx * stringSpacing} y={22 + (displayFret - 0.5) * fretHeight + 4} fill="white" fontSize={10 * scale} textAnchor="middle">
                      {chordData.fingers[stringIdx] || ''}
                    </text>
                  </g>
                );
              }
              return null;
            })}

            {/* Barre indicator */}
            {chordData.barre && (
              <rect x={12} y={22 + (chordData.frets[0] - startFret + 0.3) * fretHeight} width={stringSpacing * 5 + 6} height={8} rx={4} fill="rgba(168, 85, 247, 0.7)" />
            )}
          </svg>
        </div>
      );
    }

    // Volume Slider Component
    function VolumeSlider({ value, onChange }) {
      return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', flex: 1 }}>
          <span style={{ fontSize: '1.2rem' }}>üîà</span>
          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
            style={{
              flex: 1,
              height: '6px',
              borderRadius: '3px',
              background: `linear-gradient(to right, #a855f7 ${value * 100}%, rgba(255,255,255,0.2) ${value * 100}%)`,
              appearance: 'none',
              outline: 'none',
              cursor: 'pointer',
            }}
          />
          <span style={{ fontSize: '1.2rem' }}>üîä</span>
        </div>
      );
    }

    // Confetti Component for celebrations
    function Confetti({ trigger }) {
      const [particles, setParticles] = useState([]);

      useEffect(() => {
        if (trigger) {
          const colors = ['#a855f7', '#ec4899', '#f97316', '#22c55e', '#3b82f6', '#facc15'];
          const newParticles = Array.from({ length: 30 }, (_, i) => ({
            id: i,
            left: Math.random() * 100,
            color: colors[Math.floor(Math.random() * colors.length)],
            delay: Math.random() * 0.5,
            size: Math.random() * 8 + 6,
          }));
          setParticles(newParticles);
          setTimeout(() => setParticles([]), 3000);
        }
      }, [trigger]);

      return (
        <>
          {particles.map(p => (
            <div key={p.id} className="confetti" style={{
              left: `${p.left}%`,
              backgroundColor: p.color,
              animationDelay: `${p.delay}s`,
              width: `${p.size}px`,
              height: `${p.size}px`,
              borderRadius: Math.random() > 0.5 ? '50%' : '2px',
            }} />
          ))}
        </>
      );
    }

    // Progress Ring Component for stats
    function ProgressRing({ progress, size = 80, strokeWidth = 6, color = '#a855f7', label = '', value = '' }) {
      const radius = (size - strokeWidth) / 2;
      const circumference = radius * 2 * Math.PI;
      const offset = circumference - (progress / 100) * circumference;

      return (
        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px' }}>
          <svg width={size} height={size} style={{ transform: 'rotate(-90deg)' }}>
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              fill="none"
              stroke="rgba(255,255,255,0.1)"
              strokeWidth={strokeWidth}
            />
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              fill="none"
              stroke={color}
              strokeWidth={strokeWidth}
              strokeDasharray={circumference}
              strokeDashoffset={offset}
              strokeLinecap="round"
              className="progress-ring-circle"
              style={{ filter: `drop-shadow(0 0 6px ${color})` }}
            />
          </svg>
          <div style={{ position: 'absolute', marginTop: size / 2 - 10, fontSize: '1rem', fontWeight: '700' }}>{value}</div>
          {label && <div style={{ fontSize: '0.7rem', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '0.5px' }}>{label}</div>}
        </div>
      );
    }

    // Waveform Visualization Component
    function Waveform({ isPlaying, barCount = 5 }) {
      return (
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '3px', height: '32px' }}>
          {Array.from({ length: barCount }, (_, i) => (
            <div
              key={i}
              className={isPlaying ? 'waveform-bar' : ''}
              style={{
                width: '4px',
                height: isPlaying ? '100%' : '20%',
                backgroundColor: '#a855f7',
                borderRadius: '2px',
                animationDelay: `${i * 0.1}s`,
                transition: 'height 0.3s ease',
              }}
            />
          ))}
        </div>
      );
    }

    // Streak Fire Animation
    function StreakFire({ streak }) {
      if (streak < 3) return null;
      const flames = streak >= 10 ? 3 : streak >= 5 ? 2 : 1;
      return (
        <span className="fire-glow" style={{ display: 'inline-flex' }}>
          {Array.from({ length: flames }, (_, i) => (
            <span key={i} style={{ fontSize: '1.2rem' }}>üî•</span>
          ))}
        </span>
      );
    }

    // Achievement Unlock Notification
    function AchievementNotification({ achievement, onClose }) {
      useEffect(() => {
        const timer = setTimeout(onClose, 4000);
        return () => clearTimeout(timer);
      }, [onClose]);

      return (
        <div style={{
          position: 'fixed',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.95), rgba(236, 72, 153, 0.95))',
          padding: '32px 48px',
          borderRadius: '24px',
          textAlign: 'center',
          zIndex: 1100,
          backdropFilter: 'blur(20px)',
          border: '1px solid rgba(255,255,255,0.2)',
          boxShadow: '0 20px 60px rgba(168, 85, 247, 0.5)',
        }} className="achievement-unlock">
          <div style={{ fontSize: '4rem', marginBottom: '12px' }}>{achievement.icon}</div>
          <div style={{ fontSize: '0.8rem', color: 'rgba(255,255,255,0.7)', marginBottom: '4px', textTransform: 'uppercase', letterSpacing: '2px' }}>Achievement Unlocked!</div>
          <div style={{ fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px' }}>{achievement.name}</div>
          <div style={{ fontSize: '0.9rem', color: 'rgba(255,255,255,0.8)' }}>{achievement.description}</div>
        </div>
      );
    }

    // Bottom Navigation with Pill Indicator with Pill Indicator
    function BottomNav({ currentView, setView }) {
      const navRef = useRef(null);
      const [pillStyle, setPillStyle] = useState({ left: 0, width: 0 });

      useEffect(() => {
        const updatePill = () => {
          if (navRef.current) {
            const activeIdx = NAV_ITEMS.findIndex(item => item.id === currentView);
            const buttons = navRef.current.querySelectorAll('button');
            if (buttons[activeIdx]) {
              const btn = buttons[activeIdx];
              setPillStyle({
                left: btn.offsetLeft + 8,
                width: btn.offsetWidth - 16,
              });
            }
          }
        };
        updatePill();
        window.addEventListener('resize', updatePill);
        return () => window.removeEventListener('resize', updatePill);
      }, [currentView]);

      return (
        <nav ref={navRef} style={styles.bottomNav} className="bottom-nav">
          {/* Animated pill indicator */}
          <div className="nav-pill" style={{ ...pillStyle, position: 'absolute' }} />
          {NAV_ITEMS.map(item => (
            <button key={item.id} onClick={() => { setView(item.id); triggerHaptic('light'); }}
              className="btn-press"
              style={{ ...styles.bottomNavItem, ...(currentView === item.id ? styles.bottomNavItemActive : {}) }}>
              <span style={{ ...styles.bottomNavIcon, transform: currentView === item.id ? 'scale(1.15)' : 'scale(1)' }}>{item.icon}</span>
              <span>{item.label}</span>
            </button>
          ))}
        </nav>
      );
    }

    // Breadcrumbs
    function Breadcrumbs({ items }) {
      return (
        <div style={styles.breadcrumbs}>
          {items.map((item, i) => (
            <React.Fragment key={i}>
              {i > 0 && <span style={styles.breadcrumbSep}>/</span>}
              {item.onClick ? (
                <button style={styles.breadcrumbLink} onClick={item.onClick} className="btn-press">{item.label}</button>
              ) : (
                <span style={styles.breadcrumbCurrent}>{item.label}</span>
              )}
            </React.Fragment>
          ))}
        </div>
      );
    }

    // Floating Play Button
    function FloatingPlayButton({ onClick, isPlaying, isLoading }) {
      if (isLoading) return (
        <button style={{ ...styles.floatingPlayBtn, opacity: 0.5 }} disabled>
          <span>‚è≥</span>
        </button>
      );
      return (
        <button onClick={() => { onClick(); triggerHaptic('medium'); }} disabled={isPlaying}
          className={`btn-press ${!isPlaying ? 'floating-btn' : ''}`}
          style={{ ...styles.floatingPlayBtn, opacity: isPlaying ? 0.7 : 1 }}>
          <span>{isPlaying ? 'üîä' : '‚ñ∂Ô∏è'}</span>
        </button>
      );
    }

    // Accordion
    function Accordion({ title, children, defaultOpen = false, onPlay, isPlaying }) {
      const [isOpen, setIsOpen] = useState(defaultOpen);
      return (
        <div style={styles.accordion}>
          <button style={styles.accordionHeader} onClick={() => setIsOpen(!isOpen)} className="btn-press">
            <span style={styles.accordionTitle}>{title}</span>
            <span style={{ ...styles.accordionArrow, transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)' }}>‚ñº</span>
          </button>
          <div className="accordion-content" style={{ maxHeight: isOpen ? '500px' : '0', opacity: isOpen ? 1 : 0 }}>
            <div style={styles.accordionBody}>
              {children}
              {onPlay && (
                <button onClick={(e) => { e.stopPropagation(); onPlay(); triggerHaptic('light'); }}
                  disabled={isPlaying} className="btn-press" style={styles.playSmallBtn}>
                  {isPlaying ? 'Playing...' : '‚ñ∂ Play'}
                </button>
              )}
            </div>
          </div>
        </div>
      );
    }

    // Swipe Container for Learn pages
    function SwipeContainer({ pages, currentPage, setCurrentPage }) {
      const containerRef = useRef(null);
      const startX = useRef(0);
      const currentX = useRef(0);

      const handleTouchStart = (e) => { startX.current = e.touches[0].clientX; };
      const handleTouchMove = (e) => { currentX.current = e.touches[0].clientX; };
      const handleTouchEnd = () => {
        const diff = startX.current - currentX.current;
        const pageKeys = Object.keys(pages);
        const currentIndex = pageKeys.indexOf(currentPage);
        if (diff > 50 && currentIndex < pageKeys.length - 1) {
          setCurrentPage(pageKeys[currentIndex + 1]);
          triggerHaptic('light');
        } else if (diff < -50 && currentIndex > 0) {
          setCurrentPage(pageKeys[currentIndex - 1]);
          triggerHaptic('light');
        }
      };

      return (
        <div>
          <div style={styles.swipeIndicator}>
            {Object.keys(pages).map(key => (
              <div key={key} style={{ ...styles.swipeDot, ...(currentPage === key ? styles.swipeDotActive : {}) }}
                onClick={() => setCurrentPage(key)} />
            ))}
          </div>
          <div ref={containerRef} className="swipe-container"
            onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
            {pages[currentPage]}
          </div>
        </div>
      );
    }

    // Score Board with enhanced visuals
    function ScoreBoard({ score, total, streak, bestStreak, isPlaying }) {
      return (
        <div style={styles.scoreBoard}>
          <div style={styles.scoreStat}>
            <span style={styles.scoreLabel}>Score</span>
            <span style={styles.scoreValue} className={score > 0 ? 'count-pop' : ''}>{score}/{total}</span>
          </div>
          <div style={styles.scoreStat}>
            <span style={styles.scoreLabel}>Streak</span>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <span style={{ ...styles.scoreValue, color: streak >= 5 ? '#f97316' : 'white' }}>{streak}</span>
              <StreakFire streak={streak} />
            </div>
          </div>
          <div style={styles.scoreStat}>
            <span style={styles.scoreLabel}>Best</span>
            <span style={{ ...styles.scoreValue, color: streak === bestStreak && bestStreak > 0 ? '#22c55e' : 'white' }}>{bestStreak}</span>
          </div>
          <div style={styles.scoreStat}>
            <Waveform isPlaying={isPlaying} barCount={4} />
          </div>
        </div>
      );
    }

    // Generic Game Component
    function GameComponent({ mode, difficulty, onBack, difficultySettings, buildQuestion, getChoiceLabel, getCorrectAnswer }) {
      const { settings } = useSettings();
      const { recordAnswer } = useStats();
      const { addToast } = useToast();
      const { playSound } = useSoundEffects();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const diffSettings = difficultySettings[difficulty];

      const [gameState, setGameState] = useState('playing');
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [choices, setChoices] = useState([]);
      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(0);
      const [totalPlayed, setTotalPlayed] = useState(0);
      const [lastResult, setLastResult] = useState(null);
      const [selectedAnswer, setSelectedAnswer] = useState(null);
      const [shakeWrong, setShakeWrong] = useState(false);
      const [confettiTrigger, setConfettiTrigger] = useState(0);

      const generateRound = useCallback(() => {
        const question = buildQuestion(diffSettings, audio);
        setCurrentQuestion(question);
        setChoices(question.choices);
        setLastResult(null);
        setSelectedAnswer(null);
        setGameState('playing');
        setShakeWrong(false);
        if (settings.autoPlayOnStart && question.play) {
          setTimeout(() => question.play(), 300);
        }
      }, [diffSettings, settings.autoPlayOnStart, audio, buildQuestion]);

      useEffect(() => { if (!audio.isLoading) generateRound(); }, [audio.isLoading]);

      const handleGuess = (guess) => {
        if (gameState !== 'playing') return;
        const correctAnswer = getCorrectAnswer(currentQuestion);
        const correct = guess === correctAnswer;
        setSelectedAnswer(guess);

        // Get hint for intervals (song examples)
        let hint = '';
        if (mode === 'intervals' && INTERVALS[correctAnswer]?.songs) {
          hint = `Sounds like: ${INTERVALS[correctAnswer].songs.join(' or ')}`;
        }

        if (settings.practiceMode) {
          // Practice mode - no scoring, just learning
          if (correct) {
            playSound('success');
            triggerHaptic('success');
            setLastResult({ correct: true, message: '‚úì Correct!', hint });
          } else {
            playSound('error');
            triggerHaptic('error');
            setShakeWrong(true);
            setTimeout(() => setShakeWrong(false), 500);
            setLastResult({ correct: false, message: `It was ${getChoiceLabel(correctAnswer)}`, hint, showPiano: currentQuestion.notes });
          }
        } else {
          // Normal mode with scoring
          setTotalPlayed(prev => prev + 1);
          let newStreak = streak;
          if (correct) {
            playSound('success');
            triggerHaptic('success');
            setScore(prev => prev + 1);
            newStreak = streak + 1;
            setStreak(newStreak);
            if (newStreak > bestStreak) setBestStreak(newStreak);
            setLastResult({ correct: true, message: '‚úì Correct!', hint });
            // Streak milestones with confetti
            if (newStreak === 5) { addToast('üî• 5 streak! Keep going!', 'success'); setConfettiTrigger(Date.now()); }
            if (newStreak === 10) { addToast('üî•üî• 10 streak! Amazing!', 'success'); setConfettiTrigger(Date.now()); }
            if (newStreak === 25) { addToast('üî•üî•üî• 25 streak! Legendary!', 'success'); setConfettiTrigger(Date.now()); }
          } else {
            playSound('error');
            triggerHaptic('error');
            setShakeWrong(true);
            setTimeout(() => setShakeWrong(false), 500);
            setStreak(0);
            newStreak = 0;
            setLastResult({ correct: false, message: `‚úó Wrong! It was ${getChoiceLabel(correctAnswer)}`, hint });
          }
          recordAnswer(mode, difficulty, correct, newStreak);
        }
        setGameState('result');
      };

      const handleReplay = () => {
        if (currentQuestion?.play) {
          triggerHaptic('light');
          currentQuestion.play();
        }
      };

      const modeInfo = GAME_MODES[mode];

      if (audio.isLoading) {
        return (
          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }}>
            <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: modeInfo.name }]} />
            <Skeleton height={60} />
            <Skeleton height={100} />
            <Skeleton height={200} />
          </div>
        );
      }

      return (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '16px' }} className="page-enter">
          <Confetti trigger={confettiTrigger} />
          <Breadcrumbs items={[{ label: 'Play', onClick: onBack }, { label: modeInfo.name }]} />
          <ScoreBoard score={score} total={totalPlayed} streak={streak} bestStreak={bestStreak} isPlaying={audio.isPlaying} />

          <p style={styles.playHint}>Tap the play button to hear again</p>

          {lastResult && (
            <div className={lastResult.correct ? 'success-check' : ''} style={{ ...styles.resultBox, backgroundColor: lastResult.correct ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)', borderColor: lastResult.correct ? '#22c55e' : '#ef4444' }}>
              <div style={{ fontSize: '1.2rem' }}>{lastResult.message}</div>
              {lastResult.hint && <div style={{ fontSize: '0.85rem', marginTop: '8px', color: '#94a3b8' }}>{lastResult.hint}</div>}
              {lastResult.showPiano && <PianoVisualization highlightedNotes={lastResult.showPiano} startOctave={3} octaves={2} />}
            </div>
          )}
          {settings.practiceMode && (
            <div style={{ textAlign: 'center', padding: '10px', backgroundColor: 'rgba(168, 85, 247, 0.15)', borderRadius: '12px', fontSize: '0.85rem', color: '#a855f7', border: '1px solid rgba(168, 85, 247, 0.3)' }}>
              üéì Practice Mode - No scoring
            </div>
          )}

          <div className={shakeWrong ? 'shake' : ''} style={styles.choicesGrid}>
            {choices.map((choice, i) => {
              const correctAnswer = currentQuestion ? getCorrectAnswer(currentQuestion) : null;
              const isCorrect = gameState === 'result' && choice === correctAnswer;
              const isWrong = gameState === 'result' && choice === selectedAnswer && choice !== correctAnswer;
              return (
                <button key={i} onClick={() => handleGuess(choice)} disabled={gameState === 'result'}
                  className={`btn-press ${isCorrect ? 'glow-green' : ''} ${isWrong ? 'glow-red' : ''}`}
                  style={{ ...styles.choiceBtn, fontSize: '0.9rem', ...(isCorrect ? styles.choiceBtnCorrect : {}), ...(isWrong ? styles.choiceBtnWrong : {}), ...(gameState === 'result' ? { cursor: 'default' } : {}) }}>
                  {getChoiceLabel(choice)}
                </button>
              );
            })}
          </div>

          <div style={styles.actionButtons}>
            {gameState === 'result' && <button onClick={generateRound} className="btn-press" style={styles.nextBtn}>Next ‚Üí</button>}
            <button onClick={onBack} className="btn-press" style={styles.resetBtn}>Exit</button>
          </div>

          <FloatingPlayButton onClick={handleReplay} isPlaying={audio.isPlaying} isLoading={audio.isLoading} />
        </div>
      );
    }

    // Note Game
    function NoteGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const note = diffSettings.notes[Math.floor(Math.random() * diffSettings.notes.length)];
        const octave = diffSettings.octaves[Math.floor(Math.random() * diffSettings.octaves.length)];
        const available = diffSettings.notes.filter(n => n !== note);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, note]);
        return { note, octave, choices, play: () => audio.playNote(note, octave) };
      };
      return <GameComponent mode="notes" difficulty={difficulty} onBack={onBack} difficultySettings={NOTE_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => c} getCorrectAnswer={q => q.note} />;
    }

    // Interval Game
    function IntervalGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const interval = diffSettings.intervals[Math.floor(Math.random() * diffSettings.intervals.length)];
        const baseNote = NOTES[Math.floor(Math.random() * NOTES.length)];
        const baseIndex = getNoteIndex(baseNote);
        const secondIndex = (baseIndex + interval) % 12;
        const secondOctave = baseIndex + interval >= 12 ? 5 : 4;
        const notes = [`${baseNote}4`, `${NOTES[secondIndex]}${secondOctave}`];
        const available = diffSettings.intervals.filter(i => i !== interval);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, interval]);
        return { interval, notes, choices, play: () => audio.playSequence(notes) };
      };
      return <GameComponent mode="intervals" difficulty={difficulty} onBack={onBack} difficultySettings={INTERVAL_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => INTERVALS[c].name} getCorrectAnswer={q => q.interval} />;
    }

    // Chord Game
    function ChordGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const chordType = diffSettings.chords[Math.floor(Math.random() * diffSettings.chords.length)];
        const rootNote = NOTES[Math.floor(Math.random() * NOTES.length)];
        const notes = buildChord(rootNote, chordType, 4);
        const available = diffSettings.chords.filter(c => c !== chordType);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, chordType]);
        return { chordType, notes, choices, play: () => audio.playNotes(notes) };
      };
      return <GameComponent mode="chords" difficulty={difficulty} onBack={onBack} difficultySettings={CHORD_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => CHORD_TYPES[c].name} getCorrectAnswer={q => q.chordType} />;
    }

    // Scale Game
    function ScaleGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const scaleType = diffSettings.scales[Math.floor(Math.random() * diffSettings.scales.length)];
        const rootNote = NATURAL_NOTES[Math.floor(Math.random() * NATURAL_NOTES.length)];
        const notes = buildScale(rootNote, scaleType, 4);
        const available = diffSettings.scales.filter(s => s !== scaleType);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, scaleType]);
        return { scaleType, notes, choices, play: () => audio.playSequence(notes, 0.25) };
      };
      return <GameComponent mode="scales" difficulty={difficulty} onBack={onBack} difficultySettings={SCALE_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => SCALE_TYPES[c].name} getCorrectAnswer={q => q.scaleType} />;
    }

    // Progression Game
    function ProgressionGame({ difficulty, onBack }) {
      const buildQuestion = (diffSettings, audio) => {
        const progressionKey = diffSettings.progressions[Math.floor(Math.random() * diffSettings.progressions.length)];
        const rootNote = NATURAL_NOTES[Math.floor(Math.random() * NATURAL_NOTES.length)];
        const chords = buildProgression(rootNote, progressionKey, 3);
        const available = diffSettings.progressions.filter(p => p !== progressionKey);
        const wrong = shuffle(available).slice(0, diffSettings.choices - 1);
        const choices = shuffle([...wrong, progressionKey]);
        return { progressionKey, chords, choices, play: () => audio.playChordSequence(chords) };
      };
      return <GameComponent mode="progressions" difficulty={difficulty} onBack={onBack} difficultySettings={PROGRESSION_DIFFICULTIES}
        buildQuestion={buildQuestion} getChoiceLabel={c => PROGRESSIONS[c].name} getCorrectAnswer={q => q.progressionKey} />;
    }

    // Learn View with Swipe
    function LearnView() {
      const { settings } = useSettings();
      const audio = useAudio(settings.instrument, settings.useMidi, settings.volume);
      const [currentPage, setCurrentPage] = useState('intervals');

      const ScalesPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Scales</h2>
          {Object.entries(SCALE_TYPES).map(([key, scale]) => {
            const notes = buildScale('C', key, 4);
            const noteNames = scale.intervals.map(i => NOTES[(i % 12)]);
            return (
              <Accordion key={key} title={scale.name} onPlay={() => audio.playSequence(notes, 0.25)} isPlaying={audio.isPlaying}>
                <div style={styles.refNotes}>{noteNames.join(' - ')}</div>
                <div style={styles.refDesc}>{scale.description}</div>
              </Accordion>
            );
          })}
        </div>
      );

      const ChordsPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Chords</h2>
          {Object.entries(CHORD_TYPES).map(([key, chord]) => {
            const notes = buildChord('C', key, 4);
            const noteNames = chord.intervals.map(i => NOTES[(i % 12)]);
            return (
              <Accordion key={key} title={`C${chord.symbol} - ${chord.name}`} onPlay={() => audio.playNotes(notes)} isPlaying={audio.isPlaying}>
                <div style={styles.refNotes}>{noteNames.join(' - ')}</div>
                <div style={styles.refDesc}>Intervals: {chord.intervals.join(', ')} semitones</div>
              </Accordion>
            );
          })}
        </div>
      );

      const ProgressionsPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Progressions</h2>
          {Object.entries(PROGRESSIONS).map(([key, prog]) => {
            const chords = buildProgression('C', key, 3);
            return (
              <Accordion key={key} title={prog.name} onPlay={() => audio.playChordSequence(chords)} isPlaying={audio.isPlaying}>
                <div style={styles.refDesc}>{prog.description}</div>
              </Accordion>
            );
          })}
        </div>
      );

      const IntervalsPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Intervals</h2>
          {Object.entries(INTERVALS).map(([key, interval]) => {
            const baseNote = 'C';
            const octave = 4;
            const noteIndex = NOTES.indexOf(baseNote);
            const secondNote = NOTES[(noteIndex + parseInt(key)) % 12];
            const secondOctave = octave + Math.floor((noteIndex + parseInt(key)) / 12);
            const notes = [`${baseNote}${octave}`, `${secondNote}${secondOctave}`];
            return (
              <Accordion key={key} title={`${interval.name} (${interval.short})`} onPlay={() => audio.playSequence(notes)} isPlaying={audio.isPlaying}>
                <div style={styles.refNotes}>{baseNote} ‚Üí {secondNote}</div>
                <div style={styles.refDesc}>Sounds like: {interval.songs.join(', ')}</div>
                <PianoVisualization highlightedNotes={notes} startOctave={4} octaves={1} />
              </Accordion>
            );
          })}
        </div>
      );

      const GuitarPage = () => (
        <div>
          <h2 style={{ ...styles.cardTitle, marginBottom: '16px' }}>Guitar Chords</h2>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '12px' }}>
            {Object.entries(GUITAR_CHORDS).map(([key, chord]) => (
              <div key={key} style={{ backgroundColor: 'rgba(255,255,255,0.05)', borderRadius: '12px', padding: '8px' }}>
                <GuitarChordChart chord={key} size="small" />
              </div>
            ))}
          </div>
        </div>
      );

      const pages = { intervals: <IntervalsPage />, scales: <ScalesPage />, chords: <ChordsPage />, progressions: <ProgressionsPage />, guitar: <GuitarPage /> };

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Learn' }]} />
          <p style={{ textAlign: 'center', color: '#64748b', fontSize: '0.8rem', marginBottom: '12px' }}>Swipe left/right to navigate</p>
          <SwipeContainer pages={pages} currentPage={currentPage} setCurrentPage={setCurrentPage} />
        </div>
      );
    }

    // Stats View
    function StatsView() {
      const { stats, resetStats } = useStats();
      const { addToast } = useToast();
      const [showAchievements, setShowAchievements] = useState(false);

      const getAccuracy = (correct, total) => total === 0 ? 0 : Math.round((correct / total) * 100);
      const totalAnswered = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalAnswered, 0);
      const totalCorrect = Object.keys(GAME_MODES).reduce((sum, key) => sum + stats[key].totalCorrect, 0);
      const overallAccuracy = getAccuracy(totalCorrect, totalAnswered);
      const bestStreak = Math.max(...Object.keys(GAME_MODES).map(key => stats[key].bestStreak));

      // Check unlocked achievements
      const unlockedAchievements = Object.values(ACHIEVEMENTS).filter(a => a.requirement(stats));
      const lockedAchievements = Object.values(ACHIEVEMENTS).filter(a => !a.requirement(stats));

      const handleShare = async () => {
        const text = getShareText(stats);
        triggerHaptic('light');
        try {
          if (navigator.share) {
            await navigator.share({ title: 'KeyPerfect Stats', text });
          } else if (navigator.clipboard) {
            await navigator.clipboard.writeText(text);
            addToast('Copied to clipboard!', 'success');
          }
        } catch (err) {}
      };

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Stats' }]} />

          {/* Overall Stats with Progress Rings */}
          <div style={{ ...styles.statsCard, marginBottom: '16px' }}>
            <div style={styles.statsTitle}>üìä Overall Progress</div>
            <div style={{ display: 'flex', justifyContent: 'space-around', alignItems: 'center', padding: '16px 0' }}>
              <div style={{ position: 'relative', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                <ProgressRing progress={overallAccuracy} size={90} strokeWidth={8} color="#22c55e" value={`${overallAccuracy}%`} />
                <div style={{ marginTop: '36px', fontSize: '0.75rem', color: '#94a3b8', textTransform: 'uppercase' }}>Accuracy</div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '2.5rem', fontWeight: '700', background: 'linear-gradient(135deg, #a855f7, #ec4899)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>{totalAnswered}</div>
                <div style={{ fontSize: '0.75rem', color: '#94a3b8', textTransform: 'uppercase' }}>Questions</div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '2.5rem', fontWeight: '700', color: '#f97316', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}>
                  {bestStreak}
                  {bestStreak >= 5 && <span style={{ fontSize: '1.5rem' }}>üî•</span>}
                </div>
                <div style={{ fontSize: '0.75rem', color: '#94a3b8', textTransform: 'uppercase' }}>Best Streak</div>
              </div>
            </div>
          </div>

          {/* Achievements Section */}
          <div style={styles.statsCard}>
            <button onClick={() => setShowAchievements(!showAchievements)} className="btn-press"
              style={{ background: 'none', border: 'none', color: 'white', width: '100%', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: 'pointer' }}>
              <div style={styles.statsTitle}>üèÜ Achievements ({unlockedAchievements.length}/{Object.keys(ACHIEVEMENTS).length})</div>
              <span style={{ transform: showAchievements ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.3s' }}>‚ñº</span>
            </button>
            <div className="accordion-content" style={{ maxHeight: showAchievements ? '600px' : '0', opacity: showAchievements ? 1 : 0 }}>
              <div style={{ marginTop: '12px' }}>
                {unlockedAchievements.length > 0 && (
                  <div style={{ marginBottom: '16px' }}>
                    <div style={{ fontSize: '0.8rem', color: '#22c55e', marginBottom: '8px', fontWeight: '600' }}>Unlocked</div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '10px' }}>
                      {unlockedAchievements.map(a => (
                        <div key={a.id} className="card-lift" style={{ textAlign: 'center', padding: '14px 6px', background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(16, 185, 129, 0.15))', borderRadius: '16px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                          <div style={{ fontSize: '1.8rem', marginBottom: '6px' }} className="badge-shine">{a.icon}</div>
                          <div style={{ fontSize: '0.75rem', fontWeight: '600' }}>{a.name}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                {lockedAchievements.length > 0 && (
                  <div>
                    <div style={{ fontSize: '0.8rem', color: '#64748b', marginBottom: '8px', fontWeight: '600' }}>Locked</div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '10px' }}>
                      {lockedAchievements.map(a => (
                        <div key={a.id} style={{ textAlign: 'center', padding: '14px 6px', backgroundColor: 'rgba(255,255,255,0.03)', borderRadius: '16px', opacity: 0.6, border: '1px solid rgba(255,255,255,0.05)' }}>
                          <div style={{ fontSize: '1.8rem', marginBottom: '6px', filter: 'grayscale(100%)' }}>üîí</div>
                          <div style={{ fontSize: '0.75rem', fontWeight: '600', marginBottom: '4px' }}>{a.name}</div>
                          <div style={{ fontSize: '0.6rem', color: '#64748b', lineHeight: 1.3 }}>{a.description}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Mode Stats */}
          {Object.entries(GAME_MODES).map(([key, mode]) => {
            const modeAccuracy = getAccuracy(stats[key].totalCorrect, stats[key].totalAnswered);
            return (
              <div key={key} style={styles.statsCard} className="card-lift">
                <div style={styles.statsTitle}><span>{mode.icon}</span><span>{mode.name}</span></div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
                  <div style={{ position: 'relative' }}>
                    <ProgressRing progress={modeAccuracy} size={60} strokeWidth={5} color={modeAccuracy >= 80 ? '#22c55e' : modeAccuracy >= 50 ? '#f97316' : '#ef4444'} value={`${modeAccuracy}%`} />
                  </div>
                  <div style={{ flex: 1, display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }}>
                    <div style={styles.statItem}><div style={styles.statValue}>{stats[key].totalAnswered}</div><div style={styles.statLabel}>Answered</div></div>
                    <div style={styles.statItem}><div style={styles.statValue}>{stats[key].bestStreak}</div><div style={styles.statLabel}>Best Streak</div></div>
                    <div style={styles.statItem}><div style={styles.statValue}>{stats[key].totalCorrect}</div><div style={styles.statLabel}>Correct</div></div>
                  </div>
                </div>
              </div>
            );
          })}
          <button onClick={handleShare} className="btn-press" style={styles.shareBtn}>üì§ Share Results</button>
          <button onClick={() => { if (confirm('Reset all statistics?')) { resetStats(); addToast('Stats reset', 'info'); } }} className="btn-press" style={styles.dangerBtn}>
            Reset All Statistics
          </button>
        </div>
      );
    }

    // Settings View
    function SettingsView() {
      const { settings, updateSettings } = useSettings();
      const { sfxEnabled, setSfxEnabled } = useSoundEffects();

      const Toggle = ({ checked, onChange }) => (
        <button onClick={() => { onChange(!checked); triggerHaptic('light'); }} className="btn-press"
          style={{ ...styles.toggle, backgroundColor: checked ? '#a855f7' : 'rgba(255, 255, 255, 0.2)' }}>
          <div style={{ ...styles.toggleKnob, left: checked ? '24px' : '2px' }} />
        </button>
      );

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Settings' }]} />
          <div style={styles.card}>
            <h3 style={styles.cardTitle}>Settings</h3>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Instrument</span>
              <select value={settings.instrument} onChange={(e) => updateSettings({ instrument: e.target.value })} style={styles.select}>
                {Object.entries(INSTRUMENTS).map(([key, inst]) => (<option key={key} value={key}>{inst.name}</option>))}
              </select>
            </div>
            <div style={styles.settingRow}>
              <div>
                <span style={styles.settingLabel}>Use MIDI sounds</span>
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginTop: '2px' }}>Realistic sampled instruments</div>
              </div>
              <Toggle checked={settings.useMidi} onChange={(val) => updateSettings({ useMidi: val })} />
            </div>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Auto-play on new round</span>
              <Toggle checked={settings.autoPlayOnStart} onChange={(val) => updateSettings({ autoPlayOnStart: val })} />
            </div>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Volume</span>
              <VolumeSlider value={settings.volume} onChange={(val) => updateSettings({ volume: val })} />
            </div>
            <div style={styles.settingRow}>
              <span style={styles.settingLabel}>Sound effects</span>
              <Toggle checked={sfxEnabled} onChange={setSfxEnabled} />
            </div>
            <div style={styles.settingRow}>
              <div>
                <span style={styles.settingLabel}>Practice Mode</span>
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginTop: '2px' }}>Learn without scoring pressure</div>
              </div>
              <Toggle checked={settings.practiceMode} onChange={(val) => updateSettings({ practiceMode: val })} />
            </div>
            <div style={{ ...styles.settingRow, borderBottom: 'none' }}>
              <span style={styles.settingLabel}>Show octave in choices</span>
              <Toggle checked={settings.showOctaveInChoices} onChange={(val) => updateSettings({ showOctaveInChoices: val })} />
            </div>
          </div>
          <div style={{ ...styles.card, marginTop: '16px' }}>
            <h3 style={styles.cardTitle}>About</h3>
            <p style={{ color: '#94a3b8', fontSize: '0.9rem', lineHeight: 1.6 }}>
              KeyPerfect is an ear training app to help musicians recognize notes, intervals, chords, scales, and progressions.
            </p>
            <p style={{ color: '#64748b', fontSize: '0.8rem', marginTop: '12px' }}>Version 4.0 (Enhanced UI)</p>
          </div>
        </div>
      );
    }

    // Main Menu
    function MainMenu({ onStartGame }) {
      const [selectedMode, setSelectedMode] = useState('notes');
      const [selectedDifficulty, setSelectedDifficulty] = useState('easy');
      const { settings } = useSettings();

      const getDifficulties = () => {
        const map = { notes: NOTE_DIFFICULTIES, intervals: INTERVAL_DIFFICULTIES, chords: CHORD_DIFFICULTIES, scales: SCALE_DIFFICULTIES, progressions: PROGRESSION_DIFFICULTIES };
        return map[selectedMode];
      };

      return (
        <div style={{ flex: 1 }} className="page-enter">
          <Breadcrumbs items={[{ label: 'Play' }]} />
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>Select Game Mode</h2>

            {/* Horizontal scrolling mode selector */}
            <div style={styles.modeScroll}>
              {Object.entries(GAME_MODES).map(([key, mode]) => (
                <button key={key} onClick={() => { setSelectedMode(key); triggerHaptic('light'); }}
                  className="btn-press card-lift" style={{ ...styles.modeCard, ...(selectedMode === key ? styles.modeCardActive : {}) }}>
                  <span style={styles.modeIcon}>{mode.icon}</span>
                  <div style={styles.modeName}>{mode.name}</div>
                  <div style={styles.modeDesc}>{mode.description}</div>
                </button>
              ))}
            </div>

            <h3 style={{ ...styles.cardTitle, marginTop: '24px', marginBottom: '16px' }}>Difficulty</h3>

            {/* Chip-style difficulty selector */}
            <div style={styles.difficultyChips}>
              {Object.entries(getDifficulties()).map(([key, diff]) => (
                <button key={key} onClick={() => { setSelectedDifficulty(key); triggerHaptic('light'); }}
                  className="btn-press" style={{ ...styles.difficultyChip, ...(selectedDifficulty === key ? styles.difficultyChipActive : {}) }}>
                  {diff.label}
                </button>
              ))}
            </div>

            {/* Difficulty description */}
            <p style={{ textAlign: 'center', color: '#94a3b8', fontSize: '0.85rem', marginBottom: '24px' }}>
              {getDifficulties()[selectedDifficulty]?.description}
            </p>

            {/* Practice mode indicator */}
            {settings.practiceMode && (
              <div style={{ textAlign: 'center', padding: '10px', backgroundColor: 'rgba(168, 85, 247, 0.15)', borderRadius: '12px', fontSize: '0.85rem', color: '#a855f7', marginBottom: '16px', border: '1px solid rgba(168, 85, 247, 0.3)' }}>
                üéì Practice Mode Active
              </div>
            )}

            <button onClick={() => { onStartGame(selectedMode, selectedDifficulty); triggerHaptic('medium'); }}
              className="btn-press floating-btn" style={styles.startBtn}>
              Start Game
            </button>
          </div>
        </div>
      );
    }

    // ============================================
    // MAIN APP
    // ============================================

    function App() {
      const [view, setView] = useState('play');
      const [gameMode, setGameMode] = useState(null);
      const [gameDifficulty, setGameDifficulty] = useState(null);

      const handleStartGame = (mode, difficulty) => { setGameMode(mode); setGameDifficulty(difficulty); };
      const handleBackToMenu = () => { setGameMode(null); setGameDifficulty(null); };
      const handleTitleClick = () => { setView('play'); handleBackToMenu(); };

      const renderGameView = () => {
        if (!gameMode) return <MainMenu onStartGame={handleStartGame} />;
        const games = { notes: NoteGame, intervals: IntervalGame, chords: ChordGame, scales: ScaleGame, progressions: ProgressionGame };
        const GameComp = games[gameMode];
        return <GameComp difficulty={gameDifficulty} onBack={handleBackToMenu} />;
      };

      return (
        <div style={styles.container}>
          <header style={styles.header}>
            <h1 style={styles.title} onClick={handleTitleClick}>KeyPerfect</h1>
            <p style={styles.subtitle}>Train your musical ear</p>
          </header>

          {view === 'play' && renderGameView()}
          {view === 'learn' && !gameMode && <LearnView />}
          {view === 'stats' && !gameMode && <StatsView />}
          {view === 'settings' && !gameMode && <SettingsView />}

          {!gameMode && <BottomNav currentView={view} setView={setView} />}
        </div>
      );
    }

    // ============================================
    // RENDER
    // ============================================

    ReactDOM.render(
      <SettingsProvider>
        <StatsProvider>
          <ToastProvider>
            <App />
          </ToastProvider>
        </StatsProvider>
      </SettingsProvider>,
      document.getElementById('root')
    );
  </script>
</body>
</html>
